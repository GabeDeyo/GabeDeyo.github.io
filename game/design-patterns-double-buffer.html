<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Design Patterns - Double Buffer</title>

    <meta name="viewport" content="width=device-width,initial-scale=1.0, shrink-to-fit=no" />

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/page.css">
</head>

<body>

    <!-- Top Navigation -->
    <header>
        <nav class="navbar navbar-inverse">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapsemenu" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a href="../index.html" class="navbar-brand">Personal Notes</a>
                </div>

                <div class="collapse navbar-collapse" id="collapsemenu">
                    <ul class="nav navbar-nav">

                        <!-- GAME DEVELOMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Game Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- CONCEPTS -->
                                <li><a href="concepts.html">Concepts <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ENGINE -->
                                <li><a href="engine.html">Engine <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- IMPLEMENTATIONS -->
                                <li><a href="implementations.html">Implementations <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- GABE DEVELOPMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Gabe Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- FITNESS PAGE -->
                                <li><a href="../gabe/fitness.html">Fitness <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- STYLE & GROOMING PAGE -->
                                <li><a href="../gabe/style.html">Style <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- FINANCE PAGE -->
                                <li><a href="../gabe/finance.html">Finance <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PHILOSOPHY PAGE -->
                                <li><a href="../gabe/philosophy.html">Philosophy <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                    </ul>
                </div>

            </div>
        </nav>
    </header>

    <!-------------------------------------------------------------------------->

    <!-- MAIN -->
    <main>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h1 id="title">Design Patterns - Double Buffer</h1>

                    <aside>
                        <button type="button" class="btn btn-default" name="button" id="selectAll">Select All</button>
                        <button type="button" class="btn btn-default" name="button" id="clearAll">Clear All</button>
                    </aside>

                    <div class="jumbotron heliList">
                        <h2>Index</h2>
                        <ul>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#intent">Intent</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#motivation">Motivation</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#double-buffer">Double Buffer</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#when-to-use">When to Use It</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#keep-in-mind">Keep In Mind</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#sample-code">Sample Code</a>
                                </p>
                            </li>
                        </ul>
                    </div>

<div class="jumbotron col-md-12 heliList" id="intent">
    <h2>Intent</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            <i>Cause a series of sequential operations to appear instantaneous or simultaneous.</i>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="motivation">
    <h2>Motivation</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In their hearts, computers are sequential beasts. Their pwer comes from being able to break down the largest tasks into tiny steps that can be performed one after another. Often, though our users need to see things occur in a single instantaneous step or see multiple tasks performed simultaneously.
            <p><span class="glyphicon-remove"></span>With threading and multi-core architectures this is becoming less true, but even with several cores, only a few operations are running concurrently.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            A typical example, and one that every game engine must address, is rendering. When the game draws the world the users see, it does so one piece at a time - the mountains in the distance, the rolling hills, the trees, each in its turn. If the user <i>watched</i> the view draw incrementally like that, the illusion of a coherent world would be shattered. The scene must update smoothly and quickly, displaying a series of complete frames, each appearing instantly.
            <p><span class="glyphicon-remove"></span><b>Double Buffer</b> solves this problem, but to understand how, we first need to review how a computer displays graphics.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>How Computer Graphics Work (briefly)</b>
            <p><span class="glyphicon-remove"></span>A video display like a computer monitor draws one pixel at a time. It sweeps across each row of pixels from left to right and then moves down to the next row. When it reaches the bottom corner, it scans back up to the top left and starts all over again. It does this so fast - around 60 times a second - that our eyes can't see the scanning. To use, it's a single static field of colored pixels - an image.</p>
            <p><span class="glyphicon-remove"></span>You can think of this process like a tiny hose that pipes pixels to the display. Individual colors go into the back of the hose, and it sprays them out across the display, one bit of color to each pixel in its turn. So how does the hose know what colors go where?</p>
            <p><span class="glyphicon-remove"></span>In most computers, the answer is that it pulls them from a <i>framebuffer</i>. A framebuffer is an array of pixels in memory, a chunk of RAM where each couple of bytes represents the color of a single pixel. As the hose sprays across the display, it reads in the color values from this array, one byte at a time.</p>
            <p><span class="glyphicon-remove"></span>Ultimately, in order to get our game to appear on screen, all we do is write to that array. All of the crazy graphics algorithms we have boil down to just that: setting byte values in the frame buffer. But there's a little problem.</p>
            <p><span class="glyphicon-remove"></span>Earlier, I said computers are sequential. If the machine is executing a chunk of our rendering code, we don't expect it to be doing anything else at the same time. That's mostly accurate, but a couple of things do happen in the middle of our program running. One of those is that the video display will be reading from the framebuffer <i>constantly</i> while our game runs. This can cause a problem for us.</p>
            <p><span class="glyphicon-remove"></span>Let's say we want a happy face to appear on screen. Our program starts looping through the framebuffer, coloring pixels. What we don't realize is that the video driver is pulling from the framebuffer right as we're writing into it. As it scans across the pixels we've written, our face starts to appear, but then it outpaces us and moves into pixels we haven't written out yet. The result is <i>tearing</i>, a hideous visual bug where you see half of something drawn on screen.</p>
            <p><span class="glyphicon-remove"></span>This is why we need this pattern. Our program renders the pixels one at a time, but we need the display driver to see them all at once - in one frame the face isn't there, and in the next one it is. Double buffering solves this. I'll explain with an analogy.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Act 1, Scene 1</b>
            <p><span class="glyphicon-remove"></span>Imagine our users are watching a play produced by us. As scene one end and scene two starts, we need to change the stage setting. If we have the stagehands run on after the scene and start draggging props around, the illusion of a coherent place will be broken. We could dim the lights while we do that (which, of course, is what real theaters do), but the audience still knows something is going on. We have there to be no gap in time between scenes.</p>
            <p><span class="glyphicon-remove"></span>With a bit of real estate, we come up with this clever solution: we build two stages set up so the audience can see both. Each has its own set of lights. We'll call them stage A and stage B. Scene one is shown on stage A. Meanwhile, stage B is dark as the stagehands are setting up scene two. As soon as scene one ends, we cut the lights on stage A and bring them up on stage B. The audience looks to the new stage and scene two begins immediatly.</p>
            <p><span class="glyphicon-remove"></span>At the same time, our stagehands are over on the now darkened stage A, striking scene one and setting up scene 3. As soon as scene two ends, we switch the light back to stage A again. We continue this process for the entire play, using the darkened stage as a work area where we can set up the next scene. Every scene transition, we just toggle the lights between the two stages. Our audience gets a continuous performance with no delay between scenes. They never see a stagehand.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Back to the Graphics</b>
            <p><span class="glyphicon-remove"></span>That is exactly how double buffering works, and this process underlies the rendering system of just about every game you've ever seen. Instead of a single framebuffer, we have <i>two</i>. One of them represents the current frame, stage A in our analogy. It's the one the video hardward is reading from. The GPU can scan through it as much as it wants whenever it wants.</p>
            <p><span class="glyphicon-remove"></span>Meanwhile, our rendering code is writing to the <i>other</i> framebuffer. This is our darkened stabe B. When our rendering code is done drawing the scene, it switches the lights by <i>swapping</i> the buffers. This tells the video hardware to start reading from the second buffer now instead of the first one. As long as it times that switch at the end of a refresh, we won't get any tearing, and the entire scene will appear at once.</p>
            <p><span class="glyphicon-remove"></span>And now, the old framebuffer is available for use. We start rendering the next frame onto it.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="double-buffer">
    <h2>Double Buffer</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            A <b>buffered class</b> encapsulates a <b>buffer</b>: a piece of state that can be modified. This buffer is edited incrementally, but we want all outside code to see the edit as a single atomic change. To do this, the class keeps <i>two</i> instances of the buffer: a <b>next buffer</b> and a <b>current buffer</b>.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            When information is read <i>from</i> a buffer, it is always from the <i>current</i> buffer. When information is written <i>to</i> a buffer, it occurs on the <i>next buffer</i>. When the changes are complete, a <b>swap</b> operation swaps the next and current buffers instantly so that the new buffer is now publicly visible. The old current buffer is now available to be reused as the new next buffer.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="when-to-use">
    <h2>When to Use It</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            This pattern is one of those ones where you'll know when you need it. If you have a system that lacks double buffering, it will probably look visibly wrong or behave incorrectly. But saying, "you'll know when you need it" doesn't give you much to go on. More specifically, this pattern is appropriate when all of these are true:
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            &nbsp; &bull; We have some state that is being modified incrementally.
            <br> &nbsp; &bull; That same state may be accessed in the middle of modification.
            <br> &nbsp; &bull; We want to prevent the code that's accessing the state from seeing the work in progress.
            <br> &nbsp; &bull; We want to be able to read the state and we don't want to have to wait while it's being written.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="keep-in-mind">
    <h2>Keep In Mind</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Unlike larger architectural patterns, double buffering exists at a lower implementaiton level. Because of this, it has fewer consequences for the rest of the codebase - most of the game won't even be aware of the difference. There are a couple caveats, though.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>The Swap Itself Takes Time</b>
            <p><span class="glyphicon-remove"></span>Double-buffering requires a <i>swap</i> step once the state is done being modified. That operation must become atomic - no code can access <i>either</i> state while they are being swapped. Often, this is a quick as assigning a pointer, but if it takes longer to swap than it does to modify the state to begin with, then we haven't helped ourselves at all.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>We Have to have Two Buffers</b>
            <p><span class="glyphicon-remove"></span>The other consequence of this pattern is increased memory usage. As its name implies, the pattern requires you to keep <i>two</i> copies of your state in memory at all times. On memory-constrained devices, this can be a heavy price to pay. If you can't afford two buffers, you may have to look inot other ways to ensure your state isn't being accessed during modification.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="sample-code">
    <h2>Sample Code</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Now that we've got the theory, let's see how it works in practice. We'll write a very bare-bones graphics system that lets us draw pixels on a framebuffer. In most console and PCs, the video driver provides this low-level part of the graphics system, but implementing it by hand here will let us see what's going on.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            First up is the buffer itself:
            <pre>
            <span class="glyphicon-remove"></span>class Framebuffer {
                public Framebuffer() { clear(); }

                public void clear() {
                    for(int i = 0; i < WIDTH * HEIGHT; i++) {
                        pixels_[i] = WHITE;
                    }
                }

                public void draw() {
                    pixels_[(WIDTH * y) + x] = BLACK;
                }

                public const char* getPixels() {
                    return pixels_;
                }

                private static const int WIDTH = 160;
                private static const int HEIGHT = 120;

                private char pixels_[WIDTH * HEIGHT];
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            It has basic operations for clearing the entire buffer to a default color and setting the color of an individual pixel. It also has a function, getPixels(), to expose the raw array of memory holding the pixel data. We won't see this in the example, but the video driver will call a function frequently to stream memory from the buffer onto the screen.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We wrap this raw buffer in a Scene class. It's job here is to render something by making a bunch of draw() calls on its buffer:
            <pre>
            <span class="glyphicon-remove"></span>class Scene {
                public void draw() {
                    buffer_.clear();
                    //Draw a smiley face
                    buffer_.draw(1, 1);
                    buffer_.draw(4, 1);
                    buffer_.draw(1, 3);
                    buffer_.draw(2, 4);
                    buffer_.draw(3, 4);
                    buffer_.draw(4, 3);
                }

                public Framebuffer&amp; getBuffer() { return buffer_; }

                private Framebuffer buffer_;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Every frame, the game tells the scene to draw. The scene clears the buffer and then draws a bunch of pixels, one at a time. It also provides access to the internal buffer through getBuffer() so that the video driver can change to it.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            This seems pretty straightforward, but if we leave it like this, we'll run into problems. The trouble is that the video driver can call getPixels() on the buffer at <i>any</i> point in time, even here:
            <pre>
            <span class="glyphicon-remove"></span>buffer_.draw(1, 1);
            buffer_.draw(4, 1);
            buffer_.draw(1, 3);
            // Video driver reads pixels here!
            buffer_.draw(2, 4);
            buffer_.draw(3, 4);
            buffer_.draw(4, 3);
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            When that happens, the user will see the eyes of the face, but the mouth will disappear for a single frame. In the next frame, it could get interrupted at some other point. The end result is horribly flickering graphics. We'll fix this with double buffering:
            <pre>
            <span class="glyphicon-remove"></span>class Scene {
                public Scene() : current_(&amp;buffers_[0]), next_(&amp;buffers[1]) {}

                public void draw() {
                    next_->clear();
                    next_->draw(1, 1);
                    // ...
                    next_->draw(4, 3);

                    swap();
                }

                public Framebuffer&amp; getbuffer() { return *current_; }

                private void swap() {
                    //Just switch the pointers.
                    Framebuffer* temp = current_;
                    current = next_;
                    next_ = temp;
                }

                private Framebuffer buffers_[2];
                private Framebuffer* current_;
                private Framebuffer* next_;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Now Scene has two buffers, stored in the buffers_ array. We don't directly reference them fromthe array. Instead, there are two members, next_ and current_, that point into the array. When we draw, we draw onto the next buffer, referenced by next_. when the video driver needs to get the pixels, it always accesses the <i>other</i> buffer through current_;
            <p><span class="glyphicon-remove"></span>This way, the video driver never sees the buffer that we're working on. The only remaining piece of the puzzle is the call to swap() when the scene is done drawing the frame. That swaps the two buffers by simply switching the next_ and current_ references. The next time the video driver calls getBuffer(), it will get the new buffer we just finished drawing and put our recently drawn buffer on screen. No more tearing or unsightly glitches.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Not Just for Graphics</b>
            <p><span class="glyphicon-remove"></span></p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

                    <!-------------------------------------->
                </div>
            </div>
    </main>

    <!-------------------------------------------------------------------------->

    <!-- FOOTER -->
    <footer class="navbar navbar-inverse navbar-fixed-bottom">
        <nav>
            <div class="container">
                <div class="row">
                    <div class="col-md-6 col-sm-6 col-xs-12">
                        <ul>
                            <li>&copy; 2017 <a href="http://www.gabedeyo.com">Gabe Deyo</a></li>
                            <li>|</li>
                            <li><a href="mailto:gabedeyo@gmail.com?subject=Notes">gabedeyo@gmail.com</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>
    </footer>

    <!-- Latest Minified Slim JQuery -->
    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

    <script src="../js/selection.js" charset="utf-8"></script>
</body>

</html>

<!-- Section Template

<div class="jumbotron col-md-12 heliList" id="">
    <h2>XXX</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

-->
