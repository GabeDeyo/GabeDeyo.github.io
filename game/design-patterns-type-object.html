<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Design Patterns - Type Object</title>

    <meta name="viewport" content="width=device-width,initial-scale=1.0, shrink-to-fit=no" />

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/page.css">
</head>

<body>

    <!-- Top Navigation -->
    <header>
        <nav class="navbar navbar-inverse">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapsemenu" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a href="../index.html" class="navbar-brand">Personal Notes</a>
                </div>

                <div class="collapse navbar-collapse" id="collapsemenu">
                    <ul class="nav navbar-nav">

                        <!-- GAME DEVELOMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Game Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- CONCEPTS -->
                                <li><a href="concepts.html">Concepts <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ENGINE -->
                                <li><a href="engine.html">Engine <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- IMPLEMENTATIONS -->
                                <li><a href="implementations.html">Implementations <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- GABE DEVELOPMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Gabe Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- FITNESS PAGE -->
                                <li><a href="../gabe/fitness.html">Fitness <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- STYLE & GROOMING PAGE -->
                                <li><a href="../gabe/style.html">Style <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- FINANCE PAGE -->
                                <li><a href="../gabe/finance.html">Finance <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PHILOSOPHY PAGE -->
                                <li><a href="../gabe/philosophy.html">Philosophy <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                    </ul>
                </div>

            </div>
        </nav>
    </header>

    <!-------------------------------------------------------------------------->

    <!-- MAIN -->
    <main>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h1 id="title">Design Patterns - Type Object</h1>

                    <aside>
                        <button type="button" class="btn btn-default" name="button" id="selectAll">Select All</button>
                        <button type="button" class="btn btn-default" name="button" id="clearAll">Clear All</button>
                    </aside>

                    <div class="jumbotron heliList">
                        <h2>Index</h2>
                        <ul>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#intent">Intent</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#motivation">Motivation</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#type-object">Type Object</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#when-to-use">When to Use It</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#keep-in-mind">Keep In Mind</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#sample-code">Sample Code</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#design-decisions">Design Decisions</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#see-also">See Also</a>
                                </p>
                            </li>
                        </ul>
                    </div>

<div class="jumbotron col-md-12 heliList" id="intent">
    <h2>Intent</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            <i>Allow the flexible creation of new "classes" by creating a single class, each instance of which represents a different type of object.</i>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="motivation">
    <h2>Motivation</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Imagine we're working on a fantasy role-playing game. Our task is to write the code for the hordes of vicious monsters that seek to slay our brave hero. Monsters have a bunch of different attrivutes: health, attacks, graphics, sounds, etc., but for example purposes we'll just worry abou the first two.
            <p><span class="glyphicon-remove"></span>Each monster in the game has a value for its current health. It starts out full, and each time the monster is wounded, it diminished. Monsters also have an attack string. When the monster attacks our hero, that text will be shown to the user somehow.</p>
            <p><span class="glyphicon-remove"></span>The designers tell us that monsters come in a variety of different <i>breeds</i>, like "dragon" or "troll". Each breed describes a <i>kind</i> of monster that exists in the game, and there can be multiple monsters of the same breed running around in the dungeon at the same time.</p>
            <p><span class="glyphicon-remove"></span>The breed determines a monster's starting health - dragons start off with more than trolls, making them harder to kill. It also determines the attack string - all monsters of the same breed attack the same way.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>The typical OOP answer</h3>
            <p><span class="glyphicon-remove"></span>With that game design in mind, we fire up our text editor and start coding. According to the design, a dragon is a kind of monster, a troll is another kind, and so on with the other breeds. Thinking object-oriented, that leads us to a Monster base clase:</p>
            <pre>
            <span class="glyphicon-remove"></span>class Monster {
                public virtual ~Monster() {}
                public virtual const char* getAttack() = 0;

                protected Monster(int startingHealth) : health_(startingHealth) {}

                private int health_; // Current Health
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The public getAttack() function lets the combat code get the string that should be displayed when the monster attacks the hero. Each derived breed class will override this to provide a different message.
            <p><span class="glyphicon-remove"></span>The constructor is protected and takes the starting health for the monster. We'll have derived classes for each breed that provide their own public constructors that call this one, passing in the starting health that is appropriate for that breed.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Now let's see a couple of breed subclasses:
            <pre>
            <span class="glyphicon-remove"></span>class Dragon : public Monster {
                public Dragon() : Monster(230) {}

                public virtual const char* getAttack() {
                    return "The dragon breathes fire!";
                }
            }

            class Troll : public Monster {
                public Troll() : Monster(48) {}

                public virtual const char* getAttack() {
                    return "The troll clubs you!";
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Each class derived from Monster passes in the starting health and overrides getAttack() and return the attack string for that breed. Everything works as expected, and before long, we've got our hero running around slaying a variety of beasties. We keep slinging code, and before we know it, we've got dozens of monster subclasses, from acidic slimes to zombie goats.
            <p><span class="glyphicon-remove"></span>Then, strangely, things start to bog down. Our designers ultimatly want to have <i>hundreds</i> of breeds, and we find ourselves spending all our time writing these little seve-line subclasses and recompiling. It gets worse - the designers want to start tuning the breeds we've already coded. Our formerly productive workday degenerates to:</p>
            <p><span class="glyphicon-remove"></span> &nbsp; 1. Get email from designer asking to change health of troll from 48 to 52.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; 2. Check out and change Troll.h</p>
            <p><span class="glyphicon-remove"></span> &nbsp; 3. Recompile game.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; 4. Reply to email.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; 5. Repeat.</p>
            <p><span class="glyphicon-remove"></span>We spend the day frustrated because we've been turned into data-monkeys. Our designers are frustrated because it takes forever to get a simple number changed. What we need is the ability to change breed stats without having to recompile the whole game every time. Even better, we'd like designers to be able to create and tune breeds without <i>any</i> programmer intervention at all.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>A class for a class</h3>
            <p><span class="glyphicon-remove"></span>At a very high level, the problem we're trying to solve is pretty simple. We have a bunch of different monsters in the game, and we want to share certain attributes between them. A horde of monsters are beating on the hero, and we want some of them to use the same text for their attack. We define that by saying that all of those monsters are the same "breed", and that the breed determines the attack string.</p>
            <p><span class="glyphicon-remove"></span>We decided to implement this concept using inheritance since it lines up with our intuition of classes. A dragon is a monster, and each dragon in the game is an instance of this dragon "class". Defining each breed as a subclass of an abstract base Monster class, and having each monster in the game be an instance of that derived breed class mirrors that. We end up with a class hierarchy where all breed subclasses independently inherit from Monster.</p>
            <p><span class="glyphicon-remove"></span>Each instance of a monster in the game will be of one of the derived monster types. The more breeds we have, the bigger the class hierarchy. That's the problem of course: adding new breeds means adding new code, and each breed has to be compiled in as its own type.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            This works, but it isn't the only option. We could also architect our code so that each monster <i>has</i> a breed. Instead of subclassing Monster for each breed, we have a single Monster class and a single Breed class. So now we have a class hierarchy where simply Monster is referenced by Breed.
            <p><span class="glyphicon-remove"></span>That's it. Two classes. Notice that there's no inheritance at all. With this system, each monster in the game is simply an instance of class Monster. The Breed class contains the information that's shared between all monsters of the same breed: starting health and the attack string.</p>
            <p><span class="glyphicon-remove"></span>To associate monsters with breeds, we give each Monster instance a reference to a Breed object containing the information on its breed. The Breed class essentially defines a monster's "type". Each breed instance is an <i>object</i> that represents a different conceptual <i>type</i>, hence the name of the pattern: Type Object.</p>
            <p><span class="glyphicon-remove"></span>What's especially powerful about this pattern is that now we can define new <i>types</i> of things without complicating the codebase at all. We've essentially lifted a portion of the type system out of the hard-coded class hierarchy into data we can define at runtime.</p>
            <p><span class="glyphicon-remove"></span>We can create hundreds of different breeds by instantiating more instances of Breed with different values. If we create breeds by initializing them from data read from some configuration file, we have the ability to define new types of monster completely in data. So easy, a designer could do it!</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="type-object">
    <h2>Type Object</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Define a <b>type object</b> class and a <b>typed object</b> class. Each type object instance represents a different logical type. Each type object stores a <b>reference to the type object that describes its type.</b>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Instance-specific data is stored in the typed object instance, and data or behavior that should be shared across all instances of the same conceptual type is stored in the type object. Objects referencing the same type object will function as if they were the same type. This lets us share data and behavior across a set of similar objects, much like subclassing lets us do, but without having a fixed set of hard-coded subclasses.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="when-to-use">
    <h2>When to Use It</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            This pattern is useful anytime you need to define a variety of different "kinds" of things, but baking the kinds into your language's type system is too rigid. In particular, it's useful when either of these is true:
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; You don't know what types you will need up front. (For example, what if our game needs to support downloading content that contained new breeds of monster?)</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; You want to be able to modify or add new types without having to recompile or change code.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="keep-in-mind">
    <h2>Keep In Mind</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            This pattern is about moving the definition of a "type" from the imperative but rigid language of code into the more flexible but less behavioral world of objects in memory. The flexibility is good, but you lose some things by hoisting your types into data.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>The type objects have to be tracked manually</h3>
            <p><span class="glyphicon-remove"></span>One advantage of using something like C++'s type system is that the compiler handles all fo the bookkeeping for the classes automatically. The data that defines each class is automatically compiled into the static memory segment of the executable and just works.</p>
            <p><span class="glyphicon-remove"></span>With the Type Object pattern, we are now responsible for managing not only our monsters in memory, but also their <i>types</i> - we have to make sure all of the breed objects are instantiated and kept in memory as long as our monsters need them. Whenever we create a new monster, it's up to us to ensure that it's correctly initialized with a reference to a valid breed.</p>
            <p><span class="glyphicon-remove"></span>We've freed ourselves from some of the limitations of the compiler, but the cost is that we have to re-implement some of what it used to be doing for us.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>It's harder to define <i>behavior</i> for each type</h3>
            <p><span class="glyphicon-remove"></span>With subclassing, you can override a method and do whatever you want to - calculate values procedurally, call other code, etc. The sky is the limit. We could define a monster subclass whose attack string changed based on the phase of the moon if we wanted to. (Hand for werewolves, I suppose.)</p>
            <p><span class="glyphicon-remove"></span>When we use the Type Object pattern instead, we replace an overridden method with a member variable. Instead of having monster subclasses that override a method to <i>calculate</i> an attack string using different <i>code</i>,we have a breed object that <i>stores</i> an attack string in a different <i>variable</i>.</p>
            <p><span class="glyphicon-remove"></span>This makes it very easy to use type objects to define type-specific <i>data</i>, but hard to define type-specific <i>behavior</i>. If, for example, different breeds of monsters needed to use different AI algorithms, using this pattern becomes more challenging.</p>
            <p><span class="glyphicon-remove"></span>There are a couple of ways we can get around this limitation. A simple solution is to have a fixed set of pre-defined behaviors and then use data in the type object ot simply <i>select</i> one of them. For example, let's say our monster AI will always be either "standing still", "chasing her", or "whimpering and cowering in fear". We can define functions to implement each of those behaviors. Then, we can associate an AI algorithm with a breed by having it store a pointer to the appropriate function.</p>
            <p><span class="glyphicon-remove"></span>Another more powerful solution is to actually support defining behavior completely in data. The Interpreter and Bytecode patterns both let us build object that represent behavior. If we read in a data file and use that to create a data structure for one of those patterns, we've moved the behavior's definition completely out of code and into content.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="sample-code">
    <h2>Sample Code</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            For our first pass at an implementation, let's start simple and build the basic system described in the motivation section. We'll start with the Breed class:
            <pre>
            <span class="glyphicon-remove"></span>class Breed {
                public Breed(int health, const char* attack) : health_(health), attack_(attack) {}

                public int getHealth() { return health_; }
                public char* getAttack() { return attack_; }

                private int health_;
                private const char* attack_;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Very simple. It's basically just a container for two data fields: the starting health and the attack string. Let's see how monster use it:
            <pre>
            <span class="glyphicon-remove"></span>class Monster {
                public Monster(Breed&amp; breed) : health_(breed.getHealth()), breed_(breed) {}

                public const char* getAttack() {
                    return breed_.getAttack();
                }

                private int health_;
                private Breed&amp; breed_;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            When we construct a monster, we give it a reference to a breed object. This defines the monster's breed instead of the subclasses we were previously using. In the constructor, Monster uses the breed to determine its starting health. To get the attack string, the monster simply forwards the call to its breed.
            <p><span class="glyphicon-remove"></span>This very simple chunk of code is the core idea of the pattern. Everything from here on out is bonus.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Making type objects more like types: constructors</h3>
            <p><span class="glyphicon-remove"></span>With what we know now, we construct a monster directly and are responsible for passing in its breed. This is a bit backwards form how regular objects are instantiated in most OOP languages - we don't usually allocate a blank chunk of memory and then <i>give</i> it its class. Instead, we call a constructor function on the class itself, and it's responsible for giving us a new instance.</p>
            <p><span class="glyphicon-remove"></span>We can apply this same pattern to our type objects:</p>
            <pre>
            <span class="glyphicon-remove"></span>class Breed {
                public Monster* newMonster() { return new Monster(*this); }

                // Previous Breed code...
            }
            </pre>
            <p><span class="glyphicon-remove"></span>And the class that uses them:</p>
            <pre>
            <span class="glyphicon-remove"></span>class Monster {
                friend class Breed;

                public const char* getAttack() { return breed_.getAttack(); }

                private Monster(Breed&amp; breed) : health_(breed.getHealth()), breed_(breed) {}

                private int health_;
                private Breed&amp; breed_;
            }
            </pre>
            <p><span class="glyphicon-remove"></span>They key difference is the newMonster() function in Bred. That's our "constructor" factory method. With our original implementation, creating a monster looked like: </p>
            <pre><span class="glyphicon-remove"></span>Monster* monster = new Monster(someBreed);</pre>
            <p><span class="glyphicon-remove"></span>After our changes, it's like this:</p>
            <pre><span class="glyphicon-remove"></span>Monster* monster = someBreed.newMonster();</pre>
            <p><span class="glyphicon-remove"></span>So, why do this? There are two steaps to creating an object: allocation and initialization. Monster's constructor lets us do all of the initialization we need. In our example, that's only storing the breed, but a full game would be loading graphics, initializing the monster's AI, and doing other set-up work.</p>
            <p><span class="glyphicon-remove"></span>However, that all happens <i>after</i> allocation. We've already got a chunk of memory to put our monster into before its constructor is called. In games, we often want to control that aspect of object creation too: we'll typically use things like custom allocators or the <a href="design-patterns-object-pool.html">Object Pool</a> pattern to control where in memory our objects end up.</p>
            <p><span class="glyphicon-remove"></span>Defining a "constructor" function in Breed gives us a place to put that logic. Instead of simply calling new, the newMonster() function can pull the memory from a pool or custom heap before passing control off to Monster for initialization. By putting this logic inside Breed, in the <i>only</i> function that has the ability to create monsters, we ensure that all monsters go through the memory management scheme we want.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Sharing data through inheritance</h3>
            <p><span class="glyphicon-remove"></span>What we have so far is a perfectly serviceable type object system, but it's pretty basic. Our game will eventually have <i>hundreds</i> of different breeds, each with dozens of attributes. If a designer wants to tune all of the thirty different breeds of troll to make them a little stronger, she's got a lot of tedious data entry ahead of her.</p>
            <p><span class="glyphicon-remove"></span>What would help is the ability to share attributes across multiple <i>breeds</i> in the same way that breeds let us share attributes across multiple <i>monsters</i>. Just like we did with our original OOP solution, we can solve this using inheritance. Only, this time, instead of using our language's mechanism, we'll implement it ourselves within our type objects.</p>
            <p><span class="glyphicon-remove"></span>To keep things simple, we'll only support single inheritance. In the same way that a class can have a parent base class, we'll allow a breed to have a parent breed:</p>
            <pre>
            <span class="glyphicon-remove"></span>class Breed {
                public Breed(Breed* parent, int health, const char* attack) : parent_(parent), health_(health), attack_(attack) {}

                public int getHealth();
                public const char* getAttack();

                private Breed* parent_;
                private int health_;
                private const char* attack_;
            }
            </pre>
            <p><span class="glyphicon-remove"></span>When we construct a breed, we give it a parent that it inherits from. We can pass in NULL for a base breed that has no ancestors.</p>
            <p><span class="glyphicon-remove"></span>To make this useful, a child breed needs to control which attributes are inherited from its parent and which attributes it overrides and specifies itself. For our example system, we'll say that a breed overrides the monster's health by having a non-zero value and overrides the attack by having a non-NULL string. Otherwise, the attribute will be inherited from its parent.</p>
            <p><span class="glyphicon-remove"></span>There are two ways we can implement this. One is to handle the delegation dynamically every time the attribute is requested, like this:</p>
            <pre>
            <span class="glyphicon-remove"></span>int Breed::getHealth() {
                //Override
                if(health_ != 0 || parent_ == NULL) return health_;

                //Inherit
                return parent_->getHealth();
            }

            const char* Breed::getAttack() {
                ///Override
                if(attack_ != NULL || parent_ == NULL) return attack_;

                //Inherit
                return parent_->getAttack();
            }
            </pre>
            <p><span class="glyphicon-remove"></span>This has the advantage of doing the right thing if a breed is modified at runtime to no longer override, or no longer inherit some attribute. On the other hand, it take a bit more memory (it has to retain a pointer to its parent), and it's slower. It has to walk the inheritance chain each time you look up an attribute.</p>
            <p><span class="glyphicon-remove"></span>If we can rely on a breed's attributes not changing, a faster solution is to apply the inheritance at <i>construction time</i>. This is called "copy-down" delelgation because we <i>copy</i> inherited attributes <i>down</i> into the derived type when it's created. It looks like this:</p>
            <pre>
            <span class="glyphicon-remove"></span>Breed(Breed* parent, int health, const char* attack) : health_(health), attack_(attack) {
                //Inherit non-overridden attributes
                if(parent != NULL) {
                    if(health == 0) health_ = parent->getHealth();
                    if(attack == NULL) attack_ = parent->getAttack();
                }
            }
            </pre>
            <p><span class="glyphicon-remove"></span>Note that we no longer need a field for the parent breed. Once the constructor is done, we can forget the parent since we've already copied all of its attributes in. To access a breed's attribute, now we just return the field:</p>
            <pre>
            <span class="glyphicon-remove"></span>int getHealth() { return health_; }
            const char* getAttack() { return attack_; }
            </pre>
            <p><span class="glyphicon-remove"></span>Nice and fast! Let's say our game engine is set up to create the breeds by loading a JSON file that defines them. It could look like:</p>
            <pre>
            <span class="glyphicon-remove"></span>{
                "Troll": {
                    "health": 25,
                    "attack": "The troll hits you!"
                },
                "Troll Archer": {
                    "parent": "Troll",
                    "health": 0,
                    "attack": "The troll archer fires an arrow!"
                },
                "Troll Wizard": {
                    "parent": "Troll",
                    "health": 0,
                    "attack": "The troll wizard casts a spell on you!"
                }
            }
            </pre>
            <p><span class="glyphicon-remove"></span>We'd have a chunk of code that reads each breed entry and instantiates a new breed instance with its data. As you can see from the "parent": "Troll" fields, the Troll Archer and Troll Wizard breeds inherit from the base Troll breed.</p>
            <p><span class="glyphicon-remove"></span>Since both of them have zero for their health, they'll inherit from the base Troll breed instead. This means now our designer can tune the health in Troll and all three breeds will be updated. As the number of breeds and the number of different attributes each breed has increase, this can be a big time-saver. Now, with a pretty small chunk of code, we have an open-ended system that puts control in our designers' hands and makes the best use of their time. Meanwhile, we can get back to coding other features.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="design-decisions">
    <h2>Design Decisions</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            The Type Object pattern lets us build a type system as if we were designing our own programming language. The design space is wide open, and we can do all sorts of interesting stuff.
            <p><span class="glyphicon-remove"></span>In practive, a few things curtail our fancy. Time and maintainability will discourage us from anything particularly complicated. More importantly, whatever type object system we design, our users (often non-programmers) will need to be able to easily understand it. The simpler we can make it, the more usable it will be. So what we'll cover here is the well-trodden design space, and we'll leave the far reaches for the academcs and explorers.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Is the type object encapsulated or exposed?</h3>
            <p><span class="glyphicon-remove"></span>In our sample implementation, Monster has a reference to a breed, but it doesn't publicly expose it. Outside code can't get directly at the monster's breed. From the codebase's perspective, monsters are essentially typeless, and the fact that they have breeds is an implemention detail.</p>
            <p><span class="glyphicon-remove"></span>We can easily change this and allow Monster to return its Breed:</p>
            <pre>
            <span class="glyphicon-remove"></span>class Monster {
                public Breed&amp; getBreed() { return breed_; }
                //Existing code...
            }
            </pre>
            <p><span class="glyphicon-remove"></span>Doing this changes the design of Monster. The fact that all monster have breeds is now a publicly visible part of its API. There are benefits with either choice.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>If the type object is encapsulated:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>The complexity of the Type Object pattern is hidden from the rest of the codebase.</i> It becomes an implementation detail that only the typed object has to worry about.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>The typed object can selectively override behavior form the type object.</i> Let's say we wanted to change the monster's attack string when it's near death. Since the attack string is always accessed through Monster, we have a convenient place to put that code:</p>
            <pre>
            <span class="glyphicon-remove"></span>const char* Monster::getAttack() {
                if(health_ < LOW_HEALTH) {
                    return "The monster flails weakly.";
                }
                return breed_.getAttack();
            }
            </pre>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; If outside code was calling getAttack() directly on the breed, we wouldn't have the opportunity to insert that logic.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>We have to write forwarding methods for everything the type object exposes.</i> This is the tedious part of this design. If our type object class has a large number of methods, the object class will have to have its own methods for each of the ones that we want to be publicly visible.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>If the type object is exposed:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>Outside code can interact with type objects without having an instance of the typed class.</i> If the type object is encapsulated, there's no way to use it without also having a typed object that wraps it. This prevents us, for example, from using our constructor pattern where new monsters are created by calling a method on the breed. If users can't get to breeds directly, they wouldn't be able to call it.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>The type object is now part of the object's public API.</i> In general, narrow interfaces are easier to maintain than wide ones - the less you expose to the rest of the codebase, the less complexity and maintenance you have to deal with. By exposing the type object, we widen the object's API to include everything the type object provides.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>How are typed objects created?</h3>
            <p><span class="glyphicon-remove"></span>With this pattern, each "object" is now a pair of objects: the main object and the type object it uses. So how do we create and bind the two together?</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>Construct the object and pass in its type object:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>Outside code can control allocation.</i> Since the calling code is constructing both objects itself, it can control where in memory that occurs. If we want our objects to be usable in a variety of different memory scenarios (different allocators, on the stack, etc.) this gives us the flexibility to do that.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>Call a "constructor" function on the type object:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>The type object controls memory allocation.</i> This is the other side of the coin. If we don't want users to choose where in memory our objects are created, requiring them to go through a factory method on the type object gives us control over that. This can be useful if we want to ensure all of our objects come from a certain object pool or other memory allocator.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Can the type change?</h3>
            <p><span class="glyphicon-remove"></span>So far, we've presumed that once an object is created and bound to its type object that that binding will never change. The type an object is created with is the type it dies with. This isn't strictly necessary. We <i>could</i> allow an object to change its type over time.</p>
            <p><span class="glyphicon-remove"></span>Let's look back at our example. When a monster dies, the designers tell us sometimes they want its corpse to become a reanimated zombie. We could implement this by spawning a new monster with a zombie breed when a monster dies, but another option is to simply get the existing monster and change its breed to a zombie one.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>If the type doesn't change:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>It's simpler both to code and to understand.</i> At a concept level, "type" is something most people probably will not expect to change. This codifies that assumption.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>It's easier to debug.</i> If we're trying to track down a bug where a monster gets into some weird state, it simplifies our job if we can take for granted that the breed we're looking at <i>now</i> is the breed the monster has always had.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>If the type can change:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>There's less object creation. In our example, if the type can't change, we'll be forced to burn CPU cycles creating a new zombie monster, copying over any attributes from the original monster that need to be preserved, and then deleting it. If we can change the type, all that work gets replaced by a simple assignment.</i></p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>We need to be careful that assumption are met.</i> There's a fairly tight coupling between an object and its type. For example, a breed might assume that a monster's <i>current</i> health is never above the starting health that comes from the breed.
            <br>If we allow the breed to change, we need to make sure that the new type's requirements are met by the existing object. When we change the type, we will probably need to execute some validation code to make sure the object is now in a state that makes sense for the new type.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>What kind of inheritance is supported?</h3>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>No inheritance:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>It's simple.</i> Simplest is often best. If you don't have a ton of data that needs sharing between your type objects, why make things hard on yourself?</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>It can lead to duplicate effort.</i> I've yet to see an authoring system where designers <i>didn't</i> want some kind of inheritance. When you've got fifty different kinds of elves, having to tune their health by changing the same number in fifty different places sucks.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>Single inheritance:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>It's still relatively simple.</i> It's easy to implement, but, more importantly, it's also pretty easy to understand. If non-technical users are going to be working with the system, the fewer moving parts, the better. There's a reason a lot of programming languages only support single inheritance. It seems to be a sweet spot between power and simplicity.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>Looking up attributes is slower.</i> To get a given piece of data from a type object, we might need to walk up the inheritance chain to find the type that ultimately decides the value. If we're in perforamce-critical code, we may not want to spend time on this.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>Multiple inheritance:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>Almost all data duplication can be avoided.</i> With a good multiple inheritance system, users can build a hierarchy for thier type objects that has almost no redundancy. When it comes time to tune numbers, we can avoid a lot of copy and paste.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>It's complex.</i> Unfortunately, the benefits for this seem to be more theoretical than practical. Multiple inheritance is hard to understand and reason about.
            <br>If our Zombie Dragon type inherits both from Zombie and Dragon, which attributes come from Zombie and which come from Dragon? In order to use the system, users will need to understand how the inheritance graph is traversed and have the foresight to design an intelligent hierarchy.
            <br>Most C++ coding standards I see today tend to ban multiple inheritance, and Java and C# lack it completely. That's an acknowledgement of a sad fact: it's so hard to get right that it's often best not to use it at all. While it's worth thinking about, it's rare that you'll want to use multiple inherticance for the type objects in your games. As always, simpler is better.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="see-also">
    <h2>See Also</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            &bull; The high-level problem this pattern addresses is sharing data and behavior between several objects. Another pattern that addresses the same problem in a different way is <a href="design-patterns-prototype.html">Prototype</a>.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            &bull; Type Object is a close cousin to <a href="design-patterns-flyweight.html">Flyweight</a>. Both let you share data across instances. With Flyweight, the intent is on saving memory, and the shared data may not represent any conceptual "type" of object. With the Type Object pattern, the focus is on organization and flexibility.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            There's a lot of similarity between this pattern and the <a href="design-patterns-state.html">State</a> pattern. Both patterns let an object delegate part of what defines itself to another object. With a type object, we're usually delegating what the object is: invariant data that broadly describes the object. With State, we delegate what an object <i>is right now</i>: temporal data that describes an object's current configuration.
            <br>When we discussed having an object change its type, you can look at that as having our Type Object serve double duty as a State too.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

                    <!-------------------------------------->
                </div>
            </div>
    </main>

    <!-------------------------------------------------------------------------->

    <!-- FOOTER -->
    <footer class="navbar navbar-inverse navbar-fixed-bottom">
        <nav>
            <div class="container">
                <div class="row">
                    <div class="col-md-6 col-sm-6 col-xs-12">
                        <ul>
                            <li>&copy; 2017 <a href="http://www.gabedeyo.com">Gabe Deyo</a></li>
                            <li>|</li>
                            <li><a href="mailto:gabedeyo@gmail.com?subject=Notes">gabedeyo@gmail.com</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>
    </footer>

    <!-- Latest Minified Slim JQuery -->
    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

    <script src="../js/selection.js" charset="utf-8"></script>
</body>

</html>

<!-- Section Template

<div class="jumbotron col-md-12 heliList" id="">
    <h2>XXX</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

-->
