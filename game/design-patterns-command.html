<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Design Patterns - Command</title>

    <meta name="viewport" content="width=device-width,initial-scale=1.0, shrink-to-fit=no" />

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/page.css">
</head>

<body>

    <!-- Top Navigation -->
    <header>
        <nav class="navbar navbar-inverse">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapsemenu" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a href="../index.html" class="navbar-brand">Personal Notes</a>
                </div>

                <div class="collapse navbar-collapse" id="collapsemenu">
                    <ul class="nav navbar-nav">

                        <!-- GAME DEVELOMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Game Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- CONCEPTS -->
                                <li><a href="concepts.html">Concepts <span class="glyphicon glyphicon-chevron-right"></span></a></li>

                                <!-- ENGINE -->
                                <li><a href="engine.html">Engine <span class="glyphicon glyphicon-chevron-right"></span></a></li>

                                <!-- IMPLEMENTATIONS -->
                                <li><a href="implementations.html">Implementations <span class="glyphicon glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- GABE DEVELOPMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Gabe Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- FITNESS PAGE -->
                                <li><a href="../gabe/fitness.html">Fitness <span class="glyphicon glyphicon-chevron-right"></span></a></li>

                                <!-- STYLE & GROOMING PAGE -->
                                <li><a href="../gabe/style.html">Style <span class="glyphicon glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                    </ul>
                </div>

            </div>
        </nav>
    </header>


    <!-------------------------------------------------------------------------->

    <!-- MAIN -->
    <main>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h1 class="text-center" style="text-decoration: underline;" id="title">Design Patterns - Command</h1>
                    <!------------------------------------------------->

                    <aside>
                        <button type="button" class="btn btn-default pull-right" name="button" id="selectAll">Select All</button>
                        <button type="button" class="btn btn-default pull-right" name="button" id="clearAll">Clear All</button>
                    </aside>

                    <div class="jumbotron col-md-12 heliList">
                        <h2>Index</h2>
                        <ul>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display: none;"></span>
                                <a href="#command">Command</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display: none;"></span>
                                <a href="#configInput">Configuring Input</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display: none;"></span>
                                <a href="#direct-actors">Directions for Actors</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display: none;"></span>
                                <a href="#undo-redo">Undo &amp; Redo</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display: none;"></span>
                                <a href="#classy-disfunction">Classy &amp; Disfunctional?</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display: none;"></span>
                                <a href="#links">Links</a>
                                </p>
                            </li>
                        </ul>
                    </div>

                    <div class="jumbotron col-md-12 heliList" id="command">
                        <h2>Command</h2>
                        <ul>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                Formal definition - Encapsulate a request as an object, thereby letting users parameterize clients
                                with different requests, queue or log requests, and support undoable operations.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                A more useable definition for our case is stated - <b>A command is a reified method call</b>
                                <br>Reify - Make (something abstract) more concrete or real.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                The main focus of this pattern is taking some concept and turning it into a piece of data -
                                an object - that you can stick in a variable, pass to a function, etc.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                A more accurate definition for Commands is - Commands are an object-oriented replacment
                                for callbacks. This concept is easily recognized through examples.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                A fairly easy way to identify the Command Pattern you see an interface with a single
                                method that doesn't return anything.
                            </p></li>
                        </ul>
                        <a href="#title"><span class="glyphicon glyphicon-menu-up pull-right"></span></a>
                    </div>

                    <div class="jumbotron col-md-12 heliList" id="configInput">
                        <h2>Configuring Input</h2>
                        <ul>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                Lets figure out a piece of code that reads in raw user input, and translates it into
                                meaningful actions. Our controller scheme:
                                <br>&nbsp; A -> Swap Weapon
                                <br>&nbsp; B -> Lurch
                                <br>&nbsp; Y -> Fire Gun
                                <br>&nbsp; X -> Jump
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                A most simple implementation can be seen here.
                                <br><code>void InputHandler::handleInput(){
                                    <br>&nbsp; if(isPressed(BUTTON_X)) jump();
                                    <br>&nbsp; else if(isPressed(BUTTON_Y)) fireGun();
                                    <br>&nbsp; else if(isPressed(BUTTON_A)) swapWeapon();
                                    <br>&nbsp; else if(isPressed(BUTTON_B)) lurchIneffectively();
                                <br>}</code>
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                Observe some of the issues that arise from this simple block.
                                <br>&nbsp; Gets called once per frame by the game loop.
                                <br>&nbsp; We need to manually assign inputs to actions.
                                <br>&nbsp; Limits the user to these specific inputs. Does not allow for custimization.
                                <br>So it looks like we may need the ability to swap out inputs. "Swapping out" sounds
                                a lot like assigning a variable, so we need an object that we can use to represent a
                                game action. Enter the <b>Command Pattern</b>
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                We need to define a <b>base class</b> that represents a triggerable game command:<br>
                                <code>class Command{
                                    <br>&nbsp; public virtual ~Command(){}
                                    <br>&nbsp; public virtual void execute() = 0;
                                <br>}</code>
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                We then need <b>subclasses</b> for each of the different actions we have:<br>
                                <code>class JumpCommand : public Command {
                                    <br>&nbsp; public virtual void execute() { jump(); }
                                <br>};
                            <br>class FireCommand : public Command {
                                <br>&nbsp; public virtual void execute() { fire(); }
                            <br>};</code>
                            <br>and so on...
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                In an <b>input handler</b>, we store a pointer to a command for each button: <br>
                                <code>class InputHandler{
                                    <br>&nbsp; public void handleInput();
                                    <br>&nbsp; // Methods to bind commands...
                                    <br>&nbsp; private Command* buttonX_;
                                    <br>&nbsp; private Command* buttonY_;
                                    <br>&nbsp; private Command* buttonA_;
                                    <br>&nbsp; private Command* buttonB_;
                                <br>}</code>
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                Now the <b>input handler</b> just delegates to those: <br>
                                <code>void InputHandler::handleInput(){
                                    <br>&nbsp; if(isPressed(BUTTON_X)) buttonX_->execute();
                                    <br>&nbsp; else if(isPressed(BUTTON_Y)) buttonY_->execute();
                                    <br>&nbsp; else if(isPressed(BUTTON_A)) buttonA_->execute();
                                    <br>&nbsp; else if(isPressed(BUTTON_B)) buttonB_->execute();
                                <br>}</code>
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                Now there is a layer of indirection. Notice we don't check for NULL here. This
                                assumes each button will have <i>some</i> command wired tto it. If we even wanted
                                a button that did nothing, we would need to simply do nothing in it's execute function.
                                <br>&nbsp; A -> Swap Command
                                <br>&nbsp; B -> Lurch Command
                                <br>&nbsp; Y -> Fire Command
                                <br>&nbsp; X -> Jump Command
                            </p></li>
                        </ul>
                        <a href="#title"><span class="glyphicon glyphicon-menu-up pull-right"></span></a>
                    </div>

                    <div class="jumbotron col-md-12 heliList" id="direct-actors">
                        <h2>Directions for Actors</h2>
                        <ul>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                After analyzing the previous input section, we can see some drawbacks.
                                <br>&nbsp; &bull; The command classes assume the functions jump, fire, etc.
                                implicitly know how to find the player's avatar and apply themselves.
                                <br>&nbsp; &bull; That assumed coupling limits the usefulness of those commands.
                                <br>&nbsp; &bull; The <i>only</i> thing the Jump Command can make jump is the player.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                We should loosen those restrictions. Instead calling functions that find the
                                commanded object themselves, we'll pass in the object that we want to order around.<br>
                                <code>class Command{
                                    <br>&nbsp; public virtual ~Command() {}
                                    <br>&nbsp; public virtual execute(GameActor&amp; actor) = 0;
                                <br>};</code>
                                <br>Here, <b>GameActor</b> is our "game object" class that represents a chararacter
                                in the game world.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                We pass it in to execute() so that the derived command can invoke
                                methods on an actor of our choice.<br>
                                <code>class JumpCommand : public Command {
                                    <br>&nbsp; public virtual void execute(GameActor&amp; actor){
                                        <br>&nbsp;&nbsp; actor.jump();
                                    <br>&nbsp; }
                                <br>};</code>
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                Now we can use this one class to make any character jump. We're just missing the
                                piece between the input handler and the command that takes the command and invokes it
                                on the correct object. First, we change handleInput() to return commands: <br>
                                <code>Command* InputHandler::handleInput(){
                                    <br>&nbsp; if(isPressed(BUTTON_X)) return buttonX_;
                                    <br>&nbsp; if(isPressed(BUTTON_Y)) return buttonY_;
                                    <br>&nbsp; if(isPressed(BUTTON_A)) return buttonA_;
                                    <br>&nbsp; if(isPressed(BUTTON_B)) return buttonB_;
                                    <br>&nbsp; //nothing pressed, so do nothing.
                                    <br>&nbsp; return null;
                                <br>}</code>
                                <br>It can't execute the command immediatly since it doesn't know what actor
                                to pass in. Here's where we take advantage of the fact that the command is a
                                reified call - we can delay when the call is executed.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                So we need some code that takes that command and runs it on the actor representing
                                the player: <br>
                                <code>Command* command = inputHandler.handlInput(){
                                    <br>&nbsp; if(command){
                                        <br>&nbsp;&nbsp; command->execute(actor);
                                    <br>&nbsp; }
                                <br>}</code>
                                <br>Assuming <i>actor</i> is a reference to the player's character, this correctly
                                drives him based on the user's input. So we're back to square one, but with an added
                                layer of indirection between the command and the actor that performs it. As a result,
                                we have a cool ability: <b>we can let the player control any actor in the game now
                                by changing the actor we execute the command on.</b>
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                This is not a very common feature, but there is a similar use case that does pop up.
                                We know we can command the player-driven character, but what about other actors in
                                the world? Those are driven by the game's AI, so we can use this same command as the
                                interface between the AI engine and the actors; the code simply emits <i>Command</i>
                                objects.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                Decoupling of AI that selects commands and actor code that performs them gives us
                                flexibility.
                                <br>&nbsp; &bull; Use different AI modules for different actors.
                                <br>&nbsp; &bull; Mix and match AI for different behaviors.
                                <br>&nbsp; &bull; Want an aggressive character? Just plug-in an aggresive AI to generate commands for it.
                                <br>&nbsp; &bull; Need a demo where character runs in auto-pilot? Bolt the AI to the player's character!
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                By making commands that control an actor first-class objects, we've removed the
                                tight coupling of a direct mothod call. Instead, think of it as a <i>queue or stream
                                 of commands:</i>
                                 <br><b>AI -> Command Stream -> Actor</b>
                                 <br>Some input handler or AI produces commands and places them in the stream. Other code (dispatcher or actor itself)
                                 consumes commands and invokes them. By sticking that queue in the middle, we've decoupled the producer on
                                 one end from the consumer on the other.
                            </p></li>
                        </ul>
                        <a href="#title"><span class="glyphicon glyphicon-menu-up pull-right"></span></a>
                    </div>

                    <div class="jumbotron col-md-12 heliList" id="undo-redo">
                        <h2>Undo &amp; Redo</h2>
                        <ul>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                The most common use of this pattern is Undo. If a command can do something, it's a
                                small step to undo it. One place we'd see this in action is with a strategy game.
                                The player fat-fingers to move a unit and needs to undo it.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                Here's what moving a unit command could look like:
                                <code>class MoveUnitCommand : public Command{
                                    <br>&nbsp; public MoveUnitCommand(Unity* unity, int x, int y) : unit_(unit), x_(x), y_(y) {}
                                    <br>&nbsp; public virtual void execute(){
                                        <br>&nbsp; &nbsp; unit_ -> moveTo(x_, y_);
                                    <br>&nbsp; }
                                    <br>&nbsp; private Unit* unit_;
                                    <br>&nbsp; private int x_, y_;
                                <br>}</code>
                                <br>Note* this command is NOT being abstracted from the actor, instead it is bound
                                to the unit being moved.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                Difference in previous Input Commands and Move Unit Command:
                                <br>&nbsp; &bull; Input Commands were reusable objects that represented things that
                                could be done.
                                <br>&nbsp; &bull; Input Commands held onto a single command object and called execute()
                                anytime the right button was pressed.
                                <br>&nbsp; &bull; Move Unit Command represents a thing that can be done at a specific point in time.
                                <br>&nbsp; &bull; That means that the input handling code will be <i>creating</i> an instance
                                of this everytime the player chooses a move. Let handle that.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                <code>Command* handleInput(){
                                    <br>&nbsp; Unit* unit = getSelectedUnit();
                                    <br>&nbsp; if(isPressed(BUTTON_UP)){
                                        <br>&nbsp; &nbsp; // Move unit up one
                                        <br>&nbsp; &nbsp; int destY = unit -> y() - 1;
                                        <br>&nbsp; &nbsp; return new MoveUnitCommand(unit, unit->x(), destY);
                                    <br>&nbsp; }
                                    <br>&nbsp; if(isPressed(BUTTON_DOWN)){
                                        <br>&nbsp; &nbsp; // Move unit down one
                                        <br>&nbsp; &nbsp; int destY = unit -> y() + 1;
                                        <br>&nbsp; &nbsp; return new MoveUnitCommand(unit, unit->x(), destY);
                                    <br>&nbsp; }
                                    <br>&nbsp; // Other moves...
                                    <br>&nbsp; return null;
                                <br>}</code>
                                <br>The fact that commands are one-use-only will be an advantage soon.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                To make commands undoable, we need to add onto our Command class: <br>
                                <code>class Command {
                                    <br>&nbsp; public virtual ~Command() {}
                                    <br>&nbsp; void virtual execute() = 0;
                                    <br>&nbsp; void virtual undo() = 0;
                                <br>}</code>
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                An undo() method reverses the game state changed by the corresponding execute()
                                method. Here's our previous command with undo support: <br>
                                <code>class MoveUnitCommand : public Command {
                                    <br>&nbsp; public MoveUnitCommand(Unit* unit, int x, int y) : unit_(unit), xBefore(0), yBefore(0), x_(x), y_(y) {}
                                    <br>&nbsp; public virtual void execute(){
                                        <br>&nbsp; &nbsp; // Remember the unit's position before the move so we can resotre it.
                                        <br>&nbsp; &nbsp; xBefore_ = unit_ -> x();
                                        <br>&nbsp; &nbsp; yBefore_ = unit_ -> y();
                                        <br>&nbsp; &nbsp; unit_ -> moveTo(x_, y_);
                                    <br>&nbsp; }
                                    <br>&nbsp; public virtual void undo() {
                                        <br>&nbsp; &nbsp; unit_ -> moveTo(xBefore_, yBefore_);
                                    <br>&nbsp; }
                                    <br>&nbsp; private Unit* unit_;
                                    <br>&nbsp; private int xBefore_, yBefore_;
                                    <br>&nbsp; private int x_, y_;
                                <br>};</code>
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                So we added more state to the class. We are remembering the unit's previous position
                                with xBefore and yBefore. We could also support multi leveled undo/redo actions.
                                Instead of remembering the last command, we could keep a list of commands and
                                references to the "current" one. When the player executes a command, we append it
                                to the list and point "current" at it. When the player chooses "Undo", we undo the
                                current command and move the current pointer back. Then just advance the pointer
                                if the player selects "Redo". If the player chooses a new command after undoing
                                a command, everything in the list after current command is discarded.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                Redo may not be too common in games, but <i>re-play</i> is. A horrible way to re-play
                                something would be to record every frame. A much better way would be to record the
                                set of commands every entity performed each frame. To replay the game, the engine just
                                runs through the normal game simulation, executing the pre-recorded commands.
                            </p></li>
                        </ul>
                        <a href="#title"><span class="glyphicon glyphicon-menu-up pull-right"></span></a>
                    </div>

                    <div class="jumbotron col-md-12 heliList" id="classy-disfunction">
                        <h2>Classy &amp; Disfunctional?</h2>
                        <ul>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                Commands can be similar to first-class functions or closures, however each example
                                above is in C++ because the language has limited support for first-class functions.
                                This is not to say Commands can't be done in other languages. If you are able to
                                use real closures, do it.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                Check out this Command in JavaScript: <br>
                                <code>function makeMoveUnitCommand(unit, x, y){
                                    <br>&nbsp; //This function here is the command object:
                                    <br>&nbsp; return function(){ unit.moveTo(x, y); }
                                <br>}</code>
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                We can even add undo support using a pair of closures: <br>
                                <code>function makeMoveUnitCommand(unit, x, y){
                                    <br>&nbsp; var xBefore, yBefore;
                                    <br>&nbsp; return {
                                        <br>&nbsp; &nbsp; execute: function(){ xBefore = unit.x(); yBefore = unit.y(); unit.moveTo(x, y); }
                                        <br>&nbsp; &nbsp; undo: function(){ unit.moveTo(xBefore, yBefore); }
                                    <br>&nbsp; };
                                <br>}</code>
                            </p></li>
                        </ul>
                        <a href="#title"><span class="glyphicon glyphicon-menu-up pull-right"></span></a>
                    </div>

                    <div class="jumbotron col-md-12 heliList" id="links">
                        <h2>Links</h2>
                        <ul>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                <a href="#">Subclass Sandbox</a>
                                <br>You may end up with a lot of different command classes. In order to make it easier
                                to implement those, it's often helpful to define a concrete base class with a bunch
                                of convenient high-level mothods that the derived commands can compose to define their
                                behavior. That turns the command's main execute() method into the Subclass Sandbox pattern.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                <a href="#">Chain of Responsibility</a>
                                <br>In our examples, we explicitly chose which actor would handle a command. In some cases,
                                especially where your object model is hierarchical, it may no be so cut-and-dried. An
                                object may respond to a command, or it may decide to pawn it off on some subordinate object.
                                If you do that, you've got yourself the Chain of Responsibility pattern.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                <a href="#">Flyweight</a>
                                <br>Some commands are stateless chunks of pure behavior like the JumpCommand in the first
                                example. In cases like that, having more than one instance of that class wastes memory since
                                all instances are equivalent. The Flyweight pattern addresses that.
                            </p></li>
                        </ul>
                        <a href="#title"><span class="glyphicon glyphicon-menu-up pull-right"></span></a>
                    </div>

                    <!-------------------------------------->
                </div>
            </div>
    </main>

    <!-------------------------------------------------------------------------->


    <!-- FOOTER -->
    <footer class="navbar navbar-inverse navbar-fixed-bottom">
        <nav>
            <div class="container">
                <div class="row">
                    <div class="col-md-6 col-sm-6 col-xs-12">
                        <ul>
                            <li>&copy; 2017 <a href="http://www.gabedeyo.com">Gabe Deyo</a></li>
                            <li>|</li>
                            <li><a href="mailto:gabedeyo@gmail.com?subject=Notes">gabedeyo@gmail.com</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>
    </footer>

    <!-- Latest Minified Slim JQuery -->
    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

    <script src="../js/selection.js" charset="utf-8"></script>
</body>

</html>

<!-- Section Template

<div class="jumbotron col-md-12 heliList" id="">
    <h2>XXX</h2>
    <ul>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            XXX
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon glyphicon-menu-up pull-right"></span></a>
</div>

    Code Template

<div class="jumbotron col-md-12 heliList" id="">
    <h2>Code</h2>
    <ul>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            <code>public bool coding = true;
            <br>private Rigidbody2D rb;</code>
        </p></li>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            <code>void Start(){
                <br>&nbsp; console.log('Start Function');
            <br>}</code>
        </p></li>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            <code>void Update(){
                <br>&nbsp; console.log('Don't log here, ya dingus');
            <br>}</code>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon glyphicon-menu-up pull-right"></span></a>
</div>

-->
