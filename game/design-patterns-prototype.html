<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Design Patterns - Prototype</title>

    <meta name="viewport" content="width=device-width,initial-scale=1.0, shrink-to-fit=no" />

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/page.css">
</head>

<body>

    <!-- Top Navigation -->
    <header>
        <nav class="navbar navbar-inverse">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapsemenu" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a href="../index.html" class="navbar-brand">Personal Notes</a>
                </div>

                <div class="collapse navbar-collapse" id="collapsemenu">
                    <ul class="nav navbar-nav">

                        <!-- GAME DEVELOMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Game Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- CONCEPTS -->
                                <li><a href="concepts.html">Concepts <span class="glyphicon glyphicon-chevron-right"></span></a></li>

                                <!-- ENGINE -->
                                <li><a href="engine.html">Engine <span class="glyphicon glyphicon-chevron-right"></span></a></li>

                                <!-- IMPLEMENTATIONS -->
                                <li><a href="implementations.html">Implementations <span class="glyphicon glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- GABE DEVELOPMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Gabe Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- FITNESS PAGE -->
                                <li><a href="../gabe/fitness.html">Fitness <span class="glyphicon glyphicon-chevron-right"></span></a></li>

                                <!-- STYLE & GROOMING PAGE -->
                                <li><a href="../gabe/style.html">Style <span class="glyphicon glyphicon-chevron-right"></span></a></li>

                                <!-- FINANCE PAGE -->
                                <li><a href="../gabe/finance.html">Finance <span class="glyphicon glyphicon-chevron-right"></span></a></li>

                                <!-- PHILOSOPHY PAGE -->
                                <li><a href="../gabe/philosophy.html">Philosophy <span class="glyphicon glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                    </ul>
                </div>

            </div>
        </nav>
    </header>


    <!-------------------------------------------------------------------------->

    <!-- MAIN -->
    <main>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h1 class="text-center" style="text-decoration: underline;" id="title">Design Patterns - Prototype</h1>
                    <!------------------------------------------------->

                    <aside>
                        <button type="button" class="btn btn-default pull-right" name="button" id="selectAll">Select All</button>
                        <button type="button" class="btn btn-default pull-right" name="button" id="clearAll">Clear All</button>
                    </aside>

                    <div class="jumbotron col-md-12 heliList">
                        <h2>Index</h2>
                        <ul>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display: none;"></span>
                                <a href="#prototype">Prototype</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display: none;"></span>
                                <a href="#prototype-implementation">Prototype Implementation</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display: none;"></span>
                                <a href="#prototype-paradigm">The Prototype Language Paradigm</a>
                                </p>
                            </li>
                        </ul>
                    </div>

<div class="jumbotron col-md-12 heliList" id="prototype">
    <h2>Prototype</h2>
    <ul>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            Imageine our game has enemies swarming the hero, entering by way of "spawners", with a
            different spawner for each type of enemy.
            <br>For this example, lets say we have classes for each type of enemy in the game: <br>
            <code>class Monster {
                <br>&nbsp; //Monster stuff
            <br>}
            <br>class Ghost : public Monster {};
            <br>class Demon : public Monster {};
            <br>class Sorcerer : public Monster {};</code>
        </p></li>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            A spawner constructs instances of one particular monster type. To support every monster
            in the game, we could brute-force it by having a spawner class for each moster class,
            leading to a parallel class hierarchy:
            <br>Ghost/Demon/Sorcerer ->(inherit from) Monster ... GhostSpawner/DemonSpawner/SorcererSpawner -> Spawner
            <br>Implementing would look like this: <br>
            <code>class Spawner {
                <br>&nbsp; public virtual ~Spawner() {}
                <br>&nbsp; public virtual Monster* spawnMonster() = 0;
            <br>};
            <br>class GhostSpawner : public Spawner {
                <br>&nbsp; public virtual Monster* spawnMonster() { return new Ghost(); }
            <br>};
            <br>class DemonSpawner : public Spawner() {
                <br>&nbsp; public virtual Monster* spawnMonster() { return new Demon(); }
            <br>}
            <br>//And so on.</code>
        </p></li>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            This will clearly result in many classes, lots of boilerplate, redundancy, lots of duplication...
            <br>The <b>Prototype</b> pattern offers a solution. They key idea is that an object can spawn
            other objects similar to itself. If you have one ghost, you can make more ghosts from it.
            If you have a demon, you can make other demons. Any monster here can be treated as a
            prototypal monster used to generate other versions of itself.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon glyphicon-menu-up pull-right"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="prototype-implementation">
    <h2>Prototype Implementation</h2>
    <ul>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            To implement this pattern, we're going to give our base class, Monster, an abstract
            clone() method: <br>
            <code>class Monster {
                <br>&nbsp; public virtual ~Monster() {}
                <br>&nbsp; public virtual Monster* clone() = 0;
                <br>&nbsp; //Other Stuff
            <br>}</code>
        </p></li>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            Each monster subclass provides an implementation that returns a new object identical
            in class and state to it. For example: <br>
            <code>class Ghost : public Monster {
                <br>&nbsp; public Ghost(int health, int speed) : health_(health), speed_(speed) {}
                <br>&nbsp; public virtual Monster* clone() {
                    <br>&nbsp; &nbsp; return new Ghost(health_, speed_);
                <br>&nbsp; }
                <br>&nbsp; private int health_;
                <br>&nbsp; private int speed_;
            <br>}</code>
        </p></li>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            Once all our monsters support that, we no longer need a spawner class for each
            monster class. Instead we define a single one: <br>
            <code>class Spawner {
                <br>&nbps; public Spawner(Monster* prototype) : prototype_(prototype) {}
                <br>&nbps; public Monster* spawnMonster() { return prototype_clone(); }
                <br>&nbps; private Monster* prototype_;
            <br>};</code>
        </p></li>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            This internally holds a monster, a hidden one whose sole purpose is to be used
            by the spawner as a template to stamp out more monsters like it, sort of like
            a queen bee who never leaves the hive. <br>
            [Spawner(Monster)<-"Prototype"] -> clone() -> Monster.. Monster.. Monster..
        </p></li>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            To create a ghost spawner, we create a prototypal ghost instance and then
            create a spawner holding that prototype: <br>
            <code>Monster* ghostPrototype = new Ghost(15, 3);
            <br>Spawner* ghostSpawner = new Spawner(ghostPrototype);</code>
            <br>One great part about this pattern is that it doesn't just clone the class
            of the prototype, it clones its state too. This means we could make a spawner for
            fast ghost, weak ghosts, or slow ghosts just by creating an appropriate prototype ghost.
        </p></li>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            <b>How Well Does It Work?</b><br>
            So we don't have to create a separate spawner class for each monster. However,
            we do have to implement clone() in each monster class. That's about as much code
            as the spawners.
            <br>There are also some nasty semantic rathoes when you write a correct clone().
            Does it do a deep clone or shallow?
            <br>Also, not only does this not look like it's saving us much code in this
            contrived problem, there's the fact that it's a contrived problem. We had to take
            as a given that we have separate classes for each monster. These days, that's definitely
            not the way most game engines roll.
            <br>Most of us learned the hard way that big hierarchies like this are a pain to manage,
            which is why we instead use patterns like <b>Componenet</b> and <b>Type Object</b>
            to model different kinds of entities without enshrining each in its own class.
        </p></li>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            <b>Spawn Functions</b><br>
            Even if we do have different classes for each monster, there are other ways to strip it down.
            Instead of making separate spawner classes for each monster, we could make spawn functions, like so: <br>
            <code>Monster* spawnGhost () {
                <br>&nbsp; return new Ghost();
            <br>}</code>
        </p></li>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            This is less boilerplate than rolling a whole class for constructing a monster
            of some type. Then the one spawner class can simply store a function pointer: <br>
            <code>typedef Monster* (*SpawnCallback)();
            <br>class Spawner {
                <br>&nbps; public Spawner(SpawnCallback spawn) : spawn_(spawn) {}
                <br>&nbps; public Monster* spawnMonster() { return spawn_() }
                <br>&nbps; private SpawnCallback spawn_;
            <br>};</code>
        </p></li>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            Finally, to create a spawner for ghosts, you do: <br>
            <code>Spawner* ghostSpawner = new Spawner(spawnGhost);</code>
        </p></li>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            <b>Templates</b><br>
            Our spawner class needs to construct instances of some type, but we don't want to hard
            code some specific monster class. The natural solution then is to make it a <i>type
            parameter</i>, which <b>templates</b> let us do: <br>
            <code>class Spawner {
                <br>&nbsp; public virtual ~Spawner(){}
                <br>&nbsp; public virtual Monster* spawnMonster() = 0;
            <br>}
            <br>template &lt;class T&gt;
            <br>class SpawnerFor : public Spawner {
                <br>&nbsp; public virtual Monster* spawnMonster() { return new T(); }
            <br>}</code>
            <br>Using it looks like: <br>
            <code>Spawner* ghostSpawner = new SpawnerFor&lt;Ghost&gt;();</code>
        </p></li>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            Templates are a popular tool in languages nowadays. The Spawner class here is so that
            code that doesn't care what kind of monster a spawner creates can just use it and
            work with pointers to Monster.
            <br>If we only had the SpawnerFor&lt;T&gt; class, there would be no single supertype
            the instantiations of that template all shared, so any code that worked with spawners of
            any monster type would itself need to take a template parameter.
        </p></li>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            <b>First-Class Types</b><br>
            The previous two solutions address the need to have a class, Spawner, which is
            parameterized by a type. In C++, types aren't generally first-class, so that requires
            some gymnastics. If you're using a dynamically-typed language like JS, Python, or Ruby
            where classes are regular object you can pass around, you can solve this more directly.
            <br>In some ways, the <b>Type Object</b> pattern is another workaround for the lack of
            first-class types. That pattern can still be useful even in languages with them, though
            because it lets you define what a "type" is. You may want different semantics
            than what the language's built-in classes provide.
            <br>When you make a spawner, just pass in the class of monster that it should construct.
            The actual runtime object that represents the monster's class.
            <br>With all of these options, we still can't say we've found a case where the Prototype
            pattern was the best answer. Until we go deeper and explore the prototype as a
            language paradigm.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon glyphicon-menu-up pull-right"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="prototype-paradigm">
    <h2>The Prototype Language Paradigm</h2>
    <ul>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            Many people take "OOP" as synonymous with "classes". Definitions of OOP tend to feel
            like credos of opposing religious denominations, but a fairly non-contentious take
            on it is that OOP <i>let you define</i> "objects" which bundle data and code together.
            Compared to structured languages like C and functional languages like Scheme, the
            defining characteristic of OOP is that it tightly binds state and behavior together.
            <br>You may think classes are the one and only way to do that, but a handful of
            programmers beg to differe. Some of those guys create a language called <i>Self</i>
            and while as OOP as can be, it has no classes.
        </p></li>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            XXX
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon glyphicon-menu-up pull-right"></span></a>
</div>

                    <!-------------------------------------->
                </div>
            </div>
    </main>

    <!-------------------------------------------------------------------------->


    <!-- FOOTER -->
    <footer class="navbar navbar-inverse navbar-fixed-bottom">
        <nav>
            <div class="container">
                <div class="row">
                    <div class="col-md-6 col-sm-6 col-xs-12">
                        <ul>
                            <li>&copy; 2017 <a href="http://www.gabedeyo.com">Gabe Deyo</a></li>
                            <li>|</li>
                            <li><a href="mailto:gabedeyo@gmail.com?subject=Notes">gabedeyo@gmail.com</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>
    </footer>

    <!-- Latest Minified Slim JQuery -->
    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

    <script src="../js/selection.js" charset="utf-8"></script>
</body>

</html>

<!-- Section Template

<div class="jumbotron col-md-12 heliList" id="">
    <h2>XXX</h2>
    <ul>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            XXX
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon glyphicon-menu-up pull-right"></span></a>
</div>

-->
