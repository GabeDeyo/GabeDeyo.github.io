<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Advanced Scripting</title>

    <meta name="viewport" content="width=device-width,initial-scale=1.0, shrink-to-fit=no" />

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/page.css">
</head>

<body>

    <!-- Top Navigation -->
    <header>
        <nav class="navbar navbar-inverse">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapsemenu" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a href="../index.html" class="navbar-brand">Personal Notes</a>
                </div>

                <div class="collapse navbar-collapse" id="collapsemenu">
                    <ul class="nav navbar-nav">

                        <!-- GAME DEVELOMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Game Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- CONCEPTS -->
                                <li><a href="concepts.html">Concepts <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ENGINE -->
                                <li><a href="engine.html">Engine <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- IMPLEMENTATIONS -->
                                <li><a href="implementations.html">Implementations <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- PROGRAMMING -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Programming <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- ALGORITHMS -->
                                <li><a href="../code/algorithms.html">Algorithms <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PROBLEMS -->
                                <li><a href="../code/problems.html">Problems <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- RANDOM -->
                                <li><a href="../code/random.html">Random <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- GABE DEVELOPMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Gabe Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- FITNESS PAGE -->
                                <li><a href="../gabe/fitness.html">Fitness <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- STYLE & GROOMING PAGE -->
                                <li><a href="../gabe/style.html">Style <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- FINANCE PAGE -->
                                <li><a href="../gabe/finance.html">Finance <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PHILOSOPHY PAGE -->
                                <li><a href="../gabe/philosophy.html">Philosophy <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                    </ul>
                </div>

            </div>
        </nav>
    </header>

    <!-------------------------------------------------------------------------->

    <!-- MAIN -->
    <main>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h1 id="title">Advanced Scripting</h1>

                    <aside>
                        <button type="button" class="btn btn-default" name="button" id="selectAll">Select All</button>
                        <button type="button" class="btn btn-default" name="button" id="clearAll">Clear All</button>
                    </aside>

                    <div class="jumbotron heliList">
                        <h2>Index</h2>
                        <ul>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#1">Coroutines</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#2">Event &amp; Messaging Systems</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#3">Saving and Loading Games</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#4">Ray Casting</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#5">Mini Maps</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#6">Dynamic Meshes</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#7">Quad Tree</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#8">Extension Methods</a>
                                </p>
                            </li>
                        </ul>
                    </div>

<div class="jumbotron col-md-12 heliList" id="1">
    <h2>Coroutines</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we're going to learn about coroutines. Coroutines are a coding structure, that allows us to delay the execution of code. We can essentially pause the execution at a specific section of code, and then pick up where we left off at a later time. This can be used not only as an optimization technique, but also is an easy way to make an event happen at regular intervals. Let's take a look.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's take a look at the beginning of our Coroutines class. So far, we'll see what functions are covered later:
            <pre>
            <span class="glyphicon-remove"></span>public class Coroutines : MonoBehaviour {

                public float secondsToWait = 5f;
                public bool move = false;

                public bool complete = true;

                public bool useYieldForHeavy = false;

                public void OnMouseDown() {
                    move = true;

                    NaiveMovement();

                    StartCoroutine(NaiveMovementFixed());

                    StartTogglePulse();

                    StartHeavyTask();
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            A common mistake when starting game programming, is to implement a for loop for movement. Of course, we know the entire for loop, will execute within one frame. Meaning all of these translates, are added together and no visible movement occurs. Even worse, this method moves back to the starting position at the end. Meaning all of this movement is for nothing. This function will be called NaiveMovement().
            <pre>
            <span class="glyphicon-remove"></span>public void NaiveMovement() {
                //A common mistake when starting programming with games.
                //When attempting to move an object little by little, a for loop is used
                // this approach moves the object little by little, however all the movement
                // happens in one frame, so visually the movement is instantaneous
                for(int i = 0; i < 100; i++) {
                    this.transform.Translate(0.1f, 0f, 0f);
                }
                move = false;

                //reset position at the end
                this.transform.position = new Vector3.zero;
                Debug.Log("Completed moving");
            }
            </pre>
            <p><span class="glyphicon-remove"></span>So we see that on MouseDown we're activating our NaiveMovement function. We've completed moving, even through there was no visible movement. We can modify this with a coroutine, using the start coroutine method, and passing in our movement fixed method.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's take a look at that NaiveMovementFixed coroutine:
            <pre>
            <span class="glyphicon-remove"></span>//Looks like a regular function - has actually been converted into an object by the compiler
            //An object that is essentially a state machine delimited by the yield statements
            public IEnumerator NaiveMovementFixed() {
                //Slightly modified with coroutine functionality, this works closer to expected.
                for(int i = 0; i < 100; i++) {
                    this.transform.Translate(0.1f, 0f, 0f);
                    yield return 0; //yield execution for one frame
                }
                move = false;

                //reset position at the end
                this.transform.position = new Vector3.zero;
                Debug.Log("Completed moving");
            }
            </pre>
            <p><span class="glyphicon-remove"></span>So we notice that instead of returning void, we're going to return an IEnumerator, and we're going to call it, with yield return zero. This will yield execution of the code for one frame. We now see that executing one iteration per frame.</p>
            <p><span class="glyphicon-remove"></span>So what's actually happening behind the scenes? The compiler takes this method of IEnumerator, and converts it into an object. The object is broken apart into a state machine, based on the yield return statement.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            So how else can we use coroutines? We could use them to make an event happen at regular intervals. For example, if we want to toggle a pulse. Let's first look at the code:
            <pre>
            <span class="glyphicon-remove"></span>public void StartTogglePulse() {
                StartCoroutine(TogglePulse());
            }

            public IEnumerator TogglePulse() {
                bool big = false;
                while(true) { //normally a very bad thing. Typically starts an infinite loop
                    //Alternate between small and large, use the `big` boolean as a toggle to decide
                    if(big) {
                        this.transform.localScale = new Vector3(2f, 2f, 2f);
                    } else {
                        this.transform.localScale = new Vector3(0.5, 0.5f, 0.5f);
                    }
                    big = !big;

                    //WaitForSeconds is a YieldInstruction. These are like special states to add to the
                    // state machine. In this case, it's a state that won't return for another 1 second.
                    yield return new WaitForSeconds(1f); //yield execution for 1 seconds.
                }
            }
            </pre>
            Essentially we're going to say, if it's big, make it small, if it's small, make it big. And in this case we're going to do a while true loop, which is typically a bad thing. If we didn't have this yield in here this would be an infinite loop and we'd be locked out. Here we're going to yield return and we're going to wait for one second. This is causing the state machine to wait one second before jumping to the next state. And let's take a look at this. Clicking, we see that we have one second between getting big and small.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Finally, we can use coroutines to optimize code. For example, when running heavy tasks and doing other things on screen, like moving, we can see that, starting a heavy task and moving at the same time means we have to wait for the heavy task to finish before continuing to our movement code. This is because the entire heavy task has to complete before we can start on our move code. Let's see how we can fix this. Onto some code:
            <pre>
            <span class="glyphicon-remove"></span>//Start a heavy task
            //Select the method based off the `useYieldForHeavy` Boolean
            public void StartHeavyTask() {
                if(useYieldForHeavy)
                    StartCoroutine(HeavyTask_WithYield());
                else
                    HeavyTask();
            }

            //Perform that task as is, without coroutines
            public void HeavyTask() {
                int processed = 0;
                int maxProcessed = 100;
                while(processed < maxProcessed) {
                    Process();
                    processed++;
                }
                Debug.Log("Completed Heavy Task");
            }

            //Use Coroutines to yield between processing
            public IEnumerator Heavytask_WithYield() {
                int processed = 0;
                int maxProcessed = 100;
                while(processed < maxProcessed) {
                    Process();
                    processed++;
                    yield return 0;
                }
                Debug.Log("Completed heavy task with yield");
            }

            //A complex task, like processing a detailed path or calculating AI response
            //In this case, a fake heavy processing task to take up CPU
            private void Process() {
                double t = double.MinValue;
                for(int i = 0; i < int.MaxValue/1000f; i++) {
                    t = Mathf.Sqrt(i);
                }
            }
            </pre>
            <p><span class="glyphicon-remove"></span>It's going to take a number of items to be processed and process them, until it's completed. If we have a heavy task with yield, it's going to take a number of items to be processed, and process one per frame until it's completed. Let's see what the difference makes. If we turn on, UseYieldForHeavy, and then click our object, we'll see that it's going to move at the same time that it's processing the heavy task. And actually going to finish right around the same time.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The coroutine is a powerful coding structure that allows further control and execution of our code. Common uses include distributing the processing of a heavy method over multiple frames. Offering an alternative for control of structures in our code, or making something happen regularly in game.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="2">
    <h2>Event &amp; Messaging Systems</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we're going to go over a common control structure in game event systems. Event systems are used to communicate between objects, systems, and game managers. These systems typically have events and listeners. The listeners will subscribe to the events, also called messages, of a certain type. When an event is broadcast of a certain type, its sent to each of the listeners for that type. What each listener does with that event depends on that event. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Event message could be something "This building has been damaged". Then we can have a GUI listener that will display a message on screen about the building being damaged or where it is, a worker listener that will try to repair the building, and finally, perhaps the score listener that deducts points for letting your building get damaged. The primary benefit of these systems is flexibility. It's simple to have an object start listening for events and have it respond appropriately without needing to touch the code that is generating the event.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's check out our first <b>Event Broadcaster</b>:
            <pre>
            <span class="glyphicon-remove"></span>public class EventBroadcaster : MonoBehaviour {
                //A delegate is a type that allows you to create a method like a parameter
                // essentially it allows you to then create an instance of the delegate you can
                //pass around and call as if it were a regular method.
                //For this situation we're going to use it to attach other methods to
                //it will be the method that's called and thus calls the methods of our listeners
                public delegate void EventAction();

                //Static means that this EventAction is going to be accessable without needing to
                // instantiate an instance of this object.
                //The event keyword is also key here. It allows us to notify the listener classes
                // when the event action method is called.
                public static event EventAction OnEventAction;

                void OnMouseDown() {
                    //When this object is clicked, it will activate its event,
                    // this will then notify all listeners that the event has happened.
                    OnEventAction();
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Here we have an EventBroadcaster that's going to create a delegate. Each of the event listeners is going to create a method that matches the signature of this delegate where it returns void and takes no parameters. Then we're going to create an instance of that EventAction, with the event keyword name OnEventAction. This is essentially a hub where all event listeners can attach to so that their event action delegatees can be actived when this one is. In this case, in the OnMousedown method, we're going to activate this method. And thus, send an event to all the listeners.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's take a look at our <b>Event GUI Listener</b>:
            <pre>
            <span class="glyphicon-remove"></span>public class EventGUIListener : MonoBehaviour {
                public string messageToDisplay = "Event Recieved!";
                public float secondsToShowMessage = 3f;

                private bool showMessage = false;

                //When this component is first enabled, we want to subscribe to events
                // from the eventBroadcaster
                void OnEnable() {
                    //We're adding our notification method `RespondToEvent` to the OnEventAction
                    // now, whenever OnEventAction is called, our method RespondToEvent will also be called
                    EventBroadcaster.OnEventAction += EventRecieved;
                }

                //When this component is disabled, we want to "unsubscribe" from events.
                void OnDisable() {
                    //Now we're removing our notification method, no longer taking any action when OnEventAction is called
                    EventBroadcaster.OnEventAction -= EventRecieved;
                }

                void OnGUI() {
                    if(showMessage)
                        GUI.Label(new Rect(100, 100, 300, 20), messageToDisplay);
                }

                //This method matches the signature of 
                // public delegate void EventAction();
                //Returns void and takes no arguments
                //This means we can add it to the OnEventAction event
                void EventRecieved() {
                    ShowTimedMessage();
                }

                void ShowTimedMessage() {
                    StartCoroutine(TimedMessage());
                }

                IEnumerator TimedMessage() {
                    showMessage = true;
                    yield return new WaitForSeconds(secondsToShowMessage);
                    showMessage = false;
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Here we have our GUI listener. When the object this script is attached to is enabled it's going to attach itself to the OnEventAction of the Event Broadcaster. It's going to attach its event received method, and we can see that it matches the delegate signature where it returns void and takes no arguments. So when this method is activated here, we're going to show a timed message, which is simply a coroutine that toggles a boolean from true, waits a couple of seconds, and toggles it off.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's see another listener called <b>Event Move Listener</b>:
            <pre>
            <span class="glyphicon-remove"></span>public class EventMoveListener : MonoBehavior {
                public Vector3 eventMoveDirection = new Vector3(0, 1, 0);

                //When this component is first enabled, we want to subscribe to events
                //from the eventbroadcaster
                void OnEnable() {
                    //We're adding our notification method `RespondToEvent` to the OnEventAction
                    // now, whenever OnEventAction is called, our method RespondToEvent will also be called
                    EventBroadcaster.OnEventAction += RespondToEvent;
                }

                //When this component is disabled, we want to "unsubscribe" from events.
                void OnDisable() {
                    //Now we're removing our notification method, no longer taking any action when OnEventAction is called
                    EventBroadcaster.OnEventAction -= RespondToEvent;
                }

                //Our RespondToEvent method is used to respond to events
                //In this case, we'll just move ourselves to show that we've responded
                void RespondToEvent() {
                    this.transform.Translate(eventMoveDirection);
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Once again, when the object script is attached too, is activated, it's going to attach itself to the on event action with its respond to event method. In this case the respond to event method is fairly simple. It's just going to translate the object it's attached to in the event move direction which is defined here.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's move on to a more advanced example. In this example, we're going to see an event relay. This is an event relay class, so that we can send events from any script without having to attach an additional sender script. This will relay events between a sender of listeners. The delegate for this method is slightly different than the last. It's going to return a string, and it takes two arguments; an event message type and a sender, which is a mono behaviour.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's take a look at the <b>Advanced Event Sender</b>:
            <pre>
            <span class="glyphicon-remove"></span>public class AdvancedEventSender : MonoBehaviour {
                public bool mouseIsOverThis = false;

                void Update() {
                    if(mouseIsOverThis) {
                        if(Input.GetMouseButtonDown((int)Mouse.Utils.Button.Left)) {
                            string value = AdvancedEventRelay.RelayEvent(
                                AdvancedEventRelay.EventMessageType.StructureBuilt, this);
                            Debug.Log("StructureBuilt Event was seen by: " + value);
                        }
                        if(Input.GetMouseButtonDown((int)Mouse.Utils.Button.Right)) {
                            string value = AdvancedEventRelay.RelayEvent(
                                AdvancedEventRelay.EventMessageType.UnitDestroyed, this);
                            Debug.Log("UnitDestroyed Event was seen by: " + value);
                        }
                    }
                }

                public void OnMouseEnter() {
                    mouseIsOverThis = true;
                }

                public void OnMouseExit() {
                    mouseIsOverThis = false;
                }   
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this case, when the mouse is over this object, if we click with the left mouse button we're going to relay an event of event type StructureBuilt. We're going to send us as the sender, and then we're going to log the value returned from that event. Likewise, if the right mouse button is pressed, we're going to relay an event of type UnitDestroyed with ourselves as the sender and log the value of the returned string from that event.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's now see how our <b>Advanced Event Listener</b> works:
            <pre>
            <span class="glyphicon-remove"></span>public class AdvancedEventListener : MonoBehaviour {
                public List&lt;AdvancedEventRelay.EventMessageType&gt; eventsHandled = 
                    new List&lt;AdvancedEventRelay.EventMessageType&gt;();

                void OnEnable() {
                    AdvancedEventRelay.OnEventAction += HandleEvent;
                }

                void OnDisable() {
                    AdvancedEventRelay.OnEventAction -= HandleEvent;
                }

                //This method matches the signature of:
                // public delegate string EventAction(EventMessageType type, MonoBehaviour sender);
                //This means we can add it to the OnEventAction

                string HandleEvent(AdvancedEventRelay.EventMessageType messageType, MonoBehaviour sender) {
                    if(eventsHandled.Contains(messageType)) {
                        Debug.Log("Handled event: " messageType + " from sender: " + sender
                         + " " + Vector3.Distance(this.transform.position, sender.transform.position)
                         + " units away from me");

                         return this.ToString();
                    } else {
                        //ignore event
                        return this.ToString();
                    }
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Listeners are going to define a list of events that they handle, and they're going to attach themselves tothe onEventAction of the advanced event relay when they are enabled. And when handling an event, they check to see if this is an event type that they handle. If it is, they're going to log a message that says they handled this event from a sender, and then we're going to output the distance from the sender just to show that we can get some more information from this event system. Finally, they're going to return their name as the event handler. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The last thing we'll need is the <b>Advanced Event Relay</b>:
            <pre>
            <span class="glyphicon-remove"></span>public class AdvancedEventRelay : MonoBehaviour {

                public delegate string EventAction(EventMessageType type, MonoBehaviour sender);
                public static event EventAction OnEventAction;

                public enum EventMessageType {
                    StructureDamage,
                    StructureBuilt,
                    StructureDestroyed,
                    UnitDamage,
                    UnitBuilt,
                    UnitDestroyed
                }

                public static string RelayEvent(EventMessageType messageType, MonoBehaviour sender) {
                    return OnEventAction(messageType, sender);
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Event systems are a great flexible way to communicate between objects without the objects even needing to know about each other in advance, or at all. It's important to note that there's not just one way to create event systems. There are dozens of ways to implement event systems and many different ways to use each implementation. However, event systems, in some form or another, are a very important aspect of game design. Without events, game objects come to rely heavily on each other, and changing one object can have a cascade effect throughout a number of objects. Messaging systems help reduce special case coding, improve seperation of game logic and user interface, and keep objects independent of each other.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="3">
    <h2>Saving and Loading Games</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we'll cover saving the state of a game to disk for later loading, commonly referred to as saving and loading a game. There's not built-in functionality for adding a saved game in Unity because saving a game is unique to the game. Each game has a different set of data that needs to be saved and loaded to represent the game state. This lesson will cover both PC and mobile games as well as web. There is a distinction between the two because web games are a more limited platform. In this case with tighter security. We don't have the same freedom to read and write files on the system when using web.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Since saving is so specific for each game, in this lesson we're going to focus on the general techniques used to serialize object. Lets start of with our <b>Save Load Simple Object</b> script:
            <pre>
            <span class="glyphicon-remove"></span>//using UnityEngine, System.IO;

            public class SaveLoadSimpleObjects : MonoBehavior {
                public string saveFile = @"SaveFile.save";

                void Update() {
                    if(Input.GetKeyDown(KeyCode.L)) {
                        ReadSimpleObjects();
                    }
                    if(Input.GetKeyDown(KeyCode.S)) {
                        WriteSimpleObject();
                    }
                }

                void ReadSimpleObjects() {
                    if(File.Exists(saveFile)) {
                        using(FileStream fs = File.OpenRead(saveFile)) {
                            BinaryReader fileReader = new BinaryReader(fs);
                            int simpleObjectCount = fileReader.ReadInt32();
                            for(int simpleCount = 0; simpleCount < simpleObjectCount; simpleCount++) {
                                GameObject simpleObject = new GameObject();
                                SimpleObject simpleScript = simpleObject.AddComponent&lt;SimpleObject&gt;();
                                simpleScript.ReadObjectState(fileReader);
                            }
                        }
                    }
                }

                void WriteSimpleObjects() {
                    //using statement will dispose of the object inside when we're done using it.
                    //This is important for objects like files that we don't want to leav open.
                    using(FileStream fs = File.OpenWrite(saveFile)) {
                        SimpleObject[] simpleObjects = UnityEngine.Object.FindObjectsOfType&lt;SimpleObject&gt;();
                        BinaryWriter fileWriter = new BinaryWriter(fs);
                        fileWriter.Write(simpleObjects.Length);
                        foreach(SimpleObject simpleObject in simpleObjects) {
                            simpleObject.WriteObjectState(fileWriter);
                        }
                    }
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this script we have a save/load simple object class. It's going to handle saving and loading for us. In this case, when writing simple objects, which are a type of object in our scene, we're going to open a file, collect a list of all the simple objects in the scene. Create a new BinaryWriter and write the number of objects that we have. And then each object in our list is going to write its own state.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Now let's check out or <b>Simple Object</b> script that will be attached to objects that we want to be saved or loaded.:
            <pre>
            <span class="glyphicon-remove"></span>//using UnityEngine, System.IO;

            public class SimpleObject : MonoBehaviour {

                public string aStringObject = "test";
                public float aFloatValue = 43.2f;

                public void WriteObjectState(BinaryWriter binaryWriter) {
                    //Get all the subObjects that are children of this object.
                    SimpleSubObject[] subObjects = this.transform.GetComponentsInChildren&lt;SimpleSubObject&gt;();
                    //Write out how many objects there are, so we know how many to read in later
                    binaryWriter.Write(subObjects.Length);

                    //Each object is responsible for writing it's own state
                    foreach(SimpleSubObject subObject in subObjects) {
                        subObject.WriteObjectState(binaryWriter);
                    }

                    //Now write our own state
                    binaryWriter.Write(aStringObject);
                    binaryWriter.Write(aFloatValue);

                    binaryWriter.Write(this.gameObject.name);
                }

                public void ReadObjectState(BinaryReader binaryReader) {
                    //Get the subObjects count
                    int simpleSubCount = binaryReader.ReadInt32();
                    for(int subCount = 0; subCount < simpleSubCount; subCount++) {
                        GameObject simpleSub = new GameObject();
                        SimpleSubObject simpleSubScript = simpleSub.AddComponent&lt;SimpleSubObject&gt;();
                        simpleSubScript.ReadObjectState(binaryReader);
                        simpleSub.transform.parent = this.transform;
                    }

                    this.aStringObject = binaryReader.ReadString();
                    this.aFloatValue = binaryReader.ReadSingle();

                    this.gameObject.name = binaryReader.ReadString();
                }

                public void WriteObjectState_Web(string prependKey) {
                    //Get all the subObjects that are children of this object
                    SimpleSubObject[] subObjects = this.transform.GetComponentsInChildren&lt;SimpleSubObjects&gt;();
                    //Write out how many objects there are, so we know how many to read in later
                    PlayerPrefs.SetInt(prependKey + "subObjectCount", subObjects.Length);

                    //Each object is responsible for writing its own state.
                    //Maintain a subCount variable to add distinction between objects
                    int subCount = 0;
                    foreach(SimpleSubObject subObject in subObjects) {
                        subObject.WriteObjectState_Web(prependKey + subCount++);
                    }

                    PlayerPrefs.SetString(prependKey + "aStringObject", aStringObject);
                    PlayerPrefs.SetFloat(prependKey + "aFloatValue", aFloatValue);

                    PlayerPrefs.SetString(prependKey + "objectName", this.gameObject.name);
                }

                public void ReadObjectState_Web(string prependKey) {
                    //Get the subObjects count
                    int simpleSubCount = PlayerPrefs.GetInt(prependKey + "subObjectCount");
                    for(int subCount = 0; subCount < simpleSubCount; subCount++) {
                        GameObject simpleSub = new GameObject();
                        SimpleSubObject simpleSubScript = simpleSub.AddComponent&lt;SimpleSubObject&gt;();
                        simpleSubScript.ReadObjectState_Web(prependKey + subCount);
                        simpleSub.transform.parent = this.transform;
                    }

                    this.aStringObject = PlayerPrefs.GetString(prependKey + "aStringObject");
                    this.aFloatValue = PlayerPrefs.GetFloat(prependKey + "aFloatValue");

                    this.gameObject.name = PlayerPrefs.GetString(prependKey + "objectName");
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We'll also need to cover the <b>Simple Sub Object</b> script attached to sub objects:
            <pre>
            <span class="glyphicon-remove"></span>using UnityEngine, System.IO;

            public class SimpleSubObject : MonoBehaviour {

                public string subString = "this is a sub string";
                public int valueX = 43;
                public byte valueB = 2;

                public void WriteObjectState(BinaryWriter binaryWriter) {
                    //write our own state
                    binaryWriter.Write(subString);
                    binaryWriter.Write(valueX);
                    binaryWriter.Write(valueB);

                    binaryWriter.Write(this.gameObject.name);
                }

                public void ReadObjectState(BinaryReader binaryReader) {

                    this.subString = binaryReader.ReadString();
                    this.valueX = binaryReader.ReadInt32();
                    this.valueB = binaryReader.ReadByte();

                    this.gameObject.name = binaryReader.ReadString();
                }

                public void WriteObjectState_Web(string prependKey) {
                    PlayerPrefs.SetString(prependKey + "subString", subString);
                    PlayerPrefs.SetInt(prependKey + "valueX", valueX);
                    PlayerPrefs.SetInt(prependKey + "valueB", valueB);
                    PlayerPrefs.SetString(prependKey + "objectName", this.gameObject.name);
                }

                public void ReadObjectState_Web(string prependKey) {
                    subString = PlayerPrefs.GetString(prependKey + "subString");
                    valueX = PlayerPrefs.GetInt(prependKey + "valueX");
                    valueB = (byte)PlayerPrefs.GetInt(prependKey + "valueB");
                    this.gameObject.name = PlayerPrefs.GetString(prependKey + "objectName");
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's go through the writing process. WriteObjectState is going to accept that BinaryWriter we created before and it's going to collect a list of its children, and write the number of it's children, then each of it's children are going to write their own state. This is a typical pattern when doing recursive serialization. Each object will be responsible for writing its own state when called upon. Finally, this object is going to write its own state at the end. Let's go one deeper and take a look at the sub object writing its own state. The sub object has no sub objects of its own so it's just going to write its own state and then return.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's move on to the reading process. When reading a save file we're going to open our file, create a new binary reader. And from the file, we're going to get the number of objects we need to read. And for each of those objects, we're going to create a new object, create a new script and then have that script read its own state from the file. When an object is reading its own state from the file, it's going to get the number of sub-objects it has. And for each of those sub objects create a new game object and create a new component. Then that component is going to read its own state. As you can see this is identical to the write procedure where we write the number of objects and then each object writes it's own state. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Saving and loading are going to be mirror images of each other. Because when writing state in this way, the data is in a precise order to make reading and writing simple. This means data is byte for byte exactly in the same order when we save and load. If we're off by one byte we'll throw off the entire sequence. The web version of this is nearly identical, except the web version is limited to a dictionary key system. When using the web player, we have restricted access to the hard drive. We can only access the player preferences file. This is limited to one megabyte. Data is stored by a string reference and we can only store strings, floats or ints. It's possible to abuse this system to utilize the same method as we did before, creating a key structure to allow us to set unique keys for each object.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this case we're going to do the same thing where we get the number of sub objects, write the number of sub objects to the player preferences file, and then for each sub object, they will write their own state to the player preferences file. This is not an ideal system for web games since we are limited to one megabyte and can only store strings, floats, and ints. In a web environment the ideal situation would be to use a database. A similar tactic for data can be used in databases. We can break apart the serialization by object and store into tables, or it can combine together into a single binary data block.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we've covered a simple strategy for saving games. There are a lot of different strategies for saving games, and they vary depending on the game type, game mechanics requirements, and even the devlopers personal style. Some games will only ever need to save the high score because the game state doesn't persist beyond that. Other games will need to save the state of hundreds of objects, with each object having dozens of data structures that need to be saved as they are. The strategy we've covered is just one of many. Choosing the right strategy for your game is an important decision that only you can make.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="4">
    <h2>Ray Casting</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Raycasting is used for lots of things in games, including projectiles, path finding, steering, visibility testing, and so on. Unity does provide some pretty robust raycasting with their physics system. However, this does require that objects have physics components, in this case, any kinds of bounding volume, like a box collider.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Raycasting has a few input parameters that allow us to control the behavior of the cast as well. For example, we can define a maximum length and a layer mask. The maximum length is fairly self explanatory, where any hits beyond the maximum distance are ignored. But the layer mask is slightly more tricky. It's a bit mask that allows us to filter what type of object we want to interact with. We'll look at some code that should make this easier to understand.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Scene Setup</b>
            <br>You'll need 4 walls made from cubes with box colliders.
            <br>Name the first two Wall 1. Name the third Wall 2. Name the last Wall 3.
            <br>Place Wall 1's next to each other with a gap. Behind those, place Wall 2. Behind that place Wall 3.
            <br>Give each numbered wall it's own layer. Ex. Wall 1's = Layer 1
            <br>Create another Cube as the "Caster" which will have our script on it.
            <br>Place this caster in front of the two Wall 1s.
            <br>Make sure Gizmos are on.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We'll be casting a ray from this cube along this forward vector. Typically rays are invisible, but we're going to draw the ray using some visual debugging. This ray currrently has a bitmask of zero. Meaning it's not going to hit anything, making it a pretty uniteresting ray. Let's see the <b>Raycaster</b> code and make the ray useful:
            <pre>
            <span class="glyphicon-remove"></span>//using UnityEngine, System.Collections.Generic, System.Text;

            public class Raycaster : MonoBehaviour {
                public float maxDistance = 10;
                public int layerMask = 0;

                public List&lt;Vector3&gt; rayHitPositions = new List&lt;Vector3&gt;;
                public List&lt;Vector3&gt; sphereHitPositions = new List&lt;Vector3&gt;;

                ComboBox layerChooser;

                void Start() {
                    layerChooser = new ComboBox();
                    layerChooser = SetAllowMultiple(true);

                    //There's no built in way to get layers, so LayerUtils was created to get the currently set layers.
                    Dictionary&lt;string, int&gt; layers = LayerUtils.GetLayers();
                    foreach(string layerName in layers.Key) {
                        layerChooster.AddItem(layerName, layers[layerName], OnLayerSelected, OnLayerUnselected);
                    }
                }

                void OnLayerSelected(ComboBox.ComboItem item) {
                    layerMask = layerMask | (1&lt;&lt;(int)item.value);
                }

                void OnLayerUnselected(ComboBox.ComboItem item) {
                    layerMask = layerMask &amp; ~(1&lt;&lt;(int)item.value);   
                }

                void Update() {
                    //Allow us to rotate the caster at 20 degrees per second
                    if(Input.GetKey(KeyCode.A)) {
                        this.transform.Rotate(Vector3.up, 20f * Time.deltaTime);
                    }

                    if(Input.GetKey(KeyCode.D)) {
                        this.transform.Rotate(Vector3.up, -20f * Time.deltaTime);
                    }

                    rayHitPositions.Clear();
                    sphereHitPositions.Clear();

                    if(Input.GetKey(KeyCode.Space)) {
                        DrawRayHitAll();
                    } else {
                        DrawRayHit();
                    }

                    //DrawRayHit();

                    //DrawRayHitAll();

                    //DrawSphereHit();

                    //DrawSphereHitAll();
                }

                /* (Summary)
                    Int to a string 1's and 0's representing the bits of the integer
                    @returns A string representing the bits of an integer
                    @param name="toConvert" - Integer to convert
                */
                string IntToBits(int toConvert) {
                    StringBuilder sb = new StringBuilder();
                    for(int index = 0; index < 32; index++) {
                        if((1&lt;&lt;index &amp; toConvert) > 0)
                            sb.Insert(0, "1");
                        else
                            sb.Insert(0, "0");
                    }

                    return sb.ToString();
                }

                //Draws a ray cast, displaying hit information
                void DrawRayHit() {
                    RaycastHit hitInfo;
                    if(Physics.Raycast(this.transform.position, this.transform.forward, out hitInfo, maxDistance, layerMask)) {
                        //We have a hit
                        Debug.DrawLine(this.transform.position, hitInfo.point, Color.red, 0.01f, true);
                        rayHitPositions.Add(hitInfo.point);
                    } else {
                        Debug.DrawLine(this.transform.position, this.transform.forward * maxDistance, Color.green, 0.01f, true);
                    }
                }

                //Raises the draw gizmos event
                void OnDrawGizmos() {
                    //Draw the hit locations
                    foreach(Vector3 rayHitPosition in rayHitPositions) {
                        Gizmos.DrawWireCube(rayHitPosition, new Vector3(1f, 0.1f, 0.1f));
                    }
                    foreach(Vector3 sphereHitPosition in sphereHitPositions) {
                        Gizmos.DrawWireSphere(sphereHitPosition, 0.5f);
                    }
                }

                //Raises the GUI event
                void OnGUI() {
                    layerChooser.Draw(GUI.skin.box, new Rect(0, 0, 110, 250));
                    GUI.Label(new Rect(130, 0, 230, 40), "LayerMask: " + IntToBits(layerMask));
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            So we'll first look at updating the layer mask. A combo box list here on the left is something being used to easily add or remove layers from the mask. As we check items in the list, our layer mask is updated, as well as our array. We can see that updating it to include Layer1, means that is will now interact with Layer1 object, which both of these one walls are set to Layer 1.
            <br>In Unity there is no built in way to get a list of all the layers, so we've created a get layers method here. That will go through and create a dictionary of the layer names along with their layer value. The Raycaster is going to get a list of all those layers and add them to our Combo Box so that when we select and item, we can OR our current layer mask with the value of the layer mask selected. The layer value stored is the placement of the bit for that layer mask.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We then need to create a new integer by shifting one over at that value, and OR it with our layer maks. So for example the default layer mask is zero. So by adding it to our layer mask we are going to take one and bit-shift it by zero, which means it is going to stay here at the first position. Traparent FX is going to have a value of one, so we're going to take a one, we're going to shift it into our layer mask by one, resulting int this one here. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            So how about hitting multiple objects, by default the array will stop at the first layer that it interacts with. However there is an option to cast array to collect all of the hits that array interacts with. Let's check out that function:
            <pre>
            <span class="glyphicon-remove"></span>//Draws a ray cast, displaying multiple hit inforamtion
            void DrawRayHitAll() {
                Debug.DrawLine(this.transform.position, this.transform.forward * maxDistance, Color.green, 0.01f, true);
                RaycastHit[] hits = Physics.RaycastAll(this.transform.position, this.transform.forward, maxDistance, layerMask);
                if(hits.Length > 0) {
                    foreach(RaycastHit hit in hits) {
                        //We have a hit(s)
                        Debug.DrawLine(this.transform.position, hit.point, Color.red, 0.1f, true);
                        rayHitPositions.Add(hit.point);
                    }
                }
            }
            </pre>
            <p><span class="glyphicon-remove"></span>With this method, we can now interact with multiple layers, and see all of the objects that have been hit. This might be useful if you're shooting a projectile that can go through walls.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Further, one of the other uses I mentioned for Raycasting is path finding. And that might be to see if we can fit our object through a certain area. To do that, we might want to cast a sphere that's the size of the object, to see if it will fit. Let's see that function:
            <pre>
            <span class="glyphicon-remove"></span>//Draws the sphere hit
            void DrawSphereHit() {
                RaycastHit hitInfo;
                if(Physics.SphereCast(this.transform.position, 0.5f, this.transform.forward, out hitInfo, maxDistance, layerMask)) {
                    //We have a hit
                    Debug.DrawLine(this.transform.position, hitInfo.point, Color.red, 0.01f, true);
                    sphereHitPosition.Add(hitInfo.point);
                } else {
                    Debug.DrawLine(this.transform.position, this.transform.forward * maxDistance, Color.green, 0.01f, true);
                }
            }
            </pre>
            <p><span class="glyphicon-remove"></span>Here we're going to cast a sphere, and we're going to see if that sphere will fit through a gap. Here we can see a cylinder acting at the edge, and there we see the ray is now cast through this gap, allowing the sphere to fit. It's could be a close or far gap depending on the scene setup. Additionally, just like the multiple hits for a single ray, there's also a multiple hit for the sphere ray. This might be useful if you're creating a very large projectile, and you want to destroy multiple objects along it's path.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this section we've covered using raycasting functions in Unity. We also discussed some uses for rays. Raycasting is a powerful tool when making decisions in your game. And with plenty of cases, it's likely to make an apprearance in your games. The Raycast in Unity does use the physics system. So be sure to add a collider and layer information to any game object you'd like it to interact with using a ray.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="5">
    <h2>Mini Maps</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section we'll go over adding a mini map to your game. This mini map updates live with the scene and is centered on the players character. Mini maps are frequently used to help guide players to specific locations or just help them find their way around. Many include additional information that's not displayed in the game world, such as areas of interest or quest markers. In the scene, it will be easy to add the map to your scene simply by adding an additional camera to your scene. This camera will sit above the player character, rendering a wider view of the scene and witht the use of layers, we can add additional information to the minimap that's not displayed in the main camera. Lets take a look at the scene.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Scene Setup</b>
            <p><span class="glyphicon-remove"></span>Add 4 floor 2x0.5x2 blocks on the floor in random positions. Set all to Layer 1</p>
            <p><span class="glyphicon-remove"></span>Create 10x10x1 "MiniMapZone" box collider with the image of your interesting location on it using a "Legacy Shaders/Transparent/Diffuse" material with your image attached. Make the collider tall. Make it's layer "MiniMap". This object will have attached our "ZoneOfIntrigue" script.</p>
            <p><span class="glyphicon-remove"></span>Create a 1x1x1 "Character" box collider. Make it's layer "Ignore Raycast". Attach a rigidbody. This will have attached our "MoveTowardsClick" script, and our "MiniMap" script.</p>
            <p><span class="glyphicon-remove"></span>Make the Camera a child of the Character and rotate to (90, 0, 90) and position above the character. Make the tag "MainCamera" and keep in perspective mode with a field of view at 36.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Resources</b>
            <p><span class="glyphicon-remove"></span>characterIconImage (25x25 png) - Red circle. Default import settings.</p>
            <p><span class="glyphicon-remove"></span>CharacterIconMaterial (LegacyShaders/Transparent/VertexLit) - Has the characterIconImage attached. Default import settings.</p>
            <p><span class="glyphicon-remove"></span>CharacterIcon (Prefab) - Layer: "MiniMap", Transform: pos(0,0,0) rot(90,0,0) scale(2,2,1), Quad Mesh, Mesh Renderer (Character Icon Material).</p>
            <p><span class="glyphicon-remove"></span>MiniMapBorder (24x24 png) - White box, Black border. Default import settings.</p>
            <p><span class="glyphicon-remove"></span>ZoneOfIntrigue (24x24 png) - White box, Red border, patterned red corners. Default import settings.</p>
            <p><span class="glyphicon-remove"></span>ZoneOfIntriqueMaterial (LegacyShaders/Transparent/Diffuse) - Has the ZoneOfIntrigue attached. Default import settings.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's now take a look at our <b>Mini Map</b> script:
            <pre>
            <span class="glyphicon-remove"></span>public class MiniMap : MonoBehaviour {

                Camera miniMapCamera;

                public float viewSize = 10f;
                public Vector2 positionOnScreen = new Vector2(0f, 0f);
                public Vector2 size = new Vector2(200f, 150f);
                Texture2D miniMapBorder;
                Rect miniMapRectangle;
                Rect miniMapGUIBorder;
                public bool transparent;

                void Start() {
                    miniMapRectange = new Rect(positionOnScreen.x, (Screen.height - positionOnScreen.y) - size.y, size.x, size.y);
                    miniMapGUIBorder = new Rect(positionOnScreen.x - 5, positionOnScreen.y - 5, size.x + 10, size.y + 10);
                    GameObject miniCam = new GameObject("MiniMapCamera", typeof(Camera));
                    miniMapCamera = miniCam.GetComponent&lt;Camera&gt;();
                    SetupMinimapCamera();

                    GameObject characterIcon = GameObject.Instantiate(Resources.Load("CharacterIcon") as GameObject) as GameObject;
                    characterIcon.transform.parent = this.transform;

                    miniMapBorder = Resrouces.Load("MinimapBorder") as Texture2D;
                }

                private void SetupMinimapCamer() {
                    miniMapCamera.transform.parent = this.transform;
                    miniMapCamera.transform.position = new Vector3(0f, 20f, 0f);
                    miniMapCamera.transform.Rotate(Vector3.right, 90f);
                    miniMapCamera.orthographic = true;
                    miniMapCamera.orthographicSize = viewSize;

                    int layerMask = 0;
                    layerMask |= 1<&lt;&lt;LayerMask.NameToLayer("MiniMap");
                    layerMask |= 1&lt;&lt;LayerMask.NameToLayer("Layer1");

                    miniMapCamera.cullingMask = layerMask;

                    //Convert to viewport coordinates (i.e. 0,0 bottom left, 1,1 top right)
                    miniMapCamera.rect = new Rect(miniMapRectangle.x/Screen.width, miniMapRectangle.y/Screen.height,
                                                    miniMapRectangle.width/Screen.width, miniMapRectangle.height/Screen.height);
                }

                void Update() {
                    //We're simply putting this here so we can see it change live in the demo
                    //Ideally it would go in the setup method above.
                    if(transparent)
                        miniMapCamera.clearFlags = CameraClearFlags.Depth;
                    else
                        miniMapCamera.clearFlags = CameraClearFlags.Skybox;
                }

                void OnGUI() {
                    GUI.DrawTexture(miniMapGUIBorder, miniMapBorder);
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We're going to start by creating a game object, with a component of camera. And then setup that minimap camera by making a child of this object, setting its position above the character. Rotating it, so that it's pointing down, and setting it to an orthographic camera so we don't have the perspective view. Next we're going to add some layer masks to ensure that it shows the extra information we want from the mini map. Finally, we're going to change the view rectangel, so it's in the top left and smaller. In the scene you can see it's in the top left and smaller. And it has a black border around it, which was added as a GUI texture. We can see that we have a different icon for our player in the mini map than we do in the real world. And there's also a red box displayed in the mini map, or a "zone of intrigue", thats not displayed in the game world. The character icon in the mini map is simply an additional object that's rendering a red circle in the mini map layer. This mini map zone is simply a box collider that has a red rectangle, rendered in the mini map layer using a mesh renderer.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's view the <b>Zone of Intrigue</b> code:
            <pre>
            <span class="glyphicon-remove"></span>public class ZoneOfIntrigue : MonoBehaviour {
                void OnTriggerEnter(Collider other) {
                    Debug.Log("Intrigued...");
                }
            }
            </pre>
            <p><span class="glyphicon-remove"></span>This has some detection code, so that when entering the box collider we are displaying a message. At the moment, the minimap also displays a background. We can disable this by checking the Transparent boolean on the minimap camera, allowing us to see through the background. That's done using clear flags, which we can see here, or we can either clear the depth, or we can clear with sky box. Clearing the depth makes it transparent, as there is nothing beyond the background here.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            A little extra script here is the <b>Move Towards Click</b> script:
            <pre>
            <span class="glyphicon-remove"></span>public class MoveTowardsClick : MonoBehaviour {

                Vector3 targetPosition;

                //Speed, in units per second, we want to move towards the target
                public float speed = 5f;

                public bool holdToFollow = true;

                public bool targetSet = false;

                public float stoppingAccuracy = 2f;

                public MouseUtils.Button respondToMouseButton = MouseUtils.Button.Left;

                void Update() {
                    if(holdToFollow) {
                        if(Input.GetMouseButton((int)respondToMouseButton)) {
                            //mouse has been clicked, update position
                            //use the objects current depth, so we can move around on a 2D plane
                            targetPosition = GetMouseAtObjectDepth();
                            //make sure we "turn on" the movement
                            targetSet = true;
                        }
                    } else {
                        if(Input.GetMouseButtonDown((int)respondToMouseButton)) {
                            //mouse has been clicked, update position
                            //use the objects current depth, so we can move around on a 2D plane
                            targetPosition = GetMouseAtObjectDepth();
                            //make sure we "turn on" the movement
                            targetSet = true;
                        }
                    }

                    MoveTowardsTarget();
                }

                //Get position of the mouse at the depth of an object
                Vector3 GetMouseAtObjectDepth() {
                    //Find the depth into the scene, the distance won't work here because objects
                    // directly in front of the camera are closer than object at the edge of the screen.
                    //So we'll get the vector that points to the object, then use the dot product to see
                    // how much of that overlaps with the forward heading of the camera.
                    //Get the vector from the camera to the object
                    Vector3 headingToObject = this.transform.position - Camera.main.transform.position;
                    //Find the projection on the forward vector of the camera.
                    float depth = Vector3.Dot(headingToObject, Camera.main.transform.forward);
                    return GetMouseAtSpecifiedDepth(depth);
                }

                Vector3 GetMouseAtSpecifiedDepth(float depth) {
                    Vector3 mouseScreenPosition = Input.mousePosition;
                    mouseScreenPosition.x = depth;
                    Vector3 mouseWorldPosition = Camera.main.ScreenToWorldPoint(mouseScreenPosition);
                    return new Vector3(mouseWorldPosition.x, mouseWorldPosition.y, mouseWorldPosition.z);
                }

                public void OnDrawGizmos() {
                    if(targetSet) {
                        //Show a line from our current position to the target position
                        Gizmos.DrawLine(this.transform.position, targetPosition);

                        //Show us where the minimum stopping distance is
                        Gizmos.DrawWireSphere(targetPosition, stoppingAccuracy);
                    }
                }

                //Move towards a target at a set speed
                private void MoveTowardsTarget() {
                    //only do work if we have a valid target
                    if(targetSet) {
                        Vector3 currentPosition = this.transform.position;

                        //First, check to see if we're close enough to the target
                        //This check prevents us from oscillating back and forth over the target
                        //If we're farther than 1 unit away, do the movement, otherwise don't
                        if(Vector3.Distance(currentPosition, targetPosition) > stoppingAccuracy) {
                            //Get the direction we need to go by subtracting the current position from the target position
                            Vector3 directionOfTravel = targetPosition - currentPosition;

                            //Now normalize the direction, since we only want the direction information
                            directionOfTravel.Normalize();

                            this.transform.Translate(
                                    (directionOfTravel.x * speed * Time.deltaTime),
                                    (directionOfTravel.y * speed * Time.deltaTime),
                                    (directionOfTravel.z * speed * Time.deltaTime),
                                    Space.World);
                        } else {
                            //We've completed the move, indicate we're done by turning off targetSet
                            targetSet = false;
                        }
                    }
                }

                public override string ToString() {
                    return string.Format("[MoveTowardsClick]: " + targetPosition + " @ "
                                            + speed + "m/s, target set: " + targetSet);
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We're not limited to a top down perspective with our mini map camera. It can be pointed any direction and could even be a first person or rear view camera for a racing game. In this section, we've covered a strategy for creating a mini map camera. The mini map is an important feature for many games, and can be useful for showing additional information, without cluttering up the game world.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="6">
    <h2>Dynamic Meshes</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section we're going to go over creating dynamic meshes with scripts. Creating meshes on the fly is a foundation of a number of modern games. For example, creating meshes at runtime allows us to create proceduraly generated terrain, or destructible environments. Meshes are, at a very basic level, composed of points, in 3D space, along with the instructions on how to connect the dots, and what colors to use when doing that. The primary buildilng blocks of meshes are vertices. The most basic vertices is just to find a point in 3D space.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The instructions for constructing a mesh, are list of indices that define the order of the vertices. At a minimum, a mesh needs three vertices to form a triangle. The simplest 3D shape available for drawing. Let's see our <b>Dynamic Mesh Interface</b> code:
            <pre>
            <span class="glyphicon-remove"></span>//using UnityEngine, System.Collections.Generic;

            [RequireComponent (typeof(MeshFilter))]
            [RequireComponent (typeof(MeshRenderer))]
            [AddComponentMenu("Mesh/Dynamic Mesh Generator")]
            public class DynamicMeshInterface : MonoBehaviour {

                //Clockwise winding order defines the front of the vertex

                List&lt;Vector3&gt; triangleVertices = new List&lt;Vector3&gt;() {
                    new Vector3(0, 0, 0), new Vector3(0, 1, 0), new Vector3(1, 1, 0)
                };

                List&lt;Vector3&gt; quadVertices = new List&lt;Vector3&gt;() {
                    new Vector3(0, 0, 0), new Vector3(0, 1, 0), new Vector3(1, 1, 0), new Vector3(1, 0, 0)
                };

                List&lt;GameObject&gt; customShape = new List&lt;GameObject&gt;();

                bool regenerateCustom = false;

                void Update() {
                    if(Input.GetKeyDown(KeyCode.Alpha1)) {
                        ApplyMesh(triangleVertices);
                    }

                    if(Input.GetKeydown(KeyCode.Alpha2)) {
                        ApplyMesh(quadVertices);
                    }

                    if(Input.GetKeyDown(Keycode.Alpha3)) {
                        AddPointToScene(MouseUtils.GetMouseWorldPositionAtDepth(10));
                    }

                    if(Input.GetKeyDown(KeyCode.Alpha4)) {
                        foreach(GameObject point in customShape)
                            GameObject.Destroy(point);
                        customShape.Clear();
                        regenerateCustom = true;
                    }

                    if(Input.GetMouseButton((int)MouseUtils.Button.Left)) {
                        regenerateCustom = true;
                    }

                    if(regenerateCustom) {
                        List&lt;Vector3&gt; customPoints = new List&lt;Vector3&gt;();
                        foreach(GameObject go in customShape)
                            customPoints.Add(go.transform.position);

                        ApplyMesh(customPoints);
                        regenerateCustom = false;
                    }
                }

                void ApplyMesh(List&lt;Vector3&gt; vertices) {
                    Mesh mesh = DynamicMeshGenerator.GenerateMesh(vertices);
                    GetComponent&lt;MeshFilter&gt;().mesh = mesh;
                }

                void AddPointToScene(Vector3 point) {
                    GameObject newPoint = GameObject.CreatePrimitive(PrimitiveType.Sphere);
                    newPoint.transform.position = point;
                    newPoint.transform.localScale = new Vector3(.3f, .3f, .3f);
                    MouseDragObject mdo = newPoint.AddComponent&lt;MouseDragObject&gt;();
                    customShape.Add(newPoint);
                    regenerateCustom = true;
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            So we've added some attribtes to this model behaviour you may have not seen before. We have some attributes that both require components. This means that when this component is added to the object, these components will also be added, we can't remove these components without first removing this one.
            <p><span class="glyphicon-remove"></span>Next theres an add component menu attribute. This is going to add this component to a specific spot under the Add Component menu, under Mesh/Dynamic Mesh Generator. So we have our dynamic mesh object in our, Add Component menu under Mesh/Dynamic Mesh Generator. We're going to see that mesh filter and mesh renderer were automatically added when we added our dynamic mesh interface.</p>
            <p><span class="glyphicon-remove"></span>Next we're going to set a material so we have something to look at when these meshes get generated, and we can see some simple meshes.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The most simple mesh we'll make is just one triangle. And this list of Vector3s dedfines the points in 3D space that would make a traingle. We can see this with our first template which generates a traignel using the vertices defined in it's list. Number two generates a quad using the vertices defined in it's quad list. It is important to note that these vertices need to be defined in clockwise winding order. That's clockwise winding order when viewing the triangle from the front.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="7">
    <h2>Quad Tree</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            End Goal: Create a quad tree which is mostly used for spatial partitioning. Helps with faster operations like finding nearby objects or culling a scene for visibility.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="8">
    <h2>Extension Methods</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            End goal: Create extension methods which are special type of methods that essentially allow you to add additional methods to a class without having to modify that class.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

                    <!-------------------------------------->
                </div>
            </div>
    </main>

    <!-------------------------------------------------------------------------->

    <!-- FOOTER -->
    <footer class="navbar navbar-inverse navbar-fixed-bottom">
        <nav>
            <div class="container">
                <div class="row">
                    <div class="col-md-6 col-sm-6 col-xs-12">
                        <ul>
                            <li>&copy; 2017 <a href="http://www.gabedeyo.com">Gabe Deyo</a></li>
                            <li>|</li>
                            <li><a href="mailto:gabedeyo@gmail.com?subject=Notes">gabedeyo@gmail.com</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>
    </footer>

    <!-- Latest Minified Slim JQuery -->
    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

    <script src="../js/selection.js" charset="utf-8"></script>
</body>

</html>

<!-- Section Template

<div class="jumbotron col-md-12 heliList" id="">
    <h2>XXX</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

-->
