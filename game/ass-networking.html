<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Advanced Scripting - Networking</title>

    <meta name="viewport" content="width=device-width,initial-scale=1.0, shrink-to-fit=no" />

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/page.css">
</head>

<body>

    <!-- Top Navigation -->
    <header>
        <nav class="navbar navbar-inverse">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapsemenu" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a href="../index.html" class="navbar-brand">Personal Notes</a>
                </div>

                <div class="collapse navbar-collapse" id="collapsemenu">
                    <ul class="nav navbar-nav">

                        <!-- GAME DEVELOMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Game Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- CONCEPTS -->
                                <li><a href="concepts.html">Concepts <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ENGINE -->
                                <li><a href="engine.html">Engine <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- IMPLEMENTATIONS -->
                                <li><a href="implementations.html">Implementations <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- PROGRAMMING -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Programming <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- ALGORITHMS -->
                                <li><a href="../code/algorithms.html">Algorithms <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PROBLEMS -->
                                <li><a href="../code/problems.html">Problems <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- RANDOM -->
                                <li><a href="../code/random.html">Random <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- GABE DEVELOPMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Gabe Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- FITNESS PAGE -->
                                <li><a href="../gabe/fitness.html">Fitness <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- STYLE & GROOMING PAGE -->
                                <li><a href="../gabe/style.html">Style <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- FINANCE PAGE -->
                                <li><a href="../gabe/finance.html">Finance <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PHILOSOPHY PAGE -->
                                <li><a href="../gabe/philosophy.html">Philosophy <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                    </ul>
                </div>

            </div>
        </nav>
    </header>

    <!-------------------------------------------------------------------------->

    <!-- MAIN -->
    <main>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h1 id="title">Advanced Scripting - Networking</h1>

                    <aside>
                        <button type="button" class="btn btn-default" name="button" id="selectAll">Select All</button>
                        <button type="button" class="btn btn-default" name="button" id="clearAll">Clear All</button>
                    </aside>

                    <div class="jumbotron heliList">
                        <h2>Index</h2>
                        <ul>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#1">Master Servers</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#2">Getting Connected</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#3">Remote Procedure Calls</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#4">Chat Clients</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#5">Synchronizing Object Transforms</a>
                                </p>
                            </li>
                        </ul>
                    </div>

<div class="jumbotron col-md-12 heliList" id="1">
    <h2>Master Servers</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this first section, we're going to cover the Master Server. The master server is a tool used for facilitating network games. It basically work like this. When player A creates a new multiplayer game. They send infomation about that game to their master server. Then player B can ask the master server for a list of people hosting games. Player B finds that player A is hosting a game. Then using the connection info provided by the master server, can connect directly with Player A. Essentially, the master server is a middle man. It's a place where Player A and Player B can meet to exchange contact information and connect with each other. The master server doesn't have anything to do with the game after the client and server are connected. It just facilitates the connection. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's check out our <b>Master Server Utils</b> class:
            <pre>
            <span class="glyphicon-remove"></span>//using UnityEngine, System.Collections, System.Collections.Generic, System.Linq;

            public class MasterServerUtils {

                public static string uniqueGameType = "__Unity_Master_Server_GabeDeyo__";

                public static bool useCustomConfiguration = true;
                public static string customConfigIP = "127.0.0.1";
                public static int customConfigPort = 23466;

                private static void ConfigureMasterServer() {
                    if(useCustomConfiguration) {
                        MasterServer.ipAddress = customConfigIP;
                        MasterServer.port = customConfigPort;
                    }
                }

                public static void RequestHostList() {
                    ConfigureMasterServer();
                    MasterServer.RequestHostList(uniqueGameType);
                }

                public static List&lt;HostData&gt; ListHosts() {
                    ConfigureMasterServer();
                    HostData[] hostData = MasterServer.PollHostList();
                    MasterServer.ClearHostList();
                    return hostData.ToList();
                }

                public static void RegisterWithMasterServer(string gameName, string comment) {
                    ConfigureMasterServer();
                    MasterServer.RegisterHost(uniqueGameType, gameName, comment);
                }

                public static void OnFailedToConnectToMasterServer(NetworkConnectionError info) {
                    Debug.Log("Unable to connect to master server! - " + info);
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Here we have a Master Server Utils class that will handle a lot of the master server settings behind the scenes. The first thing we have is a unique game type. This game type should be specific to your game and only your game. When registering with the master server this unique game type distinguishes your game from all the others. Also, in the Master Server Utils is the Configure Master Server method. The master server by default will connect to the Unity servers. The Unity servers provide a testing interface for the master server. This is not recommended for running a production game. The test master servers are frequently down and not reliable enough for regular use. When releasing your own multiplayer game, if you want to use the master server functionality, you can provide your own master server. The master server project is provided by Unity, which can be compiled and produced as masterserver.exe. You'll need to download this from Unity and store in your games Resources folder. It will need to be executing in order to get connections to the Unity server.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The Master SErver Utils class also provides common functionality, like the Request Host List. This is an asynchronous call to the master server. To fill the master server's host list. Then later, when we want to list our hosts, we simply call Pull Host List which will retrieve the list of hosts stored locally. Finally, this class will allow us to register with the master server, using a game name and comment. This will call MasterServer.RegisterHost using our Unique Game Type and this specific game name along with a comment about the game.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Next we'll need to see our <b>Master Server Test Server</b> in order to test:
            <pre>
            <span class="glyphicon-remove"></span>public class MasterServerTestServer : MonoBehaviour {

                int playerCount = 8;
                int serverPort = 23467;
                bool useNAT = false;
                bool serverStarted = false;

                void Update() {
                    if(Input.GetKeyDown(KeyCode.Space) &amp;&amp; !serverStarted) {
                        StartServer();
                    }
                }

                public void StartServer() {
                    //Start a simple server and add it to the master server list
                    //This will allow other players to locate it.
                    NetworkConnectionError state = Network.InitializeServer(playerCount, serverPort, useNAT);

                    if(state == NetworkConnectionError.NoError) {
                        MasterServerUtils.RegisterWithMasterServer("Gabes Game", "This is a comment about Test Server");
                        serverStart = true;
                    } else {
                        Debug.Log("Couldn't initialize server! " + state);
                    }
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The first thing we need to do to test the Master Server is register a server with our master host. Since we're going to be using our custom settings we're going to run a master server locally and connect to it. A compiled version of the master server is found in the resources directory. Running the master server looks like a console window that will display information when clients connect or request information. When we see this when we start a server by initializing it, and then calling MasterServerUtils.RegisterWithMasterServer passing in our game name and a comment about the game.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Next we'll need to see the <b>Master Server Interface</b> class:
            <pre>
            <span class="glyphicon-remove"></span>public class MasterServerInterface : MonoBehaviour {

                public float refreshHostListFrequency = 1.5f;

                ComboBox hostLists;
                List&lt;HostData&gt; hosts = new List&lt;HostData&gt;();
                bool refreshHostList = true;
                bool hostsUpdate = false;

                public delegate void ServerSelected(HostData selectedServer);
                public event ServerSelected OnServerSelected;

                public HostData selectedHost;

                void Awake() {
                    //Request the list as soon as we're able to, so it's ready to disaply
                    MasterServerUtils.RequestHostList();
                }

                void Start() {
                    //Create the list and start the list refreshing
                    hostList = new ComboBox();
                    OnServerSelected += JoiningServer;
                    hostList.SetAllowMultiple(false);
                    StartUpdatingHosts();
                }

                void JoiningServer(HostData selectedServer) {
                    Debug.Log("Joining server: " + selectedServer.gameName);
                }

                void StartUpdatingHosts() {
                    refreshHostList = true;
                    StartCoroutine(UpdateHostsList());
                }

                void StopUpdatingHosts() {
                    refreshHostList = false;
                }

                IEnumerator UpdateHostsList() {
                    while(refreshHostList) {
                        MasterServerUtils.RequestHostList();
                        hosts = MasterServerUtils.ListHosts();
                        hostsUpdate = true;

                        yield return new WaitForSeconds(refreshHostListFrequency);
                    }
                }

                void OnListItemSelected(ComboBox.ComboItem selectedItem) {
                    selectedHost = (HostData)selectedItem.value;
                }

                void OnListItemUnselected(ComboBox.ComboItem unselectedItem) {
                    if(selectedHost == (HostData)unselectedItem.value) {
                        selectedHost = null;
                    }
                }

                void Update() {

                    //Check for an updated list, and refresh the items in the list when we have one.
                    if(hostsUpdate) {
                        hostsUpdated = false;
                        hostList.Clear();
                        foreach(HostData hostdata in hosts) {
                            ComboBox.ComboItem item = hostList.AddItem(hostdata.gameName, hostdata, OnListItemSelected, OnListItemUnselected);
                            //Maintain our selected host, even through a wipe and refresh
                            //Would want to implement a more robust comparison between selectedHost and hostdata
                            if(selectedHost != null &amp;&amp; hostdata.gameName == selectedHost.gameName &amp;&amp; hostdata.ip[0].Equals(selectedHost.ip[0])) {
                                item.Mark();
                                selectedHost = hostdata;
                            }
                        }
                    }
                }

                void OnGUI() {
                    //If we have hosts, list them, otherwise, display a "not found" message.
                    if(hosts.Count > 0) {
                        hostList.Draw(GUI.skin.box, new Rect(0, 0, 220, 300));
                        if(GUI.Button(new Rect(0, 200, 220, 35), "Join selected")) {
                            if(selectedHost != null
                                OnServerSelected(selectedHost);
                        }
                    } else {
                        GUI.Label(new Rect(0, 0, 220, 30), "No hosts found.");
                    }
                }

                //All monobehaviours will have this called when we can't connect to the master server
                // duplicating this function in multiple monobehaviours is fine, it will just duplicate
                // any response to the error (printing messages, trying a new master server, etc.).
                void OnFailedToConnectToMasterServer(NetworkConnectionError info) {
                    MasterServerUtils.OnFailedToConnectToMasterServer(info);
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The next step here is to request a host list and attempt to connect to our own server. The Master Server Interface class provides a list of hosts, a selection interface, as well as events for when hosts are selected. It uses co-routines to regularly update the host list to make sure we're always up to date. In Unity, we can see that no hosts will have been found and the master server will show connections for us pulling for servers. Pressing space bar will start the new server and you can see that it's added to the master server and the next time we update the list, there will be a new server, "Gabes Game" and you can join. At the moment this does nothing because all we have is a test interface.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Scene Setup</b>
            <p><span class="glyphicon-remove"></span>Create an empty "TestServer" object with the Master Server Test Server script attached.
            <p><span class="glyphicon-remove"></span>Create an empty "MasterServerTestInterface" object with the Master Server Interface script attached.
            <br> &nbsp; Set Refresh Host List Frequency to 3.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we've gone over the master server and its uses. The approach of gaving a middle-man for connecting players is a common one. It's useful to reduce the amount of memory, configuration and knowledge each player has to have before hosting or joining a game. This approach is also pretty inexpensive and conventient way to connect players. Most of the bandwidth will be directly between the two players and not using your own server. Further, this allows for players to find each other by game name instead of needing to know each other's IP addresses. This allows players to find each other and connect, which is the first step in getting a multiplayer game.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="2">
    <h2>Getting Connected</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section we're going to go over how to start a server and connect a client. This is a step performed by all network games, and is the first step where the server and client are actually communicating with each other. We'll be using the master server to facilitate the connection by providing details to any client that is interested, as we learned in the previous section. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's check out our <b>Server Host and Join</b> script:
            <pre>
            <span class="glyphicon-remove"></span>public class ServerHostAndJoin : MonoBehaviour {

                public int playerCount = 8;
                public int serverPort = 23467;
                bool useNAT = false;

                public bool lanOnly = true;
                string log = "";
                public bool displayLog = true;
                MasterServerInterface msInterface;

                public Vector2 position = new Vector2(0,0);
                public Vector2 logPosition = new Vector2(0,0);

                //Control the behavior of the script with this
                HostOrJoin hostOrJoin = JostOrJoin.NotSet;

                public enum HostOrJoin {
                    Host,
                    Join,
                    NotSet
                }

                void TakeAction(HostOrJoin choice) {
                    hostOrJoin = choice;

                    //Start or join, not both
                    if(hostOrJoin == HostOrJoin.Host) {
                        StartServer();
                    }

                    if(hostOrJoin == HostOrJoin.Join) {
                        //If we're joining, create a MasterServiceInterface to provide us with the interface for selecting a server
                        msInterface = this.gameObject.AddComponent&lt;MasterServerInterface&gt;();
                        //Provide a callback for when a server is selected.
                        msInterface.OnServerSelected += HandleOnServerSelected;
                    }
                }

                public void StartServer() {
                    //Determine if we should use network address translation
                    //Essentially, YES if server is behind router
                    //             NO if server has a public IP
                    if(lanOnly == true)
                        useNAT = false;
                    else
                        useNAT = !Network.HavePublicAddress();

                    //Start a simple server and add it to the master server list
                    //This will allow other players to locate it.
                    NetworkConnectionError state = Network.InitializeServer(playerCount, serverPort, useNAT);
                    if(state == NetworkConnectionError.NoError) {
                        MasterServerUtils.RegisterWithMasterServer("Gabes Game", "This is a comment about Gabes Game");
                    } else {
                        Log("Server: Couldn't initialize server! " + state);
                    }
                }

                void HandleOnServerSelected(HostData selectedServer) {
                    //When the "Connect" button is pressed in the MasterServerInterface behaviour, this is called
                    if(selectedServer != null) {
                        //Join and hide the host list interface
                        JoinServer(selectedServer);
                    }
                }

                public void JoinServer(HostData hostData) {
                    //Join a server given some HostData, this data is provided by the master server
                    Log("Client: Attempting to join server");
                    Network.Connect(hostData);
                }

                void OnPlayerConnected(NetworkPlayer player) {
                    //Fired in every MonoBehaviour when a player connects to our server
                    Log("Server: Player (" + player.ipAddress + ") connected!");
                }

                void OnServerInitialized() {
                    //Fired in every MonoBehaviour when a server is started
                    Log("Server: Server started.");
                    if(msInterface != null) {
                        msInterface.enabled = false;
                    }
                }

                void OnPlayerDisconnected(NetworkPlayer player) {
                    //Fired in every MonoBehaviour when a player disconnects from our server
                    Log("Server: Player (" + player.ipAddress + ") disconnected!");
                }

                void OnConnectedToServer() {
                    //Fired in every MonoBehaviour when a player connects to a server
                    Log("Client: Connected to server!");
                    if(msInterface != null)
                        msInterface.enabled = false;
                }

                void OnDisconnectedFromServer(NetworkDisconnection info) {
                    //Fired in every MonoBehaviour when a player disconnects from a server
                    Log("Client: Disconnected from server: " + info);
                    if(msInterface != null)
                        msInterface.enabled = true;
                }

                private void Log(string message) {
                    //Some simple logging on screen so we don't have to worry about the debug console.
                    log += "\n" + message;
                }

                void OnGUI() {
                    if(hostOrJoin == HostOrJoin.NotSet) {
                        if(GUI.Button(new Rect(position.x, position.y, 220, 40), "Start Server")) {
                            TakeAction(HostOrJoin.Host);
                        }
                        if(GUI.Button(new Rect(position.x, position.y + 45, 220, 40), "Join Server")) {
                            TakeAction(HostOrJoin.Join);
                        }
                    }

                    //Some simple logging on screen so we don't have to worry about the debug console.
                    if(displayLog)
                        GUI.TextArea(new Rect(logPosition.x, logPosition.y, 220, 300), log);
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Scene Setup</b>
            <p><span class="glyphicon-remove"></span>Create an empty "ServerHostOrJoin" object and attach the Server Host And Join script.
            <br> &nbsp; Set player count to 8, server port to 23467, lan only to true, display log to true, position to (0,0), and log position to (250,0).</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Here we have the Server Host and Join class. This class is going to maintain some information about a server and display some information on screen. This script is going to play two roles. It's either going to host or it's going to join. We can't do both within the same executable. So, when testing this, we're going to need to spawn multiple instances of the game to test both ends. this script is either going to start a server or join a server.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            When starting a server, we're going to determine if we need to use network address translation. Essentially this is a yes if the server is behind a router, and a no if the server has a public IP. Next, we're going to initialize a server using Network.InitializeServer. Passing in our playerCount, serverPort and our useNAT boolean. If there was no error in creating our server, we're going to register with the master server with the name Gabes Game and this is a comment about Gabes Game.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Otherwise, we're going to display an error saying we couldn't initialize our server. So what about the other side of things? When selecting join server, we're going to add a master server interface, which will add the interface that we've discussed in the previous section, allowing us to select a server. We're going to attach ourselves to the OnServerSelected method, which is going to accepth the host data of the selected server. When the event is triggered, we'll receive a selected server, and we'll then call JoinServer. This is going to output a log message and use Network.Connect on the host data to join the server. The remainder of the methods in this class are primarily for logging information and to show you what methods exist for such things as onServerInitialized, onPlayerDisconnected, or onConnectedToServer, or any of the others. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In order to get everything running, make sure the Master Server is running. Start a build in a small window. No that an instance is waiting for us to start or join a server, we're going to start the game in our Unity editor as well. In it, select Start Server. This has started the server, and we can then see it, it's registered with the master server. Then we can go back to our other client and select Join Server which will bring up a list of hosts. We can then see that Gabes Game is there, and we can select Join Selected. We will then see that the server has a player connected, and the client reports success for connecting to the server. Additionally, we can start multiple clients by selecting the executable in the build directory.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we've gone over the basic framework required to get two Unity games connected. The two instances don't need to be on the same computer like this section describes. they can be across the world from each other. The most common issue you'll run into is the clients not being able to reach the server. This is typically because the server's behind a firewall or router and can't be reached with the current network setup. The solution depends on the exact problem. There are a number of tools on the Unity website that will better help facilitate connections. Some of them require more advanced network setups than available to the average person, and some of them can be implemented along with a master server, to automatically help resolve connections to get players connected. If you're having problems getting connected with a remote server, I suggest you look into those resources.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="3">
    <h2>Remote Procedure Calls</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we're going to go over remote procedure calls, RPCs. These are pretty much what they sound like, a call made remotely to execute a procedure. A procedure, in this case, is just another word for method or function. We define methods with a specifal attribute, RPC, when we want to call them with an RPC call. Then, when a client or server is connected to us, they can ask us to run the code inside the tagged method. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's see our <b>Remote Caller</b> script:
            <pre>
            <span class="glyphicon-remove"></span>[RequireComponent (typeof(NetworkView))]
            public class RemoteCaller : MonoBehaviour {

                public bool displayLog = true;
                string log = "";
                public string myName = "byte";

                void Update () {
                    if(Input.GetKeyDown(KeyCode.Space)) {
                        SendGreeting(myName);
                    }
                }

                void SendGreeting(string myName) {
                    GetComponent&lt;NetworkView&gt;().RPC("PrintGreeting", RPCMode.Others, myName);
                    Log("Greeting Sent");
                }

                [RPC]
                public void PrintGreeting(string name) {
                    Log(name + " says: Hello!");
                }

                private void Log(string message) {
                    //Some simple logging on screen so we don't have to worry about the debug console.
                    log += "\n" + message;
                }

                void OnGUI() {
                    //Some simple logging on screen so we don't have to worry about the debug console.
                    if(displayLog)
                        GUI.TextArea(new Rect(220, 0, 230, 600), log);
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Scene Setup</b>
            <p><span class="glyphicon-remove"></span>Create an empty "ServerHostOrJoin" object and attach the Server Host And Join script.
            <br> &nbsp; Set player count to 8, server port to 23467, lan only to true, display log to false, position to (0,0), and log position to (450,0).</p>
            <p><span class="glyphicon-remove"></span>Create an empty "Communicator" object.
            <br> &nbsp; Attach the Remote Caller script. Set Display Log to true, and My Name to "client".
            <br> &nbsp; Attach a Network View component. Set State Synchronization to 0, and leave Observed empty.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Here we have a Remote Caller class that's going to require a component of NetworkView. Network View is a built-in Unity component used for synchronizing two game clients. For our uses, we can turn off state synchronization and set the observe component to none, since we're only using it for RPC calls. The Network View is required for remote procedure calls, so we need to have it for that. This is a simple class that's going to wait for the space key, and if detected, going to call SendGreeting, passing in the myName variable. When sending a greeting, we're going to use our networkView.RPC call and define and method we want to call on the remote end, who we want to send it to, and the parameters that the remote method is going to take.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this case, we're going to be calling the Print Greeting method which is also defined here, and we see it has the attribute RPC. In this case, we're going to be sending a string through the RPC call. The RPC call does have a limited type that it can accept. It can only accept an int, float, string, network player, network view id, vector3 or quaternion. It also accepts byte arrays which are not documented. We'll be using byte arrays in future sections. The RPC mode accepts various options.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We can send to All, we can send to Others, or we can send to Server. The buffered versions will be stored locally and sent to any clients when they connect. The first thing we want to do is ensure that our master server is started. Next we want to go to our build settings and ensure we have the RPC scene selected and build. We're going to override our existing executable. This will start a new instance of the game. Now that this is waiting for commands, we're going to go back to our editor and start another instance and start a server.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            If we check our master server, we can see that it has received the event to add our server to the list. Now going back to our spawned client, we can select Join Server and servers will be listed. We'll select Gabe's Game and join. The two are now connected. Pressing the space bar will call the RPC call, producing the greet sent message here, and our name and says hello on the other end. Alternatiively, we can press space in this client and send a greeting from here.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this section, I've shown you how remote procedure calls work, and when we can use them. RPCs are going to be used fairly widely in any Unity network game. They're a way of calling a method on a remote machine. There's a bit more setup and work and overhead to call the method, but it's a very powerful feature that's relatively simple to use. We'll use RPCs for a number of tasks in future sections.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="4">
    <h2>Chat Clients</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we're going to go over creating a Chat Client. Chat clients, typically a subcomponent of many multi player games, are great examples for showing how to manage connected users, and share data. We want the chat client to accept users that connect to it, and send messages they type to everyone else who is connected.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's take a look at our <b>Chatter</b> class:
            <pre>
            <span class="glyphicon-remove"></span>[RequireComponent (typeof (NetworkView))]
            public class Chatter : MonoBehaviour {

                MessageWindow messageWindow;
                string chatInput = "";

                float messageDisplayTime = 60;

                public GUISkin chatterSkin;

                Vector2 chatOutputSize = new Vector2(350, 175);
                Vector2 chatOutputPosition = new Vector2(0, Screen.height - 200);

                Vector2 chatInputSize = new Vector2(350, 25);
                Vector2 chatInputPosition = new Vector2(0, Screen.height - 25);
                
                string myName = "NoName";
                bool nameSet = false;

                bool connected = false;
                
                Rect chatInputRect;
                Rect chatOutputRect;
                Rect entireChatArea;

                Dictionary&lt;NetworkPlayer, string&gt; usersByID = new Dictionary&lt;NetworkPlayer, string&gt;();

                void Start () {
                    chatInputRect = new Rect(chatInputPosition.x, chatInputPosition.y, chatInputSize.x, chatInputSize.y);
                    chatOutputRect = new Rect(chatOutputPosition.x, chatOutputPosition.y, chatOutputSize.x, chatOutputSize.y);

                    entireChatArea = new Rect(chatInputPosition.x, chatInputPosition.y, Mathf.Max(chatInputSize.x, chatOutputSize.x), chatInputSize.y + chatOutputSize.y);

                    messageWindow = new MessageWindow(chatOutputSize, chatterSkin);

                }

                void Update () {
                    if(!GUIUtils.MouseOverRect(entireChatArea)) {
                        messageWindow.pauseAutoScroll = false;
                        messageWindow.CountDownTimers();
                    } else {
                        messageWindow.pauseAutoScroll = true;
                    }
                }

                void SetName(string newName) {
                    //Only after setting a name will the player be joined to the chat
                    nameSet = true;
                    if(Network.isServer) {
                            JoinUser(newName, Network.player);
                        } else {
                            GetComponent&lt;NetworkView&gt;().RPC("JoinUser", RPCMode.Server, myName, Network.player);
                            GetComponent&lt;NetworkView&gt;().RPC("Server_SendCurrentUsers", RPCMode.Server, Network.player);
                        }
                    }
                    
                    void ProcessInput() {
                        if(chatInput.Length > 0)
                            GetComponent&lt;NetworkView&gt;().RPC ("LogMessage", RPCMode.All, chatInput, Network.player);
                        
                        chatInput = "";
                    }

                    
                    void OnConnectedToServer() {
                        connected = true;
                    }
                    
                    void OnServerInitialized() {
                        connected = true;
                    }
                    
                    void OnDisconnectedFromServer(NetworkDisconnection info) {
                        if (Network.isServer)
                            SystemMessage("Server connection lost!", Network.player);
                        else
                            if (info == NetworkDisconnection.LostConnection)
                                SystemMessage("Lost connection to server!", Network.player);
                        else
                            SystemMessage("Successfully diconnected from server.", Network.player);
                    }
                    
                    void OnPlayerDisconnected(NetworkPlayer player) {
                        RemoveUser(player);
                    }


                    [RPC]
                    void Server_SendCurrentUsers(NetworkPlayer recipient) {
                        //In case someone else gets this message, only reply if we're the server
                        if(Network.isServer) {
                            foreach(NetworkPlayer user in usersByID.Keys) {
                                GetComponent&lt;NetworkView&gt;().RPC("JoinUser", recipient, usersByID[user], user);
                            }
                        }
                    }
                    
                    [RPC]
                    void JoinUser(string name, NetworkPlayer player) {
                        if(!this.usersByID.ContainsKey(player)) {
                            this.usersByID.Add(player, name);

                            if(Network.isServer) {
                                //Since we're server, let everyone know when someone joins.
                                //This includes the someone who joined, so they can add themselves and get the message
                                GetComponent&lt;NetworkView&gt;().RPC("JoinUser", RPCMode.Others, name, player);
                                GetComponent&lt;NetworkView&gt;().RPC("SystemMessage", RPCMode.All, "Joined chat.", player);
                            }
                        }
                    }


                    [RPC]
                    void RemoveUser(NetworkPlayer player) {
                        if(this.usersByID.ContainsKey(player)) {
                            SystemMessage("Has left chat", player);
                            //If we're the server, let everyone know when someone leaves.
                            if(Network.isServer) {
                                GetComponent&lt;NetworkView&gt;().RPC("RemoveUser", RPCMode.Others, player);
                            }
                            this.usersByID.Remove(player);
                        }
                    }

                    [RPC] 
                    void SystemMessage(string message, NetworkPlayer player) {
                        if(usersByID.ContainsKey(player)) {
                            message = usersByID[player] + ": " + message;
                            messageWindow.AddMessage(messageDisplayTime, message);
                            
                        } else {
                            //We don't know that user? Why not? Get the user list again, maybe we'll know for next time.
                            GetComponent&lt;NetworkView&gt;().RPC("Server_SendCurrentUsers", RPCMode.Server, Network.player);
                        }
                    }

                    [RPC] 
                    void LogMessage(string message, NetworkPlayer player) {
                        if(usersByID.ContainsKey(player)) {
                            //If we didn't say it, enter add some info about who did
                            if(player != Network.player) {
                                message = usersByID[player] + " said: " + message;
                            }

                            messageWindow.AddMessage(messageDisplayTime, message);
                        } else {
                            //We don't know that user? Why not? Get the user list again, maybe we'll know for next time.
                            GetComponent&lt;NetworkView&gt;().RPC("Server_SendCurrentUsers", RPCMode.Server, Network.player);
                        }
                    }


                    void OnGUI() {
                        if(connected) {
                            if(nameSet) {

                                messageWindow.Draw(chatOutputPosition);

                                if (Event.current.Equals(Event.KeyboardEvent("return")) &amp;&amp; GUI.GetNameOfFocusedControl().Equals("TextInput")) {
                                    ProcessInput();
                                }
                                GUI.SetNextControlName("TextInput");
                                chatInput = GUI.TextField(chatInputRect, chatInput);

                            } else {
                                //Require the user set their name before they're fully joined to the chat server.
                                GUI.Label(chatOutputRect, "Please enter your name");
                                if (Event.current.Equals (Event.KeyboardEvent ("return")) &amp;&amp; GUI.GetNameOfFocusedControl().Equals("NameInput") &amp;&amp; myName.Length > 0) {
                                    SetName (myName);
                                }
                                
                                GUI.SetNextControlName("NameInput");
                                myName = GUI.TextField(chatInputRect, myName);

                                GUI.FocusControl("NameInput");
                            }
                        }
                    }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Scene Setup</b>
            <p><span class="glyphicon-remove"></span>Create an empty "ServerHostOrJoin" object.
            <br> &nbsp; Attach the ServerHostAndJoin script. Set Player Count to 8, Server Port to 23467, Lan Only to true, Display Log to false, Position to (0,0), and Log Position to (210,0).</p>
            <p><span class="glyphicon-remove"></span>Create an empty "ChatClient" object.
            <br> &nbsp; Attach the Chatter script. Create a new "Chatter" guiskin object and place on the Chatter script. Look to video for guiskin settings. Also attach a Network View to ChatClient.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The Chatter component is going to take care of all the chat client needs. It's going to require a Network View because we're going to be using RPC calls. It's local variables set information about display message timeout, it's representation on screen, and the current user name. Additionally it's going to contain a usersByID list, which will be a look up table for NetworkPlayers to their names. Much of the GUI functionality from a chat window comes from our message window class which we learned about in previous sections.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            After the client is connected, the first thing they'll do is set their name. If we are the server, we're going to directly join that user. Otherwise we're going to ask the server to join the user. And then send a request to the server to send us all the current users connected. The process input method is going to be called when the user hits Enter after entering a line of text. It will trigger an RPC call for the LogMessage method and send in our chat input. This RPC call will include the user who sent the message. In the LogMessage method, we're going to take a message and the sender. If we're the sender we're simply going to AddMessage to our screen. If someone else sent us a message, we're going to add their name and "said", plus the message to the screen. If we receive a message from an unknown user, we're going to ask the server to send us their current users, because something went wrong and our user list is out of date.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            When the server is asked to send current users, it's going to go through its user list. And for each user in the list, it's going to send an RPC call JoinUser directly to the recipient who requested it, passing on the user name, and NetworkPlayer. When joining a new user, all users will add that user to the ID list and if it's a server, it's going to call JoinUser for all other connected clients and send a SystemMessage telling all connected clients that a user joined chat. Likewise we'll have a command for removing user where all users will be notified when they leave chat.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The difference between system message and LogMessage is that system messages are generally sent from the Server, and will be displayed differently. Let's take a look at this in Unity. You'll need to start the master server, and go through the build process to start a new client. Then launch another client in the Unity Editor and start the Server. Switch back to the other client and join the server and enter My Name as Client.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            You'll see a system message that have been sent saying that client has joined chat. When sending the message, on the Sender's end it will just print the message you typed and on the Receiver end it will say Client said "hello". When a Client Joins a server it is going to connect to the Server and the first thing its going to do is set it's name. When setting it's name it's going to send a JoinUser command to the Server. The Server will then add that user to it's local list and send a message to all other Clients saying that user has joined. This includes the Client who's just joined.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            After setting the name it's going to Send Current Users request to the Server. This Send Current User's request is going to iterate through all the user it has in it's list, and send a Join User RPC call to the Client that requested it. This will add all connected users to the local client's user list. When a Client is sending a message, it simply sends a Log Message command to all connected users. This includes a Server and All Clients.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this section we've covered how to create a Chat Client. Chat Clients are very common in multi-player games. This Chat Client shows you how you might manage users joining to the game, and let other players know about those users joining. It also shows you how you can send information to everyone peer-to-peer style like when we process input to send messages. Or we can send information to the Server and have the Server distribute it, client-to-server style. Like when a new player joins. The Chat Client recreated, fulfills the basic requirements, but there are some features that are missing to be a full featured Chat Client. For example, I suggest you add a Tell feature to allow the client to send messages to specific users.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="5">
    <h2>Synchronizing Object Transforms</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

                    <!-------------------------------------->
                </div>
            </div>
    </main>

    <!-------------------------------------------------------------------------->

    <!-- FOOTER -->
    <footer class="navbar navbar-inverse navbar-fixed-bottom">
        <nav>
            <div class="container">
                <div class="row">
                    <div class="col-md-6 col-sm-6 col-xs-12">
                        <ul>
                            <li>&copy; 2017 <a href="http://www.gabedeyo.com">Gabe Deyo</a></li>
                            <li>|</li>
                            <li><a href="mailto:gabedeyo@gmail.com?subject=Notes">gabedeyo@gmail.com</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>
    </footer>

    <!-- Latest Minified Slim JQuery -->
    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

    <script src="../js/selection.js" charset="utf-8"></script>
</body>

</html>

<!-- Section Template

<div class="jumbotron col-md-12 heliList" id="">
    <h2>XXX</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

-->
