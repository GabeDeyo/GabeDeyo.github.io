<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Advanced Scripting - GUI Controls</title>

    <meta name="viewport" content="width=device-width,initial-scale=1.0, shrink-to-fit=no" />

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/page.css">
</head>

<body>

    <!-- Top Navigation -->
    <header>
        <nav class="navbar navbar-inverse">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapsemenu" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a href="../index.html" class="navbar-brand">Personal Notes</a>
                </div>

                <div class="collapse navbar-collapse" id="collapsemenu">
                    <ul class="nav navbar-nav">

                        <!-- GAME DEVELOMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Game Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- CONCEPTS -->
                                <li><a href="concepts.html">Concepts <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ENGINE -->
                                <li><a href="engine.html">Engine <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- IMPLEMENTATIONS -->
                                <li><a href="implementations.html">Implementations <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- PROGRAMMING -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Programming <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- ALGORITHMS -->
                                <li><a href="../code/algorithms.html">Algorithms <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PROBLEMS -->
                                <li><a href="../code/problems.html">Problems <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- RANDOM -->
                                <li><a href="../code/random.html">Random <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- GABE DEVELOPMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Gabe Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- FITNESS PAGE -->
                                <li><a href="../gabe/fitness.html">Fitness <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- STYLE & GROOMING PAGE -->
                                <li><a href="../gabe/style.html">Style <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- FINANCE PAGE -->
                                <li><a href="../gabe/finance.html">Finance <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PHILOSOPHY PAGE -->
                                <li><a href="../gabe/philosophy.html">Philosophy <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                    </ul>
                </div>

            </div>
        </nav>
    </header>

    <!-------------------------------------------------------------------------->

    <!-- MAIN -->
    <main>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h1 id="title">Advanced Scripting - GUI Controls</h1>

                    <aside>
                        <button type="button" class="btn btn-default" name="button" id="selectAll">Select All</button>
                        <button type="button" class="btn btn-default" name="button" id="clearAll">Clear All</button>
                    </aside>

                    <div class="jumbotron heliList">
                        <h2>Index</h2>
                        <ul>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#1">Combo Box</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#2">Rotatable GUI Items</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#3">Progress Bar</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#4">Tables</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#5">Message Windows</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#6">GUI Items Over GameObjects</a>
                                </p>
                            </li>
                        </ul>
                    </div>

<div class="jumbotron col-md-12 heliList" id="1">
    <h2>Combo Box</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we're going to go over how to create a typical Combo Box. A combo box is a common feature in many GUIs, but missing in the standard GUI controls provided by Unity. Combo boxes are used by selecting one or many items from a list. The list can be a list of anything, and it can have multiple uses. For example it could contain strings which define which settings to use. Or it could contain game objects that would be your quest reward for the player. This means we will want to be able to associate an object with each object in the list to make it easier to use. We will also want to know when an item has been selected. Knowing when an item has been selected means we can respond for example by displaying more information about that choice, or previewing the selection in some way. Sounds like a job for events.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's check out our <b>Combo Box</b> class:
            <pre>
            <span class="glyphicon-remove"></span>//using UnityEngine, System, System.Collections, System.Collections.Generic;

            public class ComboBox : ScriptableObject {

                public List&lt;ComboItem&gt; items;

                bool allowMultiple;

                //We'll keep track of the last marked item for clean transition between selecting multiple and single
                private ComboItem lastMarked;

                //The combo item is the object that'll hold all the information for each item in the list
                //It will draw itself, tell us if it's marked, and hold its name and value
                //The name and value will be defined by the user
                //Additionally, it has events we can attach to for when this item is selected or unselected
                [Serializable]
                public class ComboItem {
                    public string name;
                    public System.Object value;
                    public bool marked;

                    public delegate void OnMarked(ComboItem item);
                    public delegate void OnUnMarked(ComboItem item);

                    public event OnMarked OnMarkedAction;
                    public event OnUnMarked OnUnMarkedAction;

                    public ComboItem(string name, System.Object value) {
                        this.name = name;
                        this.value = value;
                        this.marked = false;
                    }

                    //Draw ourselves. In this case, when selected, just append a check mark to the name
                    //Extending this to instead draw a textured checkbox or empty checkbox may be needed
                    // for stylistic requirements

                    public void Draw(GUIStyle style) {
                        GUILayout.BeginHorizontal();
                        string renderName = name;
                        if(this.marked)
                            renderName += " âœ”";

                        if(GUILayout.Button(renderName, style)) {
                            if(this.marked)
                                UnMark();
                            else
                                Mark();
                        }

                        GUILayout.EndHorizontal();
                    }

                    public void Mark() {
                        this.marked = true;
                        OnMarkedAction(this);
                    }

                    public void UnMark() {
                        this.marked = false;
                        OnUnMarkedAction(this);
                    }

                    public ComboBox() {
                        items = new List&lt;ComboItems&gt;();
                        allowMultiple = true;
                    }

                    private void OnComboItemMarked(ComboItem item) {
                        //Debug.Log("Item: " + item.name + " marked");

                        //Keep track of last marked
                        lastMarked = item;

                        //Since ComboItems dont' know about each other, we need to handle
                        // unmarking any other Combo Items a level up, here in the ComboBox
                        if(!allowMultiple) {
                            foreach(ComboItem comboItem in items) {
                                if(comboItme != item &amp;&amp; comboItem.marked) {
                                    comboItem.UnMark();
                                }
                            }
                        }
                    }

                    private void OnComboItemUnMarked(ComboItem item) {
                        //Debug.Log("Item: " + item.name + " unmarked");

                        //Clear the last marked if we've unmarked it
                        if(item == lastMarked)
                            lastMarked = null;
                    }

                    public ComboItem AddItem(string name, System.Object value) {
                        ComboItem newItem = new ComboItem(name, value);
                        this.items.Add(newItem);
                        newItem.OnMarkedAction += OnComboItemMarked;
                        newItem.OnUnMarkedAction += OnComboItemUnMarked;
                        return newItem;
                    }

                    public ComboItem AddItem(string name, System.Object value,
                                        ComboItem.OnMarked markedDelegate,
                                        ComboItem.OnUnMarked unmarkedDelegate) {
                        ComboItem newItem = new ComboItem(name, value);
                        this.items.Add(newItem);
                        newItem.OnMarkedAction += OnComboItemMarked;
                        newItem.OnMarkedAction += markedDelegate;
                        newItem.OnUnMarkedAction += OnComboItemUnMarked;
                        newItem.OnUnMarkedAction += unmarkedDelegate;
                        return newItem;
                    }

                    public void AddItems(ComboItem newItem) {
                        this.items.Add(newItems);
                        newItem.OnMarkedAction += OnComboItemMarked;
                        newItem.OnUnMarkedAction += OnComboItemUnMarked;
                    }

                    public void Clear() {
                        items.Clear();
                    }

                    public void Draw(GUIStyle style, Rect rect) {
                        GUILayout.BeginArea(rect);
                        GUILayout.BeginVertical();
                        foreach(ComboItem item in items) {
                            item.Draw(style);
                        }
                        GUILayout.EndVertical();
                        GUILayout.EndArea();
                    }

                    public void SetAllowMultiples(bool allow) {
                        allowMultiple = allow;
                        if(!allowMultiple) {
                            foreach(ComboItem comboItem in items) {
                                if(comboItem != lastMarked &amp;&amp; comboItem.marked) {
                                    comboItem.UnMark();
                                }
                            }
                        }
                    }

                    public bool AllowsMultiple() {
                        return allowMultiple;
                    }
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            So in the scene we'll have a combo box that's going to implement the scriptable item class. We're not using mono behaviour, because we're not going to use any of the mono behaviour functionality, so we won't need to include it. The combo box is going to keep a list of all the combo items as well as keeping track of the last item marked and a boolean value to allow multiples or not.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The combo item contains a name and a value, as well as information about if it's marked or not. And some delegates to attach to, to notify listeners when this item has been checked or unchecked. Additionally, the combo box item is going to be responsible for drawing itself. We're going to pass into GUI style. It's going to render its name, check a mark, and a button. This button will be used to interact with the GUI item. If the button is clicked, and we're marked, we're going to unmark. Otherwise, we're going to mark. And then we have our mark and unmark methods. We'rejust setting our own value to true or false, and triggering our events.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The combo box itself is just going to be a list of items. And, we're going to have some of our own listeners to know whether items are checked or not. Since each combo item doesn't know anything about the others, when we're not allowing multiple items to be checked, we need to go through each of our items and un-mark them when a new item is marked.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Next we have our Add Item methods. These are going to be various combinartions of adding an item. Either by name or object, or name and object and delegates for listeneing to when that item is going to be marked or unmarked. Or just adding a new combo item that we've created elsewhere. The Draw method for the combo box is just going to be responsible for iterating through each item and having that item draw itself. Finally when toggling they allow multiple. If we currently have multiple items checked we're going to uncheck all of them but the last item.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We'll need to check out our <b>Combo Box Testing Interface</b> in order to visualize this:
            <pre>
            <span class="glyphicon-remove"></span>public class ComboBoxTestInterface : MonoBehaviour {

                ComboBox cb;
                GUIStyle style;

                void Start() {
                    cb = new ComboBox();
                    style = new GUIStyle();
                    foreach(Transform child in this.transform) {
                        ComboBox.ComboItem childItem = new ComboBox.ComboItem(child.name, child);
                        childItem.OnMarkedAction += SelectItem;
                        childItem.OnUnMarkedAction += DeselectItem;
                        cb.AddItem(childItem);
                    }
                }

                void Update() {
                    if(Input.GetKeyDown(KeyCode.Tab)) {
                        cb.SetAllowMultiple(!cb.AllowsMultiples());
                    }
                }

                void SelectItem(ComboBox.ComboItem item) {
                    //Move the item up so we can see it's selected
                    ((Transform)item.value).Translate(0, 1, 0);
                }

                void DeselectItem(ComboBox.ComboItem item) {
                    //Move the item down so we can see it's not selected
                    ((Transform)item.value).Translate(0, -1, 0);
                }

                void OnGUI() {
                    if(cb.AllowsMultiple()) {
                        GUI.Label(new Rect(30, 10, 180, 20), "Please select items");
                    } else {
                        GUI.Label(new Rect(30, 10 180, 20), "Please select an item");
                    }
                    cb.Draw(Style, new Rect(30, 30, 180, 400));
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            This Combo Box Interface is going to create a combo box and for each of its children it's going to add a combo item to the combo box. As well as adding its own listener, so it knows when each item is checked or unchecked. Finally it's listeners are just going to translate an object up or down depending if it's selected or unselected. In the OnGUI method, we're going to draw a label, asking the user to select items, or select a single item, depending on if we're allowing multiple. And then we're going to call the combo box draw method to draw the combo box itself.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Scene Setup</b>
            <p><span class="glyphicon-remove"></span>Create an empty "GUI" object with the Combo Box Interface script attached. Create 3 or more children of this object as spheres to be represented as our choices.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this section we've covered creating a Combo Box GUI item. This type of control has many uses. A Combo Box control is object agnostic. It doesn't matter what you put into the list, it will simply work the same. This is important because we want the GUI controls to be very flexible because they are used in many places for many different things. The Combo Box also gives us the ability to attach our own methods to the marking and unmarking of any item in the list. This continues with our goal of making the Combo Box flexible and useable in any situation required. We now have a Combo Box that can be used in a number of situations, without needing to modify the combo box code to fit each situation.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="2">
    <h2>Rotatable GUI Items</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we're going to go over how to rotate a GUI object. Rotating GUI objects has a number of uses. For example, creating a gooey compas or waypoint marker. It also allows for additional customization in the layout of labels and tabs in an interface. Unity GUI controls don't come with functionality to rotate by default. However, we can use the information we learn here to create our own copies of GUI controls, as well as our own controls that we'll be able to rotate. The contents of all GUI elements are defined by a GUI content object.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            GUI content can be a string, texture, or both with the option to define a tool tip. Since GUI content is the base content of a GUI element, we'll focus on being able to rotate that. For this example, we'll rotate a box control with our GUI content inside. However it's possible to alter this code to rotate any GUI we control like a label, button or anything else.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's first check out our <b>Rotatable GUI Item</b> class:
            <pre>
            <span class="glyphicon-remove"></span>public class RotatableGuiItem : ScriptableObject {

                protected Vector2 size;
                protected Rect rect;

                protected Vector2 pivot;

                //Pivot around the center of the rectangle by default
                private PivotPoint xPivot = PivotPoint.Center;
                private PivotPoint yPivot = PivotPoint.Center;

                private Matrix4x4 matrixBackup;

                public enum PivotPoint {
                    Center,
                    Min,
                    Max
                }

                //Center = Center, Center
                //TopLeft = Min, Min
                //TopCenter = Center, Min
                //TopRight = Max, Min
                //RightCenter = Max, Center
                //BottomRight = Max, Max
                //BottomCenter = Center, Max
                //BottomLeft = Min, Max
                //LeftCenter = Min, Center

                public void Initalize() {
                    rect = new Rect(0, 0, size.x, size.y);
                    SetPivot(xPivot, yPivot);
                }

                public Vector2 GetPivot(Rect sourceRect, PivotPoint xPivotPoint, PivotPoint yPivotPoint) {
                    float xPivotValue = source.xMin;
                    float yPivotValue = source.yMin;

                    switch(xPivotPoint) {
                        case PivotPoint.Center:
                            xPivotValue = sourceRect.xMin + sourceRect.width * 0.5f;
                            break;
                        case PivotPoint.Min:
                            xPivotValue = sourceRect.xMin;
                            break;
                        case PivotPoint.Max:
                            xPivotValue = sourceRect.xMax;
                            break;
                    }

                    switch(yPivotPoint) {
                        case PivotPoint.Center:
                            yPivotValue = sourceRect.yMin + sourceRect.height * 0.5f;
                            break;
                        case PivotPoint.Min:
                            yPivotValue = sourceRect.yMin;
                            break;
                        case PivotPoint.Max:
                            yPivotValue = sourceRect.yMax;
                            break;
                    }

                    return new Vector2(xPivotValue, yPivotValue);
                }

                public void SetPivot(PivotPoint xPivotPoint, PivotPoint yPivotPoint) {
                    xPivot = xPivotPoint;
                    yPivot = yPivotPoint;

                    pivot = GetPivot(rect, xPivot, yPivot);
                }

                public RotatableGuiItem(Vector2 size) {
                    this.size = size;
                    Initalize();
                }

                public void Draw(float angle, GUIStyle style, GUIContent content) {
                    BeginDrawRotated(angle);
                    GUI.Box(rect, content, style);
                    EndDrawRotated();
                }

                public void BeginDrawRotated(float angle) {
                    matrixBackup = GUI.matrix;
                    GUIUtility.RotateAroundPivot(angle, pivot);
                }

                //Used only after BeginDrawRotated!
                public bool RotatedRectContains(Vector2 rectPosition, Vector2 pointToTest) {
                    Rect nonRotatedRect = new Rect(rectPosition.x, rectPosition.y, rect.width, rect.height);

                    Vector3[] nonRotatedPoints = new Vector3[] {
                        //Separate out the points, since the rect object only supports axis aligned rectangles.
                        new Vector3(nonRotatedRect.xMin, nonRotatedRect.yMin, 0),
                        new Vector3(nonRotatedRect.xMax, nonRotatedRect.yMin, 0),
                        new Vector3(nonRotatedRect.xMax, nonRotatedRect.yMax, 0),
                        new Vector3(nonRotatedRect.xMin, nonRotatedRect.yMax, 0)
                    };
                    Vector2[] rotatedPoints = new Vector2[4];

                    //Rotate the points based on the GUI matrix
                    for(int p = 0; p < nonRotatedPoints.Length; p++) {
                        rotatedPoints[p] = GUI.matrix.MultiplyPoint(nonRotatedPoints[p]);
                    }

                    //Convex shape is a bit more complex than we need for a rectangle,
                    // however I wanted to include the code so you can use it for other convex shapes
                    return GUIUtils.ConvexShapeContains(rotatedPoints, pointToTest);
                }

                public void EndDrawRotated() {
                    if(matrixBackup != null)
                        GUI.matrix = matrixBackup;
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Here, we have a Rotatable GUI Item, which is going to take a size, rectangle, and pivot point. The pivot point is going to be calculated by defining an x-axis pivot point and a y-axis pivot point. These two have the option to be in center, min, or max. Giving us nine total options for pivot points, the four corners, any of the middle four edges, and the center point. Initializing a new rotatable GUI item is going to create the rectangle that we're going to rotate, as well as the pivot point. Getting the pivot point is going to take a source rectangle and the two pivot point axes to give us a point on screen in which we'll rotate around.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Setting the pivot point will update the pivot point axes and calculate a new pivot point using Get Point. Drawing a rotatable GUI item is going to begin with Begin Draw Rotated. This is going to take the angle that we want to rotate, create a backup of our current matrix, and use the GUI utility Rotate Around Pivot, providing our angle and the pivot point calculated earlier. When we're done drawing our GUI box, we're going to call End Draw Rotated, which is simply going to restore the backed up matrix.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's see how we can implement this with our <b>Rotatable GUI Item Test Interface</b> script:
            <pre>
            <span class="glyphicon-remove"></span>public class RotatableGuiItemTestInterface : MonoBehaviour {

                RotatableGuiItem rotateString;
                GUISyle style;
                float angle = 0;

                private GUIContent contentToRotate;

                void Start() {
                    style = new GUIStyle();
                    contentToRotate = new GUIContent("Rotate this gui item using the A and D keys!");

                    Vector2 contentSize = style.CalcSize(contentToRotate);
                    rotateString = new RotatableGuiItem(new Vector2(contentSize.x, contentSize.y));

                    //rotateString.SetPivot(RotatableGuiItem.PivotPoint.Min, RotatableGuiItem.PivotPoint.Center);
                }

                void Update() {
                    if(Input.GetKey(KeyCode.A)) {
                        angle += 1;
                    }
                    if(Input.GetKey(KeyCode.D)) {
                        angle -= 1;
                    }
                }

                void OnGUI() {
                    Vector2 contentSize = style.CalcSize(contentToRotate);
                    GUI.BeginGroup(new Rect(200, 200, contentSize.x, contentSize.y));
                    rotateString.Draw(angle, style, contentToRotate);
                    GUI.EndGroup();
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Here we're going to create a new rotatable GUI item and a new GUI content. We're going to calculate the size of this content in order to determine the size of our rotatable GUI item. In the update method, we're going to accept the A and D key to increase or decrease the angle we want to rotate. Finally, in the OnGUI method, we're going to draw a rotate string with rotateString.draw.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we've learned how we can rotate GUI controls. The ability to rotate GUI controls adds additional flexibility to your layout options and interaction with the player. Keep in mind that if you're going to have a control that's always rotated, it is likely better to create the asset for the control as it should be displayed. There are performance impacts to consider with rotating GUI controls, and if we could avoid rotating them every time, it's best we do.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="3">
    <h2>Progress Bar</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we'll go over how to create a progress bar GUI component. Progress bars are common place in GUIs and are used for showing many things, from loading resources progress to experience progress towards the next level, or how much inventory space has been used. Progress bars are essentially a visual representation of two values, a maximum value and a current value. When the current value equals the maximum value, the progress bar is full. And when the current value is at zero, or the minimum value, the progress bar is empty. Ideally, we'd like to have the bar be oriented horizontally, or vertically, but could even be in-between.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's first see the <b>Progress Bar</b> class:
            <pre>
            <span class="glyphicon-remove"></span>public class ProgressBar : ScriptableObject {

                //The display name of the progress bar
                public string displayName;

                Vector2 size;

                public float minValue;
                public float maxValue;
                float currentValue;

                //Textures used to display the progress bar.
                //If you want custom textures, you can easily create a
                // new constructor that accepts alternative textures.
                //Otherwise these are generated based off the colors passed in.
                Texture2D barTexture;
                Texture2D emptyTexture;

                //Support for styles.
                public GUIStyle barStyle;

                //The rectangle that defines the bar
                Rect barRect;

                //Our rotateable itemand angle to rotate
                RotatableGUIItem barRotation;
                float barAngle;

                public Orientation orientation;

                public enum Orientation {
                    Horizontal,
                    Vertical,
                    Wonky
                }

                public ProgressBar(Vector2 size, float minValue, float maxValue,
                                    string displayName, Color emptyColor, Color barColor,
                                    Colot textColor, Orientation orientation) {
                    this.size = size;
                    this.maxValue = maxValue;
                    this.minValue = minValue;
                    this.barRect = new Rect(0, 0, size.x, size.y);
                    this.displayName = displayName;
                    this.orientation = orientation;

                    this.barStyle = new GUIStyle();
                    barStyle.normal.textColor = textColor;

                    this.emptytexture = GUIUtils.MakeTexture((int)size.x, (int)size.y, emptyColor);
                    this.barTexture = GUIUtils.MakeTexture((int)size.x, (int)size.y, barColor);

                    barRotation = new RotatableGuiItem(size);
                    barRotation.SetPivot(RotatableGuiItem.PivotPoint.Min, RotatableGuiItem.PivotPoint.Min);

                    switch(orientation) {
                        case Orientation.Horizontal:
                            barAngle = 0;
                            break;
                        case Orientation.Vertical:
                            barAngle = 90;
                            break;
                        case Orientation.Wonky:
                            barAngle = 56;
                            break;
                    }
                }

                public void SetMinMax(float min, float max) {
                    this.minValue = min;
                    this.maxValue = max;
                }

                public void Draw(Vector2 position, float currentValue) {
                    barRect.x = position.x;
                    barRect.y = position.y;

                    //Begin a group for the two box components that make up the progress bar
                    GUI.BeginGroup(new Rect(position.x, position.y, size.x, size.y));

                        //Utilize our rotation component to allow this box to be rotated as needed
                        barRotation.BeginDrawRotated(barAngle);

                        //Test to see if the mouse is hovering over this box, so we can display our alternative text
                        bool displayValueInsteadOfName = barRotation.RotatedRectContains(position, GUIUtils.GetGUIMousePosition());

                        //Draw the bar first
                        //Start with an outer box, this box represents the empty box, which is also the max size
                        // the progress bar can be
                        GUI.Box(new Rect(0, 0, size.x, size.y), emptyTexture, barStyle);
                        
                        //Next draw the inner box, this box will be drawn inside of a group that limits its size.
                        //If we were to try to just draw the box at a smaller size, Unity would "hopefully" 
                        // scale our texture smaller to fit.
                        //This would result in the texture being too short to fill the box height-wise.
                        GUI.BeginGroup(new Rect(0, 0, size.x * ((currentValue - minValue) / (maxValue - minValue)), size.y));
                            //The inner box, representing the progress bar
                            GUI.Box(new Rect(0, 0, size.x, size.y), barTexture, barStyle);
                        GUI.EndGroup();
                    GUI.EndGroup();

                    //Draw the text next
                    GUI.BeginGroup(new Rect(position.x, position.y, size.x, size.y));
                        //If we're moused over, we're going to draw the values instead of the name
                        //This will give the user (and you) the ability to see the exact value of the progress bar
                        if(displayValuesInsteadOfName) {
                            GUI.Label(new Rect(0, 0, size.x, size.y), " " + 
                                        currentValue.ToString("F1")+"/"+maxValue.ToString("F1"), barStyle);
                        } else {
                            GUI.Label(new Rect(0, 0, size.x, size.y), " " + displayName, barStyle);
                        }
                        barRotation.EndDrawRotated();
                    GUI.EndGroup();
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            So our progress bar is going to take a display name, size, our min value, max value, and current value. It's also going to generate textures for itself for the bar-empty, and bar-full. Since a progress bar is essentially two boxes, one box hold the other. The outer box is an empty box and the inner box is scalled to represent the current value relative to the size of the outer box. We're also going to make our bar rotate-able so that we can have an orientation of horizontal, vertical, even wonky.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The progress bar is going to accep parameters to set all of its values and generate textures for itself. These textures are generated at run time, using the color passed in. We fill an array with colors and create a new texture and set all of its pixels to that color, then return that texture. This will give us the texture to display on screen for the progress bar. Next, drawing the progress bar is going to take a position and its current value. We're going to utilize GUI groups to do this, first by beginning our rotation, then drawing our first outer box, then the inner box. Finally, the last group is going to draw the display label, and we're going to finish our rotation.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's look at how to implement this through our <b>Progress Bar Test Interface</b> script:
            <pre>
            <span class="glyphicon-remove"></span>[ExecuteInEditMode()]
            public class ProgressBarTestInterface : MonoBehaviour {

                public ProgressBar bar0;
                public ProgressBar bar1;
                public ProgressBar bar2;

                public float minValue = 0;
                public float maxvalue = 10;
                public float currentValue = 5;

                public Vector2 bar0Position = new Vector2(20, 100);
                public Vector2 bar1Position = new Vector2(20, 130);
                public Vector2 bar2Position = new Vector2(40, 160);

                void Start() {

                    bar0 = new ProgressBar(new Vector2(400, 20), minValue, maxValue,
                                "Test Progress Bar (Horizontal)", Color.grey, Color.green, Color.black,
                                ProgressBar.Orientation.Horizontal);

                    bar1 = new ProgressBar(new Vector2(400, 20), minValue, maxValue,
                                "Test Progress Bar (Vertical)", Color.grey, Color.magenta, Color.black,
                                ProgressBar.Orientation.Vertical);

                    bar2 = new ProgressBar(new Vector2(400, 20), minValue, maxValue,
                                "Test Progress Bar (Wonky)", Color.grey, Color.cyan, Color.black,
                                ProgressBar.Orientation.Wonky);
                }

                void Update() {
                    if(Input.GetKey(KeyCode.A)) {
                        currentValue -= 0.1f;
                        currentValue = Mathf.Max(minValue, currentValue);
                    }
                    if(Input.GetKey(KeyCode.D)) {
                        currentValue += 0.1f;
                        currentValue = Mathf.Min(maxValue, currentValue);
                    }
                }

                void OnGUI() {
                    if(bar0 != null)
                        bar0.Draw(bar0Position, currentValue);
                    if(bar1 != null)
                        bar1.Draw(bar1Position, currentValue);
                    if(bar2 != null)
                        bar2.Draw(bar2Position, currentValue);
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The first thing you should notice is that this interface uses an Execute In Edit Mode attribute. This means the interface will show up when we select the game tab, without even playing our scene. The interface is going to create three progress bars, and have the same min-max value and current value for each. We're going to just test out all of our different orientations, to see what they look like. Next, we're going to accept the A and D keys as input, to alter the current value on our progress bars. Finally, drawing all the progress bars at their respective locations. The benefit of Executing in Edit Mode is being able to position GUI elements in real time. By changing the position of the bars, we can see them update in real time.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In order to get mouse-over working for a rotated GUI elements, we'll have to take a look at our rotatable GUI item. In that class, we're checking to see if a rotated rectangle contains a position. We can't use the built in unity rectangle because that's axis aligned. So we have to generate the non-rotated rectangle, collect the points, and then rotate them all by the current Unity matrix. This will give us a rotated rectange separate into points. We can then pass this into our Convex Shap Contains method refered to in Common Scripts.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The Convex Shape Contains method takes a list of points that form a convex shape, and a point to test. Essentially, what this does is test each edge of the convex shape to ensure that the point is to the left of each edge. If the point is to the left for each edge, it's inside the convex shape. We test to see if the point is on the left by doing a cross product test to determine which side the point is on of each edge. Here we can determine if it's on the right or left, and we can make sure that the point is on the left of each edge.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we've seen how to create a progress bar GUI component. In addition to creating the progress bar, you've learned to create textures at run time and use ExecuteInEditMode to update your GUI components positions. Finally, how to calculate when a point is inside a convex polygong. Who knew there was so much involved with creating a progress bar? The information you've learned here expands the tool set available to you, for creating more complex GUI elements, with advanced behaviour.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="4">
    <h2>Tables</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we're going to create a Table GUI Component. The table GUI object is a great way to display a list of data to the user. With the table structure, we can provide a list of multiple items with details about each. Since we're creating our own table from scratch, what we put in the table is completely up to us. The table should be generic and have to be used in many situations. But allow for enough customization to allow custom code to be ran inside each cell if we wanted to. This should greatly expand the options for what we can place inside the table.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Lets first check out our <b>Table</b> class. It's a doozy:
            <pre>
            <span class="glyphicon-remove"></span>//using UnityEngine, System.Collections, System.Collections.Generic, System.Linq;

            public class Table : ScriptableObject {

                Vector2 size;
                float cellHeight;
                public GUISkin skin;
                List&lt;float&gt; columnWidths;
                ICollection&lt;string&gt; columnHeaders;
                GUIStyle styleToUse;
                List&lt;Row&gt; tableRows = new List&lt;Row&gt;();

                //A row in a table, this consists of a list of cells.
                class Row {
                    public List&lt;TableItem&gt; rowCells;
                    public Row(params TableItem[] cells) {
                        rowCells = new List&lt;TableItem&gt;(cells);
                    }
                    public Row(params string[] cells) {
                        rowCells = new List&lt;TableItem&gt;();
                        foreach(string cell in cells) {
                            rowCells.Add(new StringTableItem(cell));
                        }
                    }
                    public Row(ICollection&lt;string&gt; cells) {
                        rowCells = new List&lt;TableItem&gt;();
                        foreach(string cell in cells) {
                            rowCells.Add(new StringTableItem(cell));
                        }
                    }
                }

                //Create an abstract class for our table items, table items are the different
                // types of items we want to put in our table, for our example a string or an image
                public abstract class TableItem {
                    public delegate void OnClicked(TableItem item);
                    public event OnClicked OnClickedAction;
                    public abstract void Draw(Rect position, GUIStyle style);
                    public abstract void Update();
                    protected virtual void RaiseOnClickedEvent(TableItem item) {
                        OnClickedAction(item);
                    }
                }

                public class StringTableItem : TableItem {
                    string text;

                    public StringTableItem(string text) {
                        this.text = text;
                    }

                    public override void Draw(Rect position, GUIStyle style) {
                        GUI.Box(position, text, style);
                    }

                    public override void Update() {

                    }
                }

                public class DistanceTableItem : TableItem {
                    Transform source;
                    Transform target;
                    float distance;

                    public DistanceTableItem(Transform source, Transform target) {
                        this.source = source;
                        this.target = target;
                        this.distance = Vector3.Distance(source.position, target.position);
                    }

                    public override void Draw(Rect position, GUIStyle style) {
                        GUI.Box(position, distance.ToString(), style);
                    }

                    public override void Update() {
                        this.distance = Vector3.Distance(source.position, target.position);
                    }
                }

                public class DirectionalPointerTableItem : TableItem {
                    Texture2D texture;
                    float rotation;
                    RotatableGuiItem;
                    Rect zeroedRectangle;
                    Transform source;
                    Transform target;

                    public DirectionalPointerTableItem(Texture2D texture, Transform source, Transform target) {
                        rotatableGuiItem = new RotatableGuiItem(new Vector2(texture.width, texture.height));
                        this.texture = texture;
                        this.zeroedRectangle = new Rect(0, 0, texture.width, texture.height);
                        this.source = source;
                        this.target = target;
                        rotation = Mathf.RoundToInt(GetAnglesBetween(source, target));
                    }

                    public override void Draw(Rect position, GUIStyle style) {
                        //Draw the background first
                        GUI.Box(position, "", style);

                        //Create a centered rectangle to draw our texture and do the rotation there.
                        Rect centeredRect = new Rect((position.x + position.widht/2) - (texture.width/2),
                                                    (position.y + position.height/2) - (texture.height/2),
                                                    (texture.width, texture.height);

                        GUI.BeginGroup(centeredRect);

                            rotatableGuiItem.BeginDrawRotated(rotation);

                            GUI.Box(zeroedRetangle, texture, style);

                            rotatableGuiItem.EndDrawRotated();
                        GUI.EndGroup();
                    }

                    public override void Update() {
                        rotation = Mathf.RoundToInt(GetAngleBetween(source, target));
                    }

                    //Return the angle to rotate an object to point from t1 to t2
                    public float GetAngleBetween(Transform t1, Transform t2) {
                        Vector3 difference = t2.position - t1.position;
                        difference.Normalize();

                        return Mathf.rad2Deg * (float)Mathf.Atan2(difference.x, difference.z);
                    }
                }



                public Table(Vector2 size, float cellHeight, GUISkin sin, ICollection&lt;string&gt; columnHeaders) {
                    this.size = size;
                    this.skin = skin;
                    this.cellHeight = cellHeight;
                    this.columnHeader = columnHeaders;
                    this.columnWidths = new List&lt;float&gt;();

                    //Important to not continually search for a style that's not present
                    // it's very slow to fail.
                    if(skin.FindStyle("tablecell") != null) {
                        styleToUse = skin.GetStyle("tablecell");
                    } else {
                        styleToUse = skin.box;
                        Debug.Log("'tablecell' style not found! Using 'box' style instead");
                    }

                    float columnWidthSum = 0;
                    float[] widths = new float[columnHeaders.Count];
                    for(int header = 0; header < columnHeaders.Count; header++) {
                        float with = styleToUse.CalcSize(new GUIContent(columnHeaders.ElementAt(header))).x;
                        columnWidthSum += width;
                        widths[header] = width;
                    }
                    foreach(float width in widths) {
                        columnWidths.Add(width/columnWidthSum);
                    }
                }

                public void Addrow(params TableItem[] items) {
                    if(items.Length == columnHeaders.Count) {
                        tableRows.Add(new Row(items));
                    } else {
                        Debug.Log("Tried to add row with different number of columns than table");
                    }
                }

                public void AddRow(params string[] items) {
                    if(items.Length == columnHeaders.Count) {
                        tableRows.Add(new Row(items));
                    } else {
                        Debug.Log("Tried to add row with different number of columns than table");
                    }
                }

                public void AddRow(ICollection&lt;string&gt; items) {
                    if(items.Length == columnHeaders.Count) {
                        tableRows.Add(new Row(items));
                    } else {
                        Debug.Log("Tried to add row with different number of columns than table");
                    }
                }

                public void Draw(Vector2 position) {
                    this.DrawTable(position, this.columnHeaders, this.tableRows);
                }

                public void Update() {
                    foreach(Row td in tableRows) {
                        foreach(TableItem cell in td.rowCells) {
                            cell.Update();
                        }
                    }
                }

                void DrawTable(Vector2 position, ICollection&lt;string&gt; columnHeaders, List&lt;row&gt; tableRows) {

                    if(columnHeaders.Count > columnWidths.Count) {
                        Debug.LogError("Column headers must all have a width defined!");
                        return;
                    }

                    if(columnWidths.Sum() > 1) {
                        Debug.Log("Sum of column widths should not exceed a total of 1");
                    }

                    GUI.BeginGroup(new Rect(position.x, position.y, size.x, size.y));

                        //Draw the header row
                        //Zeros are used here because we're inside of a `BeginGroup` so all positions are relative to the group
                        // in this case, that means(0, 0) is the top left of the rectagle passed into `BeginGroup`
                        float xPos = 0;
                        float yPos = 0;

                        int columnIndex = 0;
                        foreach(string txt in columnHeaders) {
                            GUI.Label(new Rect(xPos, yPos,
                                            size.x * columnWidths[columnIndex], cellHeight),
                                            columnHeaders.ElementAt(columnIndex), styleToUse);
                            xPos += size.x * columnWidths[columnIndex];
                            columnIndex++;
                        }

                        //(carriage return) Move the pointer back to the beginning down one line (to begin on the first row)
                        xPos = 0;
                        yPos += cellHeight;

                        //Draw each row after
                        foreach(Row td in tableRows) {
                            columnIndex = 0;
                            //Draw each column in the row
                            foreach(TableItem cell in td.rowCells) {
                                cell.Draw(new Rect(xPos, yPos, size.x * columnWidths[columnIndex], cellHeight), styleToUse);
                                xPos += size.x * columnWidths[columnIndex];
                                columnIndex++;
                            }

                            //(Carriage return) Move the pointer back to the beginning down one line (to begin on the first row)
                            xPos = 0;
                            yPos += cellHeight;
                        }

                    GUI.EndGroup();
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Our table is going to contain a list of Rows, which each contain a list of TableItems. These will be the row cells. This should enable us to easily add new rows to the table, simply by creating a list of TableItems. Table Items are going to be somewhat complex. Table Items will have an even for when they're clicked, they will have their own Draw method, because they need to be responsible for drawing themselves.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Next, they'll have an update method so we can run code inside each cell like mentioned before. This abstract class will be implemented in various ways. For example, a simple String Table Item will just contain some string text and draw that text when it's requested to draw. A Distance Table Item is a little more complex. It's going to take two Transforms, and it's going to calculate the distance between the two, and displa that distance when it's requested to draw. This will utilize updates to update the distance. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Finally, an even more complex table item is the directional pointer. This item will take a texture and two Transforms, a source and a target. It will create a rotatable GUI item. Ideally, with a texture like an arrow, which will then point from the source to the target. When drawing, this will draw the rotatable GUI item to point the direction from the source to the target. In the update method, it's going to update it's rotation to ensure that it's always accurate. This method is also going to have a Get Angle Between method, that itt's use to get the angle between the two Transforms. Creating a table starts with defining the size, the cell height, the GUI scheme we want to use, and what columns will go in to it.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The table is going to attempt to use a style called table cell within the skin passed in. If the style is not found, we're going to utilize the default of the skin box. We do this because inside GUI skin, when trying to use a style that doesn't exist, it will automatically default to something else, but it's very slow. We want to use this as a shortcut so we don't have to do that every time. Next we're going to calculate the column widths, based on the size of each element in the headers. Next, adding rows has a few options, whil each time we add a row we're going to check the number of items to ensure it matches the number of headers. If it does not, we're going to display an error.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Next, our update message is going to go through and update each cell to update the code that runs inside each cell. Our drawing table method is going to begin a group for the size of the table, and for each of the columnHeaders it's going to draw a label that matches the name of that Header. Then for each row, we're going to go into each column and have each cell draw itself.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's see how we can use this with the <b>Table Test Interface</b> script:
            <pre>
            <span class="glyphicon-remove"></span>public class TableTestInterface : MonoBehaviour {

                public GUISkin tableSkin;
                Table testTable;

                public float cellHeight = 22;
                public Vector2 tablePosition = Vector2.zero;
                public Vector2 tableSize = new Vector2(500, 800);
                List&lt;List&lt;Table.TableItem&gt;&gt; tableData;
                Texture2D arrowTexture;

                void Start() {
                    arrowTexture = Resources.Load(@"Arrow") as Texture2D;
                    List&lt;string&gt; columns = new List&lt;string&gt;();
                    columns.Add("Object name");
                    columns.Add("Direction");
                    columns.Add("Distance);

                    testTable = new Table(tableSize, cellHeight, tableSkin, columns);

                    PopulateTableData();
                }

                void Update() {
                    UpdateTableData();
                }

                private void PopulateTableData() {
                    tableData = new List&lt;List&lt;Table.TableItem&gt;&gt;();
                    foreach(GameObject otherGameObject in GameObject.FindGameObjectsWithTag("TableTrack")) {

                        //We can also attach event functions to these  using each item's OnClickedAction event delegate.
                        //Create seperately and attached here if desired, something like:
                        /*
                            Table.StringTableItem stringItem = new Table.StringTableItem(otherGameObject.name);
                            stringItem.OnClickedAction += MyEventFunctionForThisItem;
                            //Where MyEventFuctionForThisItem has the signature
                            `void MyEventFunctionForThisItem(TableItem item)`
                            //Inside the TableItem, you'd simply call base.RaiseOnClickedEvent(this).
                            See the MessageWindowCode for an example using LocationMessageItem
                        */

                        testTable.AddRow(
                            new Table.StringTableItem(otherGameObject.name),
                            new Table.DirectionalPointerTableItem(arrowTexture, this.transform, otherGameObject.transform),
                            new Table.DistanceTableItem(this.transform, otherGameObject.transform)
                        );
                    }
                }

                private void UpdateTableData() {
                    //TODO: Detect if objects in the scene were added/removed and add/remove them to/from the tableData
                    //Could be as simple as, iff current object list != table data list, just call PopulateTableData again

                    //Update the table cells
                    textTable.Update();
                }

                void OnGUI() {
                    testTable.Draw(tablePosition);
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            This Test Table Interface is going to create a new Table. It's going to contain a nested list of Table Items, to define the tableData. The columns we're adding are Object name, Direction and Distance. When populating the data for this table. We're going to get all of the game objects in the scene that have the tag TableTrack. For each of these objects we're going to add a new row to our table. The row is going to consist of the object's name in a string table item, a directional pointer table item, using an aerotexture, the transform we have this interface attached to, along with the transform of the table track item. And a distance table item, that will include the same. Updating the table data we'll simply call our test table update to update all the code inside each of the table.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Scene Setup / Assets</b>
            <p><span class="glyphicon-remove"></span></p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this video we've covered how to create a table GUI component. Tables are used in a logt of places within games, from scoreboards to HUDs for nearby objects like we've created here. In a simply way to display data to the user that they're familliar with. The table we've created here is very customizable, not only with the type of data and live feedback it can provide, but with the styles we can make the table look however we like. We can extend this table to include other GUI elements, like progress bars, buttons, or text entry fields.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="5">
    <h2>Message Windows</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section we're going to cover creating a message window GUI element. The message window is used for displaying a scrolling list of messages to the user. Consider the example of an RTS game. Where the user is being updated when units are finished, they're under attack, or even auto save notifications. These messages would primarily come through as text messages with the newest at the bottom. To keep the UI cleaner, we can even make messages disappear after a while. The scroll window ensures that even if there's a lot of messages, the user will still have time to go back and review them.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We'll actually go a step further and allow these messages to be interactive as well. For example, when a user receives a message about an attack, they can click the message and their camera will snap to the attack location. Or maybe if a unit is finished building, they could click the message to see the unit and give him orders.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Scene Setup</b>
            <p><span class="glyphicon-remove"></span>TODO</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's take a look at our <b>Message Window</b> class:
            <pre>
            <span class="glyphicon-remove"></span>//using UnityEngine, System.Collections, System.Collections.Generic, System.Linq;

            public class MessageWindow : ScriptableObject {

                List&lt;MessageItem&gt; messages = new List&lt;MessageItem&gt;();
                Vector2 size;
                float scrollBarWidth;
                float messageWidth;
                float lastTotalMessageHeight;
                Vector2 scrollPosition = new Vector2(0, 0);
                public bool pauseAutoScroll = false;
                public GUISkin skin;

                bool useCustomStyle = true;

                public abstract class MessageItem {
                    public GUIStyle style;
                    public float timeRemaining;
                    public delegate void OnClicked(MessageItem item);
                    public event OnClicked OnClickedAction;

                    public MessageItem(float timeRemaining) {
                        this.timeRemaining = timeRemaining;
                    }

                    public abstract void Draw(float yPosition, float width, ref float height);

                    //Required so that classes that derive this class have access to the event OnClickedAction.
                    //Events can only be called from the class they're defined in.
                    protected virtual void RaiseOnClickedEvent(MessageItem item) {
                        OnClickedAction(item);
                    }
                }

                public class StringMessageItem : MessageItem {
                    string text;

                    public StringMessageItem(float timeToDisplay, string text) : base (timeToDisplay) {
                        this.text = text;
                    }

                    public override void Draw(float yPosition, float width, ref float height) {
                        GUIContent textContent = new GUIContent(text);
                        height = style.CalcHeight(textContent, width);
                        GUI.Label(new Rect(0, yPosition - height, width, height), textContent, style);
                    }
                }

                public class LocationMessageItem : MessageItem {

                    string text;
                    Vector3 location;

                    public LocationMessageItem(float timeToDisplay, string text, Vector3 location,
                                            OnClicked callbackOnClicked) : base (timeToDisplay) {
                        this.text = text;
                        this.location = location;
                        this.OnClickedAction += callbackOnClicked;
                    }

                    public Vector3 GetLocation() {
                        return location;
                    }

                    public override void Draw(float yPosition, float width, ref float height) {
                        GUIContent textContent = new GUIContent(text);
                        height = style.CalcHeight(textContent, width);
                        if(GUI.Button(new Rect(0, yPosition - height, width, height), textContent)) {
                            base.RaiseOnClickedEvent(this);
                            //this.timeRemaining = 0; //If we want to remove a message when it's clicked, set it's time to 0
                        }
                    }
                }

                public MessageWindow(Vector2 size, GUISkin skin) {
                    this.size = size;
                    this.skin = skin;
                    if(skin.FindStyle("messageitem") == null) {
                        Debug.Log("Skin does not contain 'messageitem' style, reverting to default.");
                        useCustomStyle = false;
                    }
                    scrollBarWidth = skin.verticalScrollbar.fixedWidth;
                    messageWidth = size.x - scrollBarWidth - 1;
                    lastTotalMessageHeight = size.y;
                }

                public MessageItem AddMessage(MessageItem item) {
                    this.messages.Add(item);
                    if(!pauseAutoScroll) {
                        scrollPosition.y = lastTotalMessageHeight;
                    }

                    if(useCustomStyle)
                        item.style = skin.GetStyle("messageitem");
                    else
                        item.style = skin.label;

                    return item;
                }

                public void AddMessage(float secondsToDisplay, string text) {
                    AddMessage(new StringMessageItem(secondsToDisplay, text));
                }

                public void CountDownTimers() {
                    List&lt;MessageItem&gt; deadMessages = new List&lt;MessageItem&gt;();
                    foreach(MessageItem messageItem in messages) {
                        messageItem.timeRemaining -= Time.deltaTime;
                        if(messageItem.timeRemaining < 0) {
                            deadMessages.Add(messageItem);
                        }
                    }
                    foreach(MessageItem deadMessage in deadMessages) {
                        messages.Remove(deadMessage);
                    }
                }

                public void Draw(Vector2 position) {
                    //Group our element to itself
                    Rect windowRect = new Rect(position.x, position.y, size.x, size.y);
                    GUI.BeginGroup(windowRect);

                        GUI.Box(new Rect(0, 0, size.x, size.y), ""); //Draw a background box

                        //Scroll view to "buffer" messages for later review
                        scrollPosition = GUI.BeginScrollView(new Rect(0, 0, size.x, size.y),
                                                            scrollPosition, new Rect(0, 0, messageWidth,
                                                            lastTotalMessageHeight));

                            //Keep track of height for future renderering
                            float yPos = lastTotalMessageHeight;
                            float totalMessageHeight = 0;
                            float lastHeight = 0;

                            //Each message draws itself, and sets a height variable so we
                            // can keep track of where we're at on screen.
                            foreach(MessageItem messageItem in Enumerable.Reverse(messages)) {
                                messageItem.Draw(yPos, messageWidth, ref lastHeight);
                                yPos -= lastHeight;
                                totalMessageHeight += lastHeight;
                            }

                            //The last total message height is used to render the scroll view,
                            // and gives us a starting point for drawing next time we render each item
                            //Use the size of the window or the size of the messages, which ever is greater
                            lastTotalMessageHeight = Mathf.Max(totalMessageHeight, size.y);

                        GUI.EndScrollView();
                    GUI.EndGroup();
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            So a message we know is going to contain a list of message items, along with other attributes for displaying the message window on screen. The message items are an abstract class that will define a style, time remaining, which is the amount of time that will be displayed on screen, as well as some on click events. The message items will be responsible for drawing themselves, so they will also include a draw method. Finally we have this raised on-click event. This is required because classes that derive this class like string message item need to have access to the event on clicked action. Events can only be called from the class they're defined in, so we're creating this method to call the on-click action when we call the raised on-click event. Various types of message items will implement this class like the string message item. This is a simple string item that will simply take a text and display that text when asked to draw.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            A more advanced implementation will be a location message item, which will take text and location, display the text when asked, and when click, will raise an event returning itself, including the location. When creating our message window, we're going to take a size and a skin. In order to avoid potential problems, we're going to search for the style we want to use, the message item style inside the skin. If that skin does not contain that style, we're going to set Use Custom Style to false, because searching for a style that doesn't exist every time makes things very slow.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            When adding a message, we're just going to add that message to our messages list. If we're not pausing our autoscroll, we're going to increase the scroll position to include the last message. Next, we have an overloaded add message, that will simply take a seconds display in text, and autocreate a new screen message item for us with those attributes. Our countdown timers are going to go through all of our messages. And decrease the time remaining by delta time. Any messages that have no time remaining will be added to the deadMessages list. Then remove after we're done iterating through the messages. This is done in two steps, because removing an item from a list we're iterating over will cause a concurrent modification error.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Drawing our message window takes a position. And uses the size to create a new rectangle. Inside that new rectangle we're going to draw a background and begin a scroll view. Inside the scroll view group we're going to draw all of our messages in reverse order. This is so that they are drawn with the newest at the bottom. Finally we're going to set our total message height in order to give us an accurate scroll bar.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's see how we can use this with the <b>Message Window Test Interface</b> script:
            <pre>
            <span class="glyphicon-remove"></span>//using UnityEngine, System.Collections, System.Text, System;

            public class MessageWindowTestInterface : MonoBehaviour {

                public GUISkin consoleSkin;
                MessageWindow consoleWindow;
                public Vector2 consoleSize = new Vector2(500, 300);
                Vector2 consolePosition = new Vector2(0, 0);
                Rect consoleRect;

                void Start() {
                    consolePosition.y = Screen.height - console.Size.y;

                    consoleRect = new Rect(consolePosition.x, consolePosition.y, consoleSize.x, consoleSize.y);
                    consoleWindow = new MessageWindow(consoleSize, consoleSkin);

                    consoleWindow.AddMessage(
                        new MessageWindow.StringMessageItem(20, 
                                "This is an extra long message. This will show the messages will" + 
                                " simply wrap around and the message below will be placed right after," +
                                " despite the wrapping"));

                    consoleWindow.AddMessage(
                        new MessageWindow.StringMessageItem(20,
                                "We can also force a line break \\n"+
                                " anywhere we \n want \n the \n breaks to be."));

                    consoleWindow.AddMessage(
                        new MessageWindow.StringMessageItem(20,
                                "Press Space to add more messages!"));
                }

                void Update() {
                    //Only count down timers when we're not moused over the console window
                    if(!GUIUtils.MouseOverRect(consoleRect)) {
                        consoleWindow.pauseAutoScroll = false;
                        consoleWindow.CountDownTimers();
                    } else {
                        consoleWindow.pauseAutoScroll = true;
                    }

                    //Mock up some trigger or events happening in game that would display messages
                    if(Input.GetKeyDown(KeyCode.Space)) {
                        consoleWindow.AddMessage(30, GUIUtils.MakeRandomString(UnityEngine.Random.Range(3, 15)));
                    }
                    if(Input.GetKeydown(KeyCode.P)) {
                        Vector3 mousePosition = Input.mousePosition;
                        mousePosition.z = 15; //depth of objects into scene
                        consoleWindow.AddMessage(
                            new MessageWindow.LocationMessageItem(30, 
                                    "Location event!",
                                    Camer.main.ScreenToWorldPoint(mousePosition),
                                    OnLocationClicked));
                    }
                }

                void OnLocationClicked(MessageWindow.MessageItem item) {
                    Vector3 messageLocation = ((MessageWindow.LocationMessageItem)item).GetLocation();
                    Camera.main.transform.position = new Vector3(messageLocation.x,
                                                                Camera.main.transform.position.y,
                                                                messageLocation.z);
                }

                void OnGUI() {
                    consoleWindow.Draw(consolePosition);
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            So with our interface, the message window test interface is going to create a new message window with this size and position. To start with, we're going to add some messages that will show some features of the string message item. For example, an extra long message that will be automatically wrapped and inserting line breaks arbitrarily. Finally a message for us telling us how to add more messages. In our update method, if the mouse is not over the rectangle, we're going to continue our auto scroll and countdown our timers.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            If the mouse over our rectangle, we're going to pause the auto scroll. This results in the user mousing over the message box to pause any timers so that messages don't disappear while they're reading them. Next, we're going to lock up some triggers that will display information in our console. Pressing the space key will add a random string. This string is randomly generated using a string builder. It is important to note that the string builder class has significantly better performance than simply appending a string with the plus equals. If making long string like this, string builder is the way to go.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Next, pressing the P key will generate a new location message. This message will pass in a location event string as well as the position of the mouse in the world. It will be handled by the OnLocationClicked listener. When the OnLocationClicked listener responds to an event, it'll translate our camera to the position above the LocationMessageItem. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we've covered creating a message window that's informative and interactive. The design allows not only for strings, but interactive buttons. And you could actually put other GUI elements in there as well. From textures, to progress bars or combo boxes. However, even though the design is very flexible, it's important to give the user what they're expecting. Many people are familiar with these types of message windows. And they're typically only expecting text and potentially clickable text. I'd advise keeping extra GUI elements to a minimum.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="6">
    <h2>GUI Items Over GameObjects</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section we're going to go over positioning GUI elements relative to game objects. This type of tagging is done throughout games. For example, during a tutorial, we might want to place a label next to the object a player is supposed to click. Or we might want to use this for indicating targets in a shooter game, or even to show a progress bar above a building to indicate how far along construction is. Additionally, you can use these in your own debugging to provide more information about the objects on-screen. Once again, we're going to aim for a system that's flexible and easy to use.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We want to be able to track game objects and draw whatever game element we like over them. In previous sections, we've covered a strategy for using abstract classes and deriving different classes to extend functionality. In this section, we're going to go over a strategy of using delegates. Using delegates has advantages, for example, not needing to modify the element class to add new functionality. However, there's also the disadvantage of moving the code for an element outside of the element. This can lead to code duplication, and means more work for other people, including future you, to add the functionality needed.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's check out our <b>Object Tagger</b> class:
            <pre>
            <span class="glyphicon-remove"></span>public class ObjectTagger {

                Dictionary&lt;GameObject, TaggedObject&gt; taggedObjects;

                public class TaggedObject {

                    public GameObject target;
                    public Vector3 offset;
                    public bool clampToScreen;
                    public float screenEdgePadding = 5;
                    GUIStyle style;
                    GUIContentGenerator contentGenerator;

                    //Now with generator including with each object
                    public TaggedObject(GameObject target, bool clampToScreen, Vector3 offset,
                                        GUIStyle style, GUIContentGenerator contentGenerator) {
                        this.target = target;
                        this.clampToScreen = clampToScreen;
                        this.offset = offset;
                        this.style = style;
                        this.contentGenerator = contentGenerator;
                    }

                    public TaggedObject(GameObject target, bool clampToScreen, Vector3 offset, GUIStyle style) {
                        this.target = target;
                        this.clampToScreen = clampToScreen;
                        this.offset = offset;
                        this.style = style;
                    }

                    //Draw method for drawing GUI content over the target object
                    public virtual Rect Draw() {
                        if(contentGenerator == null) {
                            Debug.LogError("Content generator must be defined to use this draw call");
                        }
                        GUIContent content = contentGenerator(this);

                        //Get the position of the object (plus offset) on screen and convert it to Screen coordinates
                        Vector3 position = Camer.main.WorldToScreenPoint(target.transform.position + offset);
                        position.y = Screen.height - position.y;

                        //Get the size of the GUIContent
                        Vector2 tagSize = style.CalcSize(content);

                        //Center the tag over the position
                        Vector2 tagSize = new Vector2(position.x - (tagSize.x/2), position.y - (tagSize.y/2));

                        //Properly place the rectangle for drawing on screen (or off screen?)
                        Rect contentRectangle = new Rect(newPosition.x, newPosition.y, tagSize.x, tagSize.y);
                        if(clampToScreen) {
                            contentRectangle = GUIUtils.PlaceRectangleOnScreen(contentRectangle, screenEdgePadding);
                        }

                        GUI.Box(contentRectangle, content, style);
                        return contentRectangle;
                    }

                    //Draw method for drawing GUI content over the target object
                    public virtual Rect Draw(GUIContent content) {
                        //Get the position of the object (plus offset) on screen and convert it to Screen coordinates
                        Vector3 position = Camera.main.WorldToScreenPoint(target.transform.position + offset);
                        position.y = Screen.height - position.y;

                        //Get the size of the GUIContent
                        Vector2 tagSize = style.CalcSize(content);

                        //Center the tag over the position
                        Vector2 newPosition = new Vector2(position.x - (tagSize.x/2), position.y - (tagSize.y/2));

                        //Properly place the rectangle for drawing on screen (or off screen?)
                        Rect contentRectangle = new Rect(newPosition.x, newPosition.y, tagSize.x, tagSize.y);
                        if(clampToScreen) {
                            contentRectange = GUIUtils.PlaceRectangleOnScreen(contentRectangle, screenEdgePadding);
                        }

                        GUI.Box(contentRectangle, content, style);
                        return contentRectangle;
                    }
                }

                //A more advanced Draw call for passing in whatever kind of content we want,
                // more work than using GUIContent however
                public virtual Rect Draw(GUIElementGetSize getSize, GUIElementDraw elementDrawer) {
                    //Get the position of the object (plus offset) on screen and convert it to Screen coordinates
                    Vector3 position = Camera.main.WorldToScreenPoint(target.transform.position + offset);
                    position.y = Screen.height - position.y;

                    //Get the size of the custom element
                    Vector3 tagSize = getSize(this, style);
                    //Center the tag over the position
                    Vector2 newPosition = new Vector2(position.x - (tagSize.x/2), position.y - (tagSize.y/2));

                    //Properly place the rectangle for drawing on screen (or off screen?)
                    Rect contentRectangle = new Rect(newPosition.x, newPosition.y, tagSize.x, tagSize.y);
                    if(clampToScreen) {
                        contentRectangle = GUIUtils.PlaceRectangleOnScreen(contentRectangle, screenEdgePadding);
                    }

                    //Draw the custom element
                    elementDrawer(contentRectangle, this, style);
                    return contentRectangle;
                }

                public class FancyTaggedObject : TaggedObject {
                    Vector2 lineSourcePosition;
                    Texture2D lineTexture;

                    public FancyTaggedObject(GameObject target, bool clampToScreen,
                                            Vector3 offset, GUIStyle style, Vector2 source,
                                            Texture2D lineTexture) : base(
                                                target, clampToScreen, offset, style) {
                        this.lineSourcePosition = source;
                        this.lineTexture = lineTexture;
                    }

                    public override Rect Draw(GUIContent content) {
                        Rect labelRectange = base.Draw(Content);

                        Vector2 nearestCorner = GUIUtils.NearestPointOnPerimeter(labelRectangle, lineSourcePosition);

                        GUIUtils.DrawLine(lineSourcePosition, nearestCorner, Color.black, 3, lineTexture);

                        return labelRectangle;
                    }
                }

                public ObjectTagger() {
                    taggedObjects = new Dictionary&lt;GameObject, TaggedObject&gt;();
                }

                public TaggedObject Add(GameObject objectToTag, GUIStyle style, Vector3 offset) {
                    return Add(objectToTag, style, offset, true, 5f, null);
                }

                //Now with generator included with each object
                public TaggedObject Add(GameObject objectToTag, GUIStyle style, Vector3 offset,
                                            GUIContentGenerator generator) {
                    return Add(objectToTag, style, offset, true, 5f, generator);
                }

                //Now with generator included with each object
                public TaggedObject Add(GameObject objectToTag, GUIStyle style, Vector3 offset,
                                bool clampToScreen, float screenEdgePadding, GUICOntentGenerator generator) {
                    TaggedObject newTaggedObject = new TaggedObject(objectToTag, clampToScreen, offset, style, generator);
                    taggedObjects.Add(objectToTag, newTaggedObject);
                    return newTaggedObject;
                }

                public TaggedObject AddFancy(GameObject objectToTag, GUIStyle style, Vector2, source, Vector3 offset) {
                    return AddFancy(objectToTag, style, source, null, offset, true, 5f);
                }

                public TaggedObject AddFancy(GameObject objectToTag, GUIStyle style, Vector2 source,
                                    Texture2D lineTexture, Vector3 offset, bool clampToScreen,
                                    float screenEdgePadding) {
                    FancyTaggedObject newTaggedObject = new TaggedObject(
                            objectToTag, clampToScreen, offset, style, source, lineTexture);
                    taggedObject.Add(objectToTag, newTaggedObject);
                    return newTaggedObject;
                }

                public void Remove(GameObject objectToRemove) {
                    if(taggedObjects.ContainsKey(objectToRemove))
                        taggedObjects.Remove(objectToRemove);
                }

                //Simple GUIContent generator. To be run on each tagged object to out GUIContent
                public delegate GUIContent GUIContentGenerator(TaggedObject taggedObject);

                //Simple GUIContent drawer
                public void Draw(GUIContentGenerator contentGenerator) {
                    foreach(TaggedObject taggedObject in taggedObject.Values) {
                        GUIContent content = contentGenerator(taggedObject);
                        taggedObject.Draw(content);
                    }
                }

                //Simple GUIContent drawer
                public void Draw() {
                    foreach(TaggedObject taggedObject in taggedObjects.Values) {
                        //Ensure the gameobject hasn't been removed from the world.
                        //We should remove tagging if we're removing an object
                        if(taggedObject.target != null)
                            taggedObject.Draw();
                    }
                }

                //Custom drawer for each object. Paired with the GetSize, this can be passed in to draw whatever we like
                public delegate void GUIElementDraw(Rect contentRectangle, TaggedObject taggedObject, GUIStyle style);

                //Gets the size of the custom object before drawing
                public delegate Vector2 GUIElementGetSize(TaggedObject taggedObject, GUIStyle style);

                public void Draw(GUIElementGetSize getSize, GUIElementDraw elementDrawer) {
                    foreach(TaggedObject taggedObject in taggedObjects.Values) {
                        taggedObject.Draw(getSize, elementDrawer);
                    }
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's now see how we can use it using a <b>Taggin Interface</b> script:
            <pre>
            <span class="glyphicon-remove"></span>public class Tagging Interface : MonoBehaviour {
                ObjectTagger tagger;
                public GUISkin interfaceSkin;

                void Start() {
                    tagger = new ObjectTagger();
                    if(interfaceSkin == null)
                        interfaceSkin = new GUISkin();
                }

                public void TagObject(GameObject gameObject, ObjectTagger.GUIContentGenerator contentGenerator,
                                    Vector3 offset) {
                    tagger.Add(gameObject, interfaceSkin.box, offset, contentGenerator);
                }

                public void RemoveTag(GameObject gameObject) {
                    tagger.Remove(gameObject);
                }

                void OnGUI() {
                    tagger.Draw();
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Our Object Tagger is going to maintain a dictionary of game objects and their Tagged Object class. The Tagged Object is going to contain a Game Object target and an offset. The offset vector in an offset into the 3D world for where we want to place our label. We can use this, for example, to place labels above an object or next to it, instead of directly over it. Clamp To Screen, when true, will keep the label on the screen at all times even when the object is not. This is useful for finding objects outside the screen and knowing which way to turn the camera to look at them. The screen edge Padding is how near the edge we want the label to go.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Finally we have the GUI Content Generator. This is a delegate class that will be called to generate the GUI content that will be rendered into the label over the tagged object. This content generator is going to be used in the Draw call. It generates a GUI Content. Next, the Draw call finds a position in the 3D world, and converts that to a screen position. We then determine the size of the rectangle we need to draw based on the GUIContent generated.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We then use GUI Box to draw a rectangle on screen at the location of the object using the content generated from our Content Generator. We have other Draw calls that allow us to pass in GUI Content directly, bypassing the need for a Content Generator. Finally we have a Draw call that takes two delegates, a GUI Element Get Size and a GUI Element Draw. These two delegates will determine the size we need to draw and then using a Element Drawer, to draw a rectangle at the position of the object. This allows us to bypass the GUI Box and use whatever kind of element we want above the object.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We also have a Fancy Tagged Object. The primary difference with this tag type, is it draws a 2D line from the tagger to the TaggedObject. This would be useful if you wanted to mouse over an item in a table, and have a line drawn from that item to the game object in world. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's take a look at the <b>Object Tagger Test Interface</b> script:
            <pre>
            <span class="glyphicon-remove"></span>public class ObjectTaggerTestInterface : MonoBehaviour {

                ObjectTagger tagger;
                public GUISkin taggerSkin;
                Texture2D target;

                void Start() {
                    tagger = new ObjectTagger();
                    target = Resources.Load("Target") as Texture2D;
                    SimpleAdd(Vector3.forward);
                    
                    //SimpleAdd(Vector3.zero);
                    //FancyAdd();
                }

                void SimpleAdd(Vector3 offset) {
                    //Add all the GameObjects with the tag "Tagged" to the tagger list
                    foreach(GameObject gameObject in GameObject.FindGameObjectWithTag("Tagged")) {
                        tagger.Add(gameObject, taggerSkin.box, offset);
                    }
                }

                void FancyAdd() {
                    //Get the on-screen position of ourself, to pass as the source point for drawing a line
                    // from us to the target
                    Vector3 thisScreenPosition = Camera.main.WorldToScreenPoint(this.transform.position);
                    thisScreenPosition.y = Screen.height - this.ScreenPosition.y;

                    //Add all the GameObjects with the tag "Tagged" to the tagger list
                    foreach(GameObject gameObject in GameObject.FindGameObjectsWithTag("Tagged")) {
                        tagger.AddFancy(gameObject, taggerSkin.box, new Vector2(thisScreenPosition.x,
                                                                        thisScreenPosition.y), Vector3.zero);
                    }
                }

                //Example GUIContentGenerator, outputting the name of the object
                GUIContent GenerateName(ObjectTagger.TaggedObject taggedObject) {
                    return new GUIContent(taggedObject.target.name);
                }

                //Example GUIContentGenerator, outputting the name and position of the object
                GUIContent GenerateSimpleInfo(ObjectTagger.TaggedObject taggedObject) {
                    return new GUIContent(taggedObject.target.name + "\n" + 
                                        taggedObject.target.transform.position);
                }

                //Example GUIContentGenerator, creating a target texture
                GUIContent GenerateTarget(ObjectTagger.TaggedObject taggedObject) {
                    return new GUIContent(target);
                }

                //Custom drawing example of drawing an element
                void GUIElementDraw(Rect contentRectangle, ObjectTagger.TaggedObject taggedObject, GUIStyle style) {
                    GUI.Label(contentRectangle, new GUIContent(target));
                }

                //Custom drawing example of getting size
                Vector2 GUIElementGetSize(ObjectTagger.TaggedObject taggedObject, GUIStyle style) {
                    return style.CalcSize(new GUIContent(target));
                }

                void OnGUI() {
                    tagger.Draw(GenerateName);
                    //tagger.Draw(GenerateTarget);
                    //tagger.Draw(GUIElementGetSize, GUIElementDraw);
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The Object Tagger Test Interface is going to create a new Object Tagger and perform a Simple Add. The Simple Add method simply goes through all the game objects in the scene tagged with Tagged, and adds them to the gameObject tagger. Now that we have objects tagged, we're going to go to our OnGUI and call tagger.Draw() and pass in this delegate method, GenerateName. GenerateName is going to generate a new GUI Content using the taggedObject as source, and in this case it's going to take the taggedObject and produce the name. To produce a new GUIContent, which will be rendered in the label above the object.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Another GUI Content Generator we have is the Generate Simple Info. The Generate Simple Info is going to generate a name and position. Labels aren't the only thing we can generate. Here we're going to generate a target. We want to use a different Simple Add method that passes in a zero vector so that the target is directly over our object instead of above it. The target is a texture that we load from our resources directory. Any finally we have our Fancy Add. This will simply draw a line from our tagger to the tagged objects. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this section we've seen how to position GUI elements relative to game objects. this is ideal for using the GUI to indicate objects in a 3D world. This system also demonstrated the use of delegates for extending the functionality of the class instead of abstract classes to generate new functionality. Likely the ideal balance is some mixture of both. Using derived classes to provide the most common or challenging functionality, and allowing the ability to pass in delegates for performing custom actions. Remember when writing code that you might not be the only one using it. You might release it to other someday, and putting in the extra work now helps you in the future as well.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

                    <!-------------------------------------->
                </div>
            </div>
    </main>

    <!-------------------------------------------------------------------------->

    <!-- FOOTER -->
    <footer class="navbar navbar-inverse navbar-fixed-bottom">
        <nav>
            <div class="container">
                <div class="row">
                    <div class="col-md-6 col-sm-6 col-xs-12">
                        <ul>
                            <li>&copy; 2017 <a href="http://www.gabedeyo.com">Gabe Deyo</a></li>
                            <li>|</li>
                            <li><a href="mailto:gabedeyo@gmail.com?subject=Notes">gabedeyo@gmail.com</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>
    </footer>

    <!-- Latest Minified Slim JQuery -->
    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

    <script src="../js/selection.js" charset="utf-8"></script>
</body>

</html>

<!-- Section Template

<div class="jumbotron col-md-12 heliList" id="">
    <h2>XXX</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

-->
