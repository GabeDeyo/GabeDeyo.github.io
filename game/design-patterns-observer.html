<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Design Patterns - Observer</title>

    <meta name="viewport" content="width=device-width,initial-scale=1.0, shrink-to-fit=no" />

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/page.css">
</head>

<body>

    <!-- Top Navigation -->
    <header>
        <nav class="navbar navbar-inverse">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapsemenu" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a href="../index.html" class="navbar-brand">Personal Notes</a>
                </div>

                <div class="collapse navbar-collapse" id="collapsemenu">
                    <ul class="nav navbar-nav">

                        <!-- GAME DEVELOMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Game Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- CONCEPTS -->
                                <li><a href="concepts.html">Concepts <span class="glyphicon glyphicon-chevron-right"></span></a></li>

                                <!-- ENGINE -->
                                <li><a href="engine.html">Engine <span class="glyphicon glyphicon-chevron-right"></span></a></li>

                                <!-- IMPLEMENTATIONS -->
                                <li><a href="implementations.html">Implementations <span class="glyphicon glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- GABE DEVELOPMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Gabe Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- FITNESS PAGE -->
                                <li><a href="../gabe/fitness.html">Fitness <span class="glyphicon glyphicon-chevron-right"></span></a></li>

                                <!-- STYLE & GROOMING PAGE -->
                                <li><a href="../gabe/style.html">Style <span class="glyphicon glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                    </ul>
                </div>

            </div>
        </nav>
    </header>


    <!-------------------------------------------------------------------------->

    <!-- MAIN -->
    <main>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h1 class="text-center" style="text-decoration: underline;" id="title">Design Patterns - Observer</h1>
                    <!------------------------------------------------->

                    <aside>
                        <button type="button" class="btn btn-default pull-right" name="button" id="selectAll">Select All</button>
                        <button type="button" class="btn btn-default pull-right" name="button" id="clearAll">Clear All</button>
                    </aside>

                    <div class="jumbotron col-md-12 heliList">
                        <h2>Index</h2>
                        <ul>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display: none;"></span>
                                <a href="#observer">Observer</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display: none;"></span>
                                <a href="#achievement">Achievement Unlocked</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display: none;"></span>
                                <a href="#how-it-works">How It Works</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display: none;"></span>
                                <a href="#too-slow">It's Too Slow?</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display: none;"></span>
                                <a href="#dynamic-allocation">It Does Too Much Dynamic Allocation?</a>
                                </p>
                            </li>
                        </ul>
                    </div>

                    <div class="jumbotron col-md-12 heliList" id="observer">
                        <h2>Observer</h2>
                        <ul>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                One of the most popular and utelized computer architectures is the Model-View-Controller
                                architecture, and underlying that is the Observer pattern. It's so important that Java
                                built it into it's core library and C# has it available right in the language (event).
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                The Observer Pattern is the most widely used pattern availble, but the game development
                                world can be strangely sheltered at times, so maybe this seems new. We'll start off
                                with an example to get familiarized.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                This is a long and important one, so strap in!
                            </p></li>
                        </ul>
                        <a href="#title"><span class="glyphicon glyphicon-menu-up pull-right"></span></a>
                    </div>

                    <div class="jumbotron col-md-12 heliList" id="achievement">
                        <h2>Achievement Unlocked</h2>
                        <ul>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                Let's add an achievement syste to a game. It features many badges players can unlock
                                by completing various milestones. This is tricky to implement cleanly because we
                                have such a wide range of achievements that are unlocked by different behaviors. If
                                we're not careful, our achievement code could become entangled with everything.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                What we need here is our code to be concerned with one facet of the game nicely
                                lumped in one place. The challenge here is that achievements are triggered by
                                many aspects of gameplay. How can that work without coupling the achievement code
                                to all of them?
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                Enter the <b>Observer Pattern</b>. It lets one piece of code announce that something interesting
                                happened without actually caring who receives the notification.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                Example. We've got a block of physics code that handles gravity and tracks which
                                bodies are relaxing on nice flat surfaces and which are plummeting toward sure
                                demise. To implement a "Fall off a Bridge" badge, we could just jam the achievement
                                code right here, but that's messy, instead, we should do this:
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                We could just jam the achievement code right here, but that's messy, instead, we should do this: <br>
                                <code>void Physics::updateEntity(Entity&amp; entity){
                                    <br>&nbsp; bool wasOnSurface = entity.isOnSurface();
                                    <br>&nbsp; entity.accelerate(GRAVITY);
                                    <br>&nbsp; entity.update();
                                    <br>&nbsp; if(wasOnSurface &amp;&amp; !entity.isOnSurface()){
                                        <br>&nbsp; &nbsp; notify(entity, EVENT_START_FALL);
                                    <br>&nbsp; }
                                <br>}</code>
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                This code essentially says, "I don't know who's listening, but this thing just fell,
                                do what you need to."
                                <br>The achievement system registers itself so that whenever the physics code sends
                                a notification, the achievement system receives it. It can then check to see if
                                the falling body in this case is our achievement hero, and if his prior perch happened
                                to be a bridge. If so, it unlocks the proper achievement, plus it does all of this with
                                no involvement from the physics code.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                In face, we can change the set of achievements or tear out the entire achievement
                                system without touching a line of the physics engine. It will still send out its notifications,
                                oblivious to the fact that nothing is receiving them anymore.
                            </p></li>
                        </ul>
                        <a href="#title"><span class="glyphicon glyphicon-menu-up pull-right"></span></a>
                    </div>

                    <div class="jumbotron col-md-12 heliList" id="how-it-works">
                        <h2>How It Works</h2>
                        <ul>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                <b>The Observer</b><br>
                                We'll start with the base Observer class. <br>
                                <code>class Observer {
                                    <br>&nbsp; public virtual ~Observer() {}
                                    <br>&nbsp; public virtual void onNotify(const Entity&amp; entity, Event event) = 0;
                                <br>};</code>
                                <br>The params of onNotify() are up to you, which unfortunaly makes the Observer pattern
                                non ready-made pattern easily pasted into your current code.The typical patterns are the
                                object htat sent the notification and a generic "data" parameter you stuff other details into.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                Any concrete class that implements this becomes an observer. For now that would be our
                                achievement example.<br>
                                <code>class Achievement : public Observer {
                                    <br>&nbsp; public virtual void onNotify(const Entity&amp; entity, Event event ) {
                                        <br>&nbsp; &nbsp; switch(event) {
                                            <br>&nbsp; &nbsp; &nbsp; case EVENT_ENTITY_FELL:
                                                <br>&nbsp; &nbsp; &nbsp; &nbsp; if(entity.isHer() &amp;&amp; heroIsOnBridge_) {
                                                    <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unlock(ACHIEVEMENT_FELL_OFF_BRIDGE);
                                                <br>&nbsp; &nbsp; &nbsp; &nbsp; }
                                                <br>&nbsp; &nbsp; &nbsp; &nbsp; break;
                                        <br>&nbsp; &nbsp; }
                                    <br>&nbsp; }
                                    <br>&nbsp; private void unlock(Achievement achievement) {
                                        <br>&nbsp; &nbsp; //Unlock something if not already unlocked...
                                    <br>&nbsp; }
                                    <br>&nbsp; private bool heroIsOnBridge_;
                                <br>};</code>
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                <b>The Subject</b><br>
                                The notification method is invoked by the object being observed, this object is the
                                "subject". It has two jobs. <br>
                                <b>First Job</b> - Hold the list of observers that are waiting for communication: <br>
                                <code>class Subject {
                                    <br>&nbps; private Observer* observers_[MAX_OBSERVERS];
                                    <br>&nbps; private in numObservers_;
                                <br>}</code>
                                <br>In real code, we should use a dynamically-sized collection instead of an array.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                The important part is that the subject exposes a <i>public</i> API for modifying that list: <br>
                                <code>class Subject {
                                    <br>&nbsp; public void addObserver(Observer* observer) { //Add to array }
                                    <br>&nbsp; public void removeObserver(Observer* observer) { //Remove from array }
                                    <br>&nbsp; //Other stuff...
                                <br>};</code>
                                <br>This allows outside code to control who recieves notifications. The subject communicates
                                with the observers, but it isn't <i>coupled</i> to them.
                                <br>It is also important that the subject has a list of observers instead of a single one.
                                This makes sure that observers aren't implicitly coupled to each other.
                                <br>Since we wouldn't want two or more systems interfering with each other, supporting a
                                list of observers ensures that each observer is treated independently from the others. As
                                far as they know, each is the only thing in the program with eyes on the subject.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                <b>Second Job</b> - The other job of the subject is sending notifications. <br>
                                <code>class Subject {
                                    <br>&nbsp; protected void notify(const Entity&amp; entity, Event event) {
                                        <br>&nbsp; &nbsp; for(int i = 0; i < numObservers_; i++) {
                                            <br>&nbsp; &nbsp; &nbsp; observers_[i]->onNotify(entity, event);
                                        <br>&nbsp; &nbsp; }
                                    <br>&nbsp; }
                                    <br>&nbsp; // Other Stuff
                                <br>}</code>
                                <br>Note* this code assumes observers don't modify the list in their onNotify() methods.
                                A more robust implemementation would either prevent or gracefully handle ocncurrent modification
                                like that.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                <b>Observable Physics</b><br>
                                With the observer and subject, we can hook all this into our physics engine so it can
                                send notifications and the achievement system can wire itself up to receive them. <br>
                                <code>class Physics : public Subject {
                                    <br>&nbsp; public void updateEntity(Entity&amp; entity);
                                <br>}</code>
                                <br>This lets us make notify() in Subject protected. So the derived physics engine can use
                                it to send notifications, but outside code cannot. While addObserver() and removeObserver()
                                 are public, so anything that can get to the physics system can observe it.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                Now when the physics engine does something noteworthy, it calls notify() which walks the
                                observer list and gives them a heads up.
                                <br>In real code, we use avoid using inheritance here. Instea, we'd make Physics have an
                                instance of Subject. Instead of observing the physics engine itself, the subject would be a seperate
                                "falling event" object. Observers could register themselves using something like: <code>physics.entityFell().addObserver(this);</code>
                                <br>To us this is the difference between the observer systems and event systems. With the former,
                                you observe the thing that did something interesting. With the latter, you observe an
                                object that represents the interesting thing that happens.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                So this is pretty simple. Just one class that maintains a list of pointers to instances
                                of some interface. It's hard to believe that something so straightforeward is the
                                communication backbone of countless programs and app frameworks.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                Now when the physics engine does something noteworthy, it calls notify() which walks the
                                observer list and gives them a heads up.
                                <br>In real code, we use avoid using inheritance here. Instea, we'd make Physics have an
                                instance of Subject. Instead of observing the physics engine itself, the subject would be a seperate
                                "falling event" object. Observers could register themselves using something like: <code>physics.entityFell().addObserver(this);</code>
                                <br>To us this is the difference between the observer systems and event systems. With the former,
                                you observe the thing that did something interesting. With the latter, you observe an
                                object that represents the interesting thing that happens.
                            </p></li>
                        </ul>
                        <a href="#title"><span class="glyphicon glyphicon-menu-up pull-right"></span></a>
                    </div>

                    <div class="jumbotron col-md-12 heliList" id="too-slow">
                        <h2>It's Too Slow?</h2>
                        <ul>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                The Observer Pattern gets a bad rap here, mostly because it's associated with
                                concepts such as "events", "messages", and even "data binding". These systems are
                                known to be slow(often deliberately). They involve things like queueing or doing dynamic
                                allocation for each notificiation.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                But we've seen how it works. Sending a notification is simply walking a list and calling
                                some virtual methods. Granted, it's a bit slower than a statically dispatched call, but
                                this cost is negligible.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                <b>Too Fast?</b><br>
                                It is important to note that the Observer pattern is synchronous. The subject invokes
                                its observers directly, which means it doesn't resume its own work until all of the
                                observers directly, which means it doesn't resume its own work until all of the
                                observers have returned from their notification methods. A slow observer can block
                                a subject.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                This isn't that bad, but just needs to be something you're aware of. If you're responding
                                to an event asynchronously, you need to finish and return control as quickly as possible
                                so that the event doesn't lock up. When you have slow work to do, push it onto another
                                thread or a work queue.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                You do need to be careful mixing observers with threading and explicit locks though.
                                If an observer tries to grab a lock that the subject has, you can deadlock the game.
                                In a highly threaded engine, you may be better off with asynchronous communication using
                                an Event Queue.
                            </p></li>
                        </ul>
                        <a href="#title"><span class="glyphicon glyphicon-menu-up pull-right"></span></a>
                    </div>

                    <div class="jumbotron col-md-12 heliList" id="dynamic-allocation">
                        <h2>It Does Too Much Dynamic Allocation?</h2>
                        <ul>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                Many programmer have moved to garbage collected languages, and dynamic allocation
                                isn't the hazard it used to be. However when it comes to performance-critical software,
                                like games, memory allocation still matters. Dynamic allocation takes time, as does
                                reclaiming memory, even if it happens automatically.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                In real implementations, the observer list is almost always a dynamically allocated
                                collection that grows and shrinks as observers are added and removed. That memory churn
                                spooks programmers.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                We need to notice that it only allocates memory when observers are being wired up.
                                Sending a notification requires no memory allocation whatsoever -  it's just a method
                                call. If you hook up your observers at the start of the game and don't mess with them
                                much, the amount of allocation is minimal.
                                <br>But worst case, we can go through a way to implement adding and removing observers
                                without dynamic allocation at all.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                <b>Linked Observers</b><br>
                                So far, Subject owns a list of pointers to each Observer watching it. The Observer class
                                itself has no reference to this list. It's just a pure virtual interface. Interfaces are preffered
                                over concrete, stateful classes, so that's generally a good thing.
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                If we're willing, we could put a bit of state in Observer, we can solve our allocation problems
                                by threading the subject's list through the observers themselves. Instead of the subject having
                                a separate collection of pointers, the observer objects become nodes in a linked list:
                                <br>Subject/Head_ -> Observer/Next_ -> Observer/Next_
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                To implememnt this, first we'll get rid of the array in Subject and replace it with a
                                pointer to the head of the list of observers: <br>
                                <code>class Subject {
                                    <br>&nbsp; Subject() : head_(NULL) {}
                                    <br>&nbsp; //Methods
                                    <br>&nbsp; private Observer* head_;
                                <br>};</code>
                            </p></li>
                            <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
                                Then we'll extend Observer with a pointer to the next observer in the list: <br>
                                <code>class Observer {
                                    <br>&nbsp; friend class Subject;
                                    <br>&nbsp; public Observer() : next_(NULL) {}
                                    <br>&nbsp; //Other stuff
                                    <br>&nbsp; private Observer* next_;
                                <br>};</code>
                            </p></li>
                        </ul>
                        <a href="#title"><span class="glyphicon glyphicon-menu-up pull-right"></span></a>
                    </div>

                    <!-------------------------------------->
                </div>
            </div>
    </main>

    <!-------------------------------------------------------------------------->


    <!-- FOOTER -->
    <footer class="navbar navbar-inverse navbar-fixed-bottom">
        <nav>
            <div class="container">
                <div class="row">
                    <div class="col-md-6 col-sm-6 col-xs-12">
                        <ul>
                            <li>&copy; 2017 <a href="http://www.gabedeyo.com">Gabe Deyo</a></li>
                            <li>|</li>
                            <li><a href="mailto:gabedeyo@gmail.com?subject=Notes">gabedeyo@gmail.com</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>
    </footer>

    <!-- Latest Minified Slim JQuery -->
    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

    <script src="../js/selection.js" charset="utf-8"></script>
</body>

</html>

<!-- Section Template

<div class="jumbotron col-md-12 heliList" id="">
    <h2>XXX</h2>
    <ul>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            XXX
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon glyphicon-menu-up pull-right"></span></a>
</div>

    Code Template

<div class="jumbotron col-md-12 heliList" id="">
    <h2>Code</h2>
    <ul>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            <code>public bool coding = true;
            <br>private Rigidbody2D rb;</code>
        </p></li>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            <code>void Start(){
                <br>&nbsp; console.log('Start Function');
            <br>}</code>
        </p></li>
        <li><p><span class="glyphicon glyphicon-remove pull-right" style="display:none;"></span>
            <code>void Update(){
                <br>&nbsp; console.log('Don't log here, ya dingus');
            <br>}</code>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon glyphicon-menu-up pull-right"></span></a>
</div>

-->
