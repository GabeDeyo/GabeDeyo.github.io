<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Design Patterns - Event Queue</title>

    <meta name="viewport" content="width=device-width,initial-scale=1.0, shrink-to-fit=no" />

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/page.css">
</head>

<body>

    <!-- Top Navigation -->
    <header>
        <nav class="navbar navbar-inverse">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapsemenu" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a href="../index.html" class="navbar-brand">Personal Notes</a>
                </div>

                <div class="collapse navbar-collapse" id="collapsemenu">
                    <ul class="nav navbar-nav">

                        <!-- GAME DEVELOMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Game Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- CONCEPTS -->
                                <li><a href="concepts.html">Concepts <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ENGINE -->
                                <li><a href="engine.html">Engine <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- IMPLEMENTATIONS -->
                                <li><a href="implementations.html">Implementations <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- GABE DEVELOPMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Gabe Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- FITNESS PAGE -->
                                <li><a href="../gabe/fitness.html">Fitness <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- STYLE & GROOMING PAGE -->
                                <li><a href="../gabe/style.html">Style <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- FINANCE PAGE -->
                                <li><a href="../gabe/finance.html">Finance <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PHILOSOPHY PAGE -->
                                <li><a href="../gabe/philosophy.html">Philosophy <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                    </ul>
                </div>

            </div>
        </nav>
    </header>

    <!-------------------------------------------------------------------------->

    <!-- MAIN -->
    <main>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h1 id="title">Design Patterns - Event Queue</h1>

                    <aside>
                        <button type="button" class="btn btn-default" name="button" id="selectAll">Select All</button>
                        <button type="button" class="btn btn-default" name="button" id="clearAll">Clear All</button>
                    </aside>

                    <div class="jumbotron heliList">
                        <h2>Index</h2>
                        <ul>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#intent">Intent</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#motivation">Motivation</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#event-queue">Event Queue</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#when-to-use">When to Use It</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#keep-in-mind">Keep In Mind</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#sample-code">Sample Code</a>
                                </p>
                            </li>
                        </ul>
                    </div>

<div class="jumbotron col-md-12 heliList" id="intent">
    <h2>Intent</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            <i>Decouple when a message or event is sent from when it is processed.</i>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="motivation">
    <h2>Motivation</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Unless you've been under a rock for the past few years, you've probably already heard of an "event queue". If not, maybe "message queue", or "event loop", or "message pump" rings a bell. To refresh your memory, let's walk through a couple of common manifestations of the pattern.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>GUI Event Loops</h3>
            <p>If you've ever done any user interface programming, then you're well acquanted with <i>events</i>. Every time the user interacts with your program - clicks a button, pulls down a menu, or presses a key - the operating system generates an event. It throws this object at your app, and your job is to grab it and hook it up to some interesting behavior.</p>
            <p><span class="glyphicon-remove"></span>In order to receive these missives, somewhere deep in the bowels of your code is an event loop. It looks roughly like this:</p>
            <pre>
            <span class="glyphicon-remove"></span>while(running){
                Event event = getNextEvent();
                // Handle event...
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The call to getNextEvent() pulls a bit of unprocessed user input inot your app. You route it to an event handler and, like magic, your application comes to life. The interesting part is that the application <i>pulls</i> in the eevent when <i>it</i> wants it. The operating system doesn't just immediately jump to some code in your pap when the user pokes a peripheral.
            <p><span class="glyphicon-remove"></span>That means when user input comes in, it needs to go somewhere so that the operating system doesn't lose it between when the device driver reported the input and when your app gets around to calling getNextEvent(). That "somewhere" is a <i>queue</i>. When user input comes in, the OS adds it to a queue of unprocessed events. When you call getNextEvent(), that pulls the oldest event off the queue and hands it to your application.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Central Event Bus</h3>
            <p><span class="glyphicon-remove"></span>Most games aren't event-driven like this, but it is common for a game to have its own event queue as the backbone of its nervous system. You'll often hear "central", "global", or "main" used to describe it. It's used for high level communication between game systems that want to stay decoupled.</p>
            <p><span class="glyphicon-remove"></span>Say your game has a tutorial system to display help boxes after specific in-game events. For example, the first time the player vanquishes a foul beast, you want to show a little balloon that says, "Press X to grab the loot!"</p>
            <p><span class="glyphicon-remove"></span>Your gameplay and combat code are likely complex enough as it is. The last thing you want to do is stuff a bunch of checks for triggering tutorials in there. Instead, you could have a central event queue. Any game system can send to it, so the combat code can add an "enemy died" event every time you slay a foe.</p>
            <p><span class="glyphicon-remove"></span>Likewise, any game system can <i>receive</i> events from the queue. The tutorial engine registers itself with the queue and indicates it wants to receive "enemy dies" events. This way, knowledge of an enemy dying makes its way from the combat system over to the tutorial engine without the two being directly aware of each other.</p>
            <p><span class="glyphicon-remove"></span>I thought about using this as the example for the rest of the chapter, but I'm not generally a fan of big global systems. Event queues don't have to be for communicating across the entire game engine. They can be just as useful within a single class or domain.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Say What?</h3>
            <p><span class="glyphicon-remove"></span>So, instead, let's add sound to our game. Humans are mainly visual animals, but hearing is deeply connected to our emotions and our sense of physical space. The right simulated echo can make a black screen feel like an enormous cavern, and a well-timed violin adagio can make your heartstrings hum in sympathetic resonance.</p>
            <p><span class="glyphicon-remove"></span>To ger our game wound for sound, we'll start with the simplest possible approach and see how it goes. We'll add a little "audio engine" that has an API for playing a sound given an identifier and a volume:</p>
            <pre>
            <span class="glyphicon-remove"></span>class Audio {
                public static void playSound(SoundId id, int volume);
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            It's responsible for loading the appropriate sound resource, finding an available channel to play it on, and starting it up. This chapter isnt' about some platform's real audio API, so I'll conjure one up that we can presume is implemented elsewhere. Using it, we write our method like so:
            <pre>
            <span class="glyphicon-remove"></span>void Audio::playSound(SoundId id, int volume) {
                ResourceId resource = loadSound(id);
                int channel = findOpenChannel();
                if(channel == -1) return;
                startSound(resource, channel, volume);
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We check that in, create a few sound files, and start sprinkling playSound() calls through our codebase like some magical audio fairy. For example, in our UI code, we play a little bloop when the selected menu item changes:
            <pre>
            <span class="glyphicon-remove"></span>class Menu {
                public void onSelect(int index) {
                    Audio::playSound(SOUND_BLOOP, VOL_MAX);
                    //Other stuff...
                }
            }
            </pre>
            <p><span class="glyphicon-remove"></span>After doing this, we notice that sometimes when you switch menu items, the whole screen freezes for a few frames. We've hit our first issue.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Problem 1</h3>
            <p><span class="glyphicon-remove"></span><b>The APi blocks the caller until the audio engine has completely processed the request.</b> Our playSound() method is synchronous - it doesn't return back to the caller until bloops are coming out of the speakers. If a sound file has to be loaded from disc first, that may take a while. In the meantime, the rest of the game is frozen.</p>
            <p><span class="glyphicon-remove"></span>Ignoring that for now, we move on. In the AI code, we add a call to let out a wail of anguish when an enemy takes damage form the player. Nothing warms a gamer's heart like inflicting simulated pain on a virtual living being.</p>
            <p><span class="glyphicon-remove"></span>It works, but sometimes when the hero does a mighty attack, it hits two enemies in the exact same frame. That causes the game to play the wail sound twice simultaneously. If you know anything about audio, you know mixing multiple sounds together sums their waveforms. When those are the <i>same</i> waveform, it's the same as <i>one</i> sound played <i>twice as loud</i>. Jarringly loud.</p>
            <p><span class="glyphicon-remove"></span>We have a related problem in boxx fights when piles of minions are running around causing mayhem. The hardware can only play so many sounds at one time. When we go over that limit, sound gets ignored or cut off.</p>
            <p><span class="glyphicon-remove"></span>To handle these issues, we need to look at the entire set of sound calls to aggregate and prioritize them. Unfortunately, our audio API handles each playSound() call independently. It sees requests through a pinhole, one at a time.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Problem 2</h3>
            <p><span class="glyphicon-remove"></span><b>Requests cannot be processed in aggregate.</b> These problems seem like mere annoyances compared to the next issue that falls in our lap. by now, we've strewn playSound() calls throughout the codebase in lots of different game systems. But our game engine is running on modern multi-core hardware. To take advantage of those cores, we distribute those systems on different threads - rendering on one, AI on another, etc.</p>
            <p><span class="glyphicon-remove"></span>Since API is synchronous, it runs on the <i>caller's</i> thread. When we call it from different game systems, we're hitting our API concurrently from multiple threads. Look at that sample code. See any thread synchronization? Me neither.</p>
            <p><span class="glyphicon-remove"></span>This is particularly egregious because we intend to have a <i>separate</i> thread for audio. It's just sitting there totally idle while these other threads are busy stepping all over each other and breaking things.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Problem 3</h3>
            <p><span class="glyphicon-remove"></span><b>Requests are processed on the wrong thread.</b> The common theme to these problems is that the audio engine interprets a call to playSound() to mean, "Drop everything and play the sound right now!" <i>Immediacy</i> is the problem. Other game systems call play at <i>their</i> convenience, but not necessarily when it's conventient for the audio engine to handle that request. To fix that, we'll decouple <i>receiving</i> a request from <i>processing</i> it.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="event-queue">
    <h2>Event Queue</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            A <b>queue</b> stores a series of <b>notifications or requests</b> in first-in, first-out order. Sending a notification <b>enqueues the request and returns.</b> The request processor then <b>processes items from the queue</b> at a later time. Requests can be <b>handled directly</b> or <b>routed to interested parties.</b> This <b>decouples the sender from the receiver</b> both <b>statically</b> and <b>in time.</b>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="when-to-use">
    <h2>When to Use It</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            If you only want to decouple <i>who</i> receives a message from its sender, patterns like Observer and command will take care of this with less complexity. You only need a queue when you want to decouple something <i>in time.</i>
            <p><span class="glyphicon-remove"></span>I think of it in terms of pushing and pulling. You have some code A that wants another chunk B to do some work. The natural way for A to initiate that is by <i>pushing</i> the request to B.</p>
            <p><span class="glyphicon-remove"></span>Meanwhile, the natural way for B to process that request is by <i>pulling</i> it in at a convenient time in its run cycle. When you have a push model on one end and a pull model on the other, you need a buffer between them. That's what a queue provides that simpler decoupling patterns don't.</p>
            <p><span class="glyphicon-remove"></span>Queues give control to the code that pulls from it - the receiver can delay processing, aggregate requests, or discard them entirely. But queues do this by taking control <i>away</i> from the sender. All the sender can do is throw a request on the queue and hope for the best. This makes queues a poor fit when the sender needs a response.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="keep-in-mind">
    <h2>Keep In Mind</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Unlike some more modest patterns in this book, event queues are complex and tend to have a wide-reaching effect on the architecture of our games. That means you'll want to think hard about how - or if - you use one.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>A Central Event Queue is a Global Variable</h3>
            <p><span class="glyphicon-remove"></span>One common use of this pattern is for a sort of Grand Central Station that all parts of the game can route messages through. It's a powerful piece of infrastructure, but <i>powerful</i> doesn't always mean <i>good</i>.</p>
            <p><span class="glyphicon-remove"></span>It took a while, but most of us learned the hard way that global variables are bad. When you have a piece of state that any part of the program can poke at, all sorts of subtle interdependencies creep in. This pattern wraps that state in a nice little protocol, but it's still a global, with all of the danger that entails.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>The State of the World can Change Under You</h3>
            <p><span class="glyphicon-remove"></span>Say some AI code posts an "entity died" event to a queue when a virtual minion shuffles off its mortal coil. That event hangs out in the queue for who knows how many frames until it eventually works its way to the front and gets processed.</p>
            <p><span class="glyphicon-remove"></span>Meanwhile, the experience system wants to track the heroin's body count and reward her for her grisly efficiency. It receives each "entity dies" event and determines the kind of entity slain and the difficulty of the kill so it can dish out an appropriate reward.</p>
            <p><span class="glyphicon-remove"></span>That requires various pieces of state in the world. We need the entity that died so we can see how tough it was. We may want to inspect its surroundings to see what other obstacles or minions were nearby. but if the event isn't received until later, that stuff may be gone. The entity may have been dealloacted, and other nearby foes may have wandered off.</p>
            <p><span class="glyphicon-remove"></span>When you receive an event, you have to be careful not to assume the <i>current</i> state of the world reflects how the world was <i>when the event was raised.</i> This means queued events tend to be more data heavy than events in synchronous systems. With the latter, the notification can say "something happened" and the receiver can look around for the details. With a queue, those ephemeral details must be captured when the event is sent so they can be used later.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>You can get Stuck in Feedback Loops</h3>
            <p><span class="glyphicon-remove"></span>All event and message systems have to worry about cycles:</p>
            <p><span class="glyphicon-remove"></span> &nbsp; 1. <b>A</b> sends an event</p>
            <p><span class="glyphicon-remove"></span> &nbsp; 2. <b>B</b> receives it and responds by sending an event.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; 3. That event happens to be one that <b>A</b> cares about, so it receives it. In response, it sends an event...</p>
            <p><span class="glyphicon-remove"></span> &nbsp; 4. Go to 2.</p>
            <p><span class="glyphicon-remove"></span>When your messaging system is <i>synchronous</i>, you find cycles quickly - they overflow the stack and crash your game. With a queue, the asynchrony unwinds the stack, so the game may keep running even though spurious events are sloshing back and forth in there. A common rule to avoid this is to avoid <i>sending</i> events from within code that's <i>handling</i> one.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="sample-code">
    <h2>Sample Code</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            We've already seen some code. It's no perfect, but it has the right basic functionality - the public API we want and the right low-level audio calls. All that's left for us to do now is  fix its problem.
            <p><span class="glyphicon-remove"></span>The first is that our API <i>blocks</i>. When a piece of code plays a sound, it can't do anything else until playSound() finishes loading the resources and actually starts making the speaker wiggle.</p>
            <p><span class="glyphicon-remove"></span>We want to defer that work until later so that playSound() can return quickly. To do that, we need to <i>reify</i> the request to play a sound. We need a little structure that stores the detail of a pending request so we can keep it around until later:</p>
            <pre>
            <span class="glyphicon-remove"></span>struct PlayMessage {
                SoundId id;
                int volume;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Next, we need to give Audio some storage space to keep track of these pending play messages. Now, your algorithms professor might tell you to use some exciting data structure here like a Fibonacci heap or a skip list, or , hell, at least a <i>linked list</i>. But in practice, the best way to store a bunch of homogeneous things is almost always a plain old array:
            <br> &nbsp; &bull; No dynamic allocation.
            <br> &nbsp; &bull; No memory overhead for bookkeeping information or pointers.
            <br> &nbsp; &bull; Cache-friendly contiguous memory usage.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            So let's do that:
            <pre>
            <span class="glyphicon-remove"></span>class Audio {
                public static void init() {
                    numPending_ = 0;
                }

                //Other stuff...

                private static const int MAX_PENDING = 16;
                private static PlayMessage pending_[MAX_PENDING];
                private static int numPending_;
            }
            </pre>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

                    <!-------------------------------------->
                </div>
            </div>
    </main>

    <!-------------------------------------------------------------------------->

    <!-- FOOTER -->
    <footer class="navbar navbar-inverse navbar-fixed-bottom">
        <nav>
            <div class="container">
                <div class="row">
                    <div class="col-md-6 col-sm-6 col-xs-12">
                        <ul>
                            <li>&copy; 2017 <a href="http://www.gabedeyo.com">Gabe Deyo</a></li>
                            <li>|</li>
                            <li><a href="mailto:gabedeyo@gmail.com?subject=Notes">gabedeyo@gmail.com</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>
    </footer>

    <!-- Latest Minified Slim JQuery -->
    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

    <script src="../js/selection.js" charset="utf-8"></script>
</body>

</html>

<!-- Section Template

<div class="jumbotron col-md-12 heliList" id="">
    <h2>XXX</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

-->
