<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Advanced Scripting - Prefabs</title>

    <meta name="viewport" content="width=device-width,initial-scale=1.0, shrink-to-fit=no" />

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="../../../css/page.css">
</head>

<body>

    <!-- Top Navigation -->
    <header>
        <nav class="navbar navbar-inverse">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapsemenu" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a href="../../../index.html" class="navbar-brand">Personal Notes</a>
                </div>

                <div class="collapse navbar-collapse" id="collapsemenu">
                    <ul class="nav navbar-nav">

                        <!-- GAME DEVELOMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Game Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- CONCEPTS -->
                                <li><a href="../../Categories/concepts.html">Concepts <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ENGINE -->
                                <li><a href="../../Categories/engine.html">Engine <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- IMPLEMENTATIONS -->
                                <li><a href="../../Categories/implementations.html">Implementations <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- PROGRAMMING -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Programming <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- LANGUAGES -->
                                <li><a href="../../../code/Categories/languages.html">Languages <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ALGORITHMS -->
                                <li><a href="../../../code/Categories/algorithms.html">Algorithms <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PROBLEMS -->
                                <li><a href="../../../code/Categories/problems.html">Problems <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- RANDOM -->
                                <li><a href="../../../code/Categories/random.html">Random <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- GABE DEVELOPMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Gabe Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- FITNESS PAGE -->
                                <li><a href="../../../gabe/Categories/fitness.html">Fitness <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- STYLE & GROOMING PAGE -->
                                <li><a href="../../../gabe/Categories/style.html">Style <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- FINANCE PAGE -->
                                <li><a href="../../../gabe/Categories/finance.html">Finance <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PHILOSOPHY PAGE -->
                                <li><a href="../../../gabe/Categories/philosophy.html">Philosophy <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                    </ul>
                </div>

            </div>
        </nav>
    </header>

    <!-------------------------------------------------------------------------->

    <!-- MAIN -->
    <main>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h1 id="title">Advanced Scripting - Prefabs</h1>

                    <aside>
                        <button type="button" class="btn btn-default" name="button" id="selectAll">Select All</button>
                        <button type="button" class="btn btn-default" name="button" id="clearAll">Clear All</button>
                    </aside>

                    <div class="jumbotron heliList">
                        <h2>Index</h2>
                        <ul>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#1">Creating a Prefab System</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#2">Advanced Prefab System</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#3">Storing &amp; Managing Prefabs</a>
                                </p>
                            </li>
                        </ul>
                    </div>

<div class="jumbotron col-md-12 heliList" id="1">
    <h2>Creating a Prefab System</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we'll be discussing how to create your own Prefab system for increased control over entity data. This will allow the end user, the gamer, to be able to create their own entities and mod your game. Unity prefabs are a very useful tool, allowing us to define complex entities, save them, and then load them as many times as we want, during the execution of the code. While it is very easy and powerful to create new prefabs in the Editor, it does restrict us to the Editor. This becomes a significant problem if, for example we wanted to allow end users to create their own entities in game.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            As modding becomes a more common and popular new feature in modern games, it's important to consider how we might enable end user content creation. You can do this with data files that define the state of entities we want to create. This is essentially how Unity creates prefabs using serilization. However, the serialized data generated by Unity Prefabs is not easily accessible to us, or the end user. In order to create our own Prefab system, we're going to need to find our own scripting language. I've created a very simple scripting language here that has a keyword, colon, and data, and in this case, the custom component takes the name of the custom component and the data that will go into the component.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Check out this data file: <b>TestEntityA.data</b>
            <pre>
            <span class="glyphicon-remove"></span>position:3,0,1

            customcomponent:AttackInfo

            453.52
            We can define whatever we want here!
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In order to create our own entities, we need to create an object, add components and then set those component values. For this, we've created the Entity Loader. This is the MonoBehavior that on start will read each file that ends with .data inside of the directory we defined. It will read all the lines of that data file into an array, get the name of the data file, and then create a new Custom Prefab storing the lines from the data file and the name of the Prefab. This will also handle adding new entities to the scene by pressing the A or B key.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            First lets check out the Entity Loader:
            <pre>
            <span class="glyphicon-remove"></span>public class EntityLoader : MonoBehavior {
                string dataFolder = @"Assets\";
                Dictionary&lt;string, CustomPrefab&gt; prefabs = new Dictionary&lt;string, CustomPrefab&gt;();

                void Start() {
                    foreach(string dataFile in Directory.GetFiles(dataFolder, "*.data", SearchOption.AllDirectories)) {
                        string[] lines = File.ReadAllLines(dataFile);
                        string name = dataFile.Substring(dataFile, LastIndexOf("\\")+1, dataFile.LstIndexOf(".") - (dataFile.LastIndexOf("\\")+1));
                        prefabs.Add(name, new CustomePrefab(name, lines));
                    }
                }

                void Update() {
                    if(Input.GetKeyDown(KeyCode.A)) {
                        prefabs["TestEntityA"].Instantiate();
                    }
                    if(Input.GetKeyDown(KeyCode.B)) {
                        prefabs["TestEntityB"].Instantiate();
                    }
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Next we'll need to take a look at the CustomPrefab class. This class will hold the data from the Prefab file as well as the name. 
            <pre>
            <span class="glyphicon-remove"></span>public class CustomPrefab {
                string name;
                string[] dataLines;
                int dataPointer = 0;

                public CustomPrefab(string name, string[] scriptLines) {
                    this.name = name;
                    this.dataLines = scriptLines;
                }

                //Create game object, then parse data file to add components and data.
                public GameObject Instantiate() {
                    //Create an empty game object to work with in this example we'll create a sphere.
                    //However, you can easily define a custom mesh of your own.
                    GameObject go = GameObject.CreatePrimitive(PrimitiveType.Sphere);
                    go.name = name;

                    while(dataPointer < dataLines.Length) {
                        if(dataLines[dataPointer].Length < 1) {
                            dataPointer++; //skip any whitespace
                            continue;
                        }

                        if(dataLines[dataPointer].StartsWith("customcomponent:")) {
                            //Separate the component name from the header
                            string componentName = dataLines[dataPointer].Substring(dataLines[dataPointer].IndexOf(":") + 1);
                            dataPointer++;
                            //Unity uses C# reflection and allows us to simply pass the string name of the script we want to add.
                            CustomComponentBase c = go.AddComponent(componentName) as CustomComponentBase;

                            //This is similar to calling go.AddComponent("ComponentA");
                            while(dataLines[dataPointer].Length < 1) {
                                dataPointer++; // clear any white space after the component token
                            }

                            if(c != null) {
                                //Special Components we want to add should implement the ComponentType class, 
                                //this way we can call our special SetData function
                                //Pass the dataPointer as a reference (ref) so that we'll continue with any modification when we get back here
                                c.SetData(dataLines, ref dataPointer);
                            } else {
                                Debug.Log("Error adding " + componentName + "! Ensure the name is typed correctly.");
                            }
                        } else if(dataLines[dataPointer].StartsWith("position:")) {
                            string vec3Position = dataLines[dataPointer].Substring(dataLines[dataPointer].IndexOf(":") + 1);
                            string[] posComponents = vec3Position.Split(',');
                            go.transform.position = new Vector3(float.Parse(posComponents[0]), float.Parse(posComponents[1]), float.Parse(posComponents[2]));
                            dataPointer++;
                            continue;
                        }
                        // else if(other keywords) {
                        //    //other processing (other mesh, mesh filter, colliders, etc.)
                        // }
                        else {
                            Debug.Log("Lines: `" + dataLines[dataPointer] + "` not recognized as valid token");
                            dataPointer++;
                            continue;
                        }
                    }
                    dataPointer = 0;
                    return go;
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            When calling instantiate we're going to create a game object, set the name, parse the file and look for keywords. And create components and set data. We're going to use a while loop to parse through our dataLines in the file. I'll explain more on that later. Here, we're skipping any white space and here we're going to check for our keyword tokens. For example, the customcomponent keyword or the Position keyword.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            A customcomponent keyword is used when we're defining our own components. And here we would define position as a Unity built in component. Or if we wanted to add other components like mesh, mesh filter, or any colliders, we would add those below here. Let's follow the execution when we come to a customcomponent. When we're reading a customcomponent, we're going to get the componentName. An attempt to add the componentName, using reflection.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The componentName in our data example is going to be, AttackInfo, which we have a class of here:
            <pre>
            <span class="glyphicon-remove"></span>public class AttackInfo : CustomComponentBase {
                public float valueX = 0;
                public string valueString = "test";

                public override void SetData(string[] lines, ref int pointer) {
                    Debug.Log("AttackInfo setting data!");
                    valueX = float.Parse(lines[pointer++]);
                    valueString = lines[pointer++];
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            That's going to be created as a CustomComponentbase, which is an abstract class:
            <pre>
            <span class="glyphicon-remove"></span>public abstract class CustomComponetBase : MonoBehavior {
                public abstract void SetData(string[] lines, ref int pointer);
            }
            </pre>
            <p><span class="glyphicon-remove"></span>We use an abstract class here, so we don't have to define each class individually. We can just use a base class. And then call this SetData method on that base class which will then in turn call the set data overriden method in each of our Custom Components. When setting the data we pass in the dataLines that represent the script file as well as the pointer to where we are in the file. This is because each component sets it's own data.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            It's going to read the file and increment the pointer. So here we're going to set our valueX and our valueString, and increment the pointer. It's passed in as a reference so that when we get back to the Custom Prefab, the dataPointer is up to date. And this is the reason we use a while loop instead of a for each, because we're incrementing the dataPointer outside of the control of the Custom Prefab. Let's follow the execution when we hit a position keyword. In this case we are going to read the value after the position. We're going to split that string into components using the String Split method.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The last pieces we'll need for our Prefab system is our Components and their Data.
            <pre>
            <span class="glyphicon-remove"></span>public class ComponentA : CustomComponentBase {
                public float valueX = 0;
                public string valueString = "test";

                public override void SetData(string[] lines, ref int pointer) {
                    Debug.Log("Component A setting data!");
                    valueX = float.Parse(lines[pointer++]);
                    valueString = lines[pointer++];
                }
            }
            </pre>
            <p><span class="glyphicon-remove"></span>And now our last entity data: TestEntityB.data:</p>
            <pre>
            <span class="glyphicon-remove"></span>position:-3,0,0

            customecomponent:AttackInfo

            55
            This is a string value for componentA
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We split on comma and then creaate a new position using those components. You can see here that we have a position of 3-0-1. That's x, y, and z. So let's see what this looks like. We hit Play. And now we can either press A or B. And that will create our Test Entities. I can see that we have an attack info component; the value of 55. And this is a string value. and then I'm testing TTA F45352, just as defined in our Script file.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In order to use this system, create an Empty "Entity Loader" object and just add the Entity Loader script.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we've covered creating your own Prefab system to allow for modification by end users. This system relies on a simple scripting language you define. Using the simple token parser, the system is able to generate some reasonably complex objects. Further extensions to the system will allow for parent-child relationships, more support for built in Unity components, and improved error handling. While the basic system can be very powerful, it's not very user-friendly in it's current state. If you plan on implementing a similar system, consider extensive documentation. Or create UI which writes scripts automatically.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="2">
    <h2>Advanced Prefab System</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In the last section, we created a basic prefab system for defining our own prefabs. In this section we're going to go over a more advanced system. This system will utilize reflection heavily. Reflection is essentially a method for allowing a program to access information about itself. This means we can access method names, fields and properties. For this example, we're most interested in fields, since that's what we'll be defining in our scripts. Additionally, the prefab system has a more sophisticated parser called a Lexer.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            One of the first items we'll need is our <b>AdvComponent</b> script:
            <pre>
            <span class="glyphicon-remove"></span>//using UnityEngine, System.Collections, System.Collections.Generic, System, System.Reflection, System.Text;

            public class AdvComponent : MonoBehaviour {

                public bool SetData(ref Lexer lex) {
                    bool returnValue = true;
                    List&lt;string&gt; valueSet = new List&lt;string&gt;(); // an easy way to keep track of the values we've already set

                    while(!lex.Match("}") &amp;&amp; lex.GetTokenType() != Lexer.TokenType.EndOfInput) {
                        //for each token until the end of the component definition or the end of input
                        FieldInfo fieldInfo = this.GetType().GetField(lex.GetToken());
                        if(fieldInfo != null) {
                            System.Object value = lex.GetValue();

                            //Handle our special cases. These are types not defined in Unity, but defined in our scripting language
                            // for example, here we're going to select values from the range type values defined in our scripts.
                            Lexer.FinializeSpecialTypes(ref value, lex.GetTokenType());

                            if(fieldInfo.FieldType.IsEnum) {
                                fieldInfo.SetValue(this, Enum.Parse(fieldInfo.FieldType, value.ToString()));
                            } else {
                                fieldInfo.SetValue(this, value);
                            }

                            valueSet.Add(fieldInfo.Name);
                        } else { //if the current token hasn't been set, it's something we don't know what to do with
                            Debug.Log("Warning: Unknown property: `" + lex.GetToken() + "` on component `" + this.GetType().Name + "`");
                            lex.GetValue(); //get the value to clear it from the queue
                        }

                        lex.NextToken(); //get the next token to prepare for the next iteration
                    }
                    //now that we've parsed all the tokens, check over our fields to make sure we didn't miss any that are required to be set
                    foreach(FieldInfo fieldInfo in this.GetType().GetFields(BindingFlags.Public |
                                                                            BindingFlags.Instance | 
                                                                            BindingFlags.DeclaredOnly)) {
                        if(RequiresDefinition(fieldInfo) &amp;&amp; !valueSet.Contains(fieldInfo.Name)) {
                            Debug.Log("Error: The property: `" + fieldInfo.Name + "`, is set `RequiresDefinition` and is not defined!");
                            returnValue = false;
                        }
                    }

                    return returnValue;
                }

                public class PrefabAttribute : Attribute {
                    public bool RequiresDefinition {get; set;}
                }

                public static bool RequiresDefinition(FieldInfo fieldInfo) {
                    foreach(System.Object customAttribute in fieldInfo.GetCustomAttributes(true)) {
                        if(customAttribute.GetType() == typeof(PrefabAttribute)) {
                            return((PrefabAttribute)customAttribute).RequiresDefinition;   
                        }
                    }
                    return false;
                }

                //Added for Custom Editor
                public string GenerateComponentScript() {
                    StringBuilder generatedScript = new StringBuilder();
                    generatedScript.AppendLine("[" + this.GetType().Name + "]{");

                    foreach(FieldInfo fieldInfo in this.GetType().GetFields(BindingFlags.Public |
                                                                            BindingFlags.Instance |
                                                                            BindingFlags.DeclaredOnly)) {
                        generatedScript.AppendLine(fieldInfo.Name + "=" + GetPropertyString(fieldInfo));
                    }
                    generatedScript.AppendLine("}");
                    return generatedScript.ToString();
                }

                //Added for Custom Editor
                public string GetPropertyString(FieldInfo fieldInfo) {
                    if(fieldInfo.FieldType == typeof(string)) {
                        return "\"" + fieldInfo.GetValue(this).ToString() + "\"";
                    } else if(fieldInfo.FieldType == typeof(Vector3)) {
                        return fieldInfo.GetValue(this).ToString().Replace("(","").Replace(")","");
                    } else {
                        return fieldInfo.GetValue(this).ToString();
                    }
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The Lexer performs lexical analysis similar to how compilers read code. Finally, we'll use field attributes to find which fields we want to require a value for. Let's take a look at a sample script. This sample script syntax is a component enclosed in square brackets with open curly bracket and closed curly bracket and inside, we want to add all of our component data. So this movement component has three fields; top, speed, turning radius and acceleration. And these fields will match up to a movement component with top speed, turning radius and acceleration.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The <b>Lexer</b> is long and complicated so strap in:
            <pre>
            <span class="glyphicon-remove"></span>//using System; System.IO; and UnityEngine;
            public class Lexer : IDisposable {
                StreamReader input;
                MemoryStream stream;
                private string token;
                private TokenType tokenType;

                //tokens define the language, they allow us to know how to parse the script
                public enum TokenType {
                    IdentifierToken,
                    KeywordToken,
                    IntToken,
                    RealToken,
                    StringToken,
                    OtherToken,
                    EndOfInput,
                    IntRangeToken,
                    RealRangeToken,
                    ComponentToken
                    BoolToken,
                    Vec3,
                    Vec3Range
                }

                public Lexer(string fileInput) {
                    //generate a new stream reader to use our lexer on
                    input = new StreamReader(GenerateStreamFromString(fileInput));
                }

                public Stream GenerateStreamFromString(string s) {
                    stream = new MemoryStream();
                    StreamWriter writer = new StreamWriter(stream);
                    writer.Write(s);
                    writer.Flush();
                    stream.Position = 0;
                    return stream;
                }

                public void Dispose() {
                    stream.Dispose();
                }

                private void SkipWhiteSpace() {
                    //peek ahead each character and consume whitespace characters, otherwise we're done.
                    int c = input.Peek();
                    while(Char.IsWhiteSpace((char)c)) {
                        input.Read();
                        
                        if(input.EndOfStream)
                            return;

                        c = input.Peek();
                    }
                }

                private int GetNextFromInput() {
                    input.Read();
                    return input.Peek();
                }

                private int GetNextNonWhiteSpaceFromInput() {
                    input.Read();
                    SkipWhiteSpace();
                    return input.Peek();
                }

                public void NextToken() {
                    try{
                        token = "";
                        SkipWhiteSpace();
                        if(input.EndOfStream) {
                            token = "&lt;eof&gt;";
                            tokenType = TokenType.EndOfInput;
                            return;
                        }
                        int c = input.Peek();
                        if(char.IsDigit((char)c) || c == "-") {
                            if(c == "-") {
                                token = token + (char) c;
                                c = GetNextFromInput();
                            }
                            tokenType = TokenType.IntToken;
                            while(char.IsDigit((char) c)) {
                                token = token + (char) c;
                                c = GetNextFromInput();
                            }
                            if(c == ".") {
                                tokenType = TokenType.RealToken;
                                token = token + (char) c;
                                c = GetNextFromInput();
                                while(char.IsDigit((char) c)) {
                                    token = token + (char) c;
                                    c = GetNextFromInput();
                                }
                            }
                            if(c == ":") {
                                token = token + (char) c;
                                if(tokenType == TokenType.IntToken) {
                                    tokenType = tokenType.IntRangeToken;
                                    c = GetNextFromInput();
                                    if(c == "-") {
                                        token = token + (char) c;
                                        c = GetNextFromInput();
                                    }
                                    while(char.IsDigit((char) c)) {
                                        token = token + (char) c;
                                        c = GetNextFromInput();
                                    }
                                } else { //real token
                                    tokenType = TokenType.RealRangeToken;
                                    c = GetNextFromInput();
                                    if(c == "-") {
                                        token = token + (char) c;
                                        c = GetNextFromInput();
                                    }
                                    while(char.IsDigit((char) c)) {
                                        token = token + (char) c;
                                        c = GetNextFromInput();
                                    }
                                    if(c == ".") {
                                        token = token + (char) c;
                                        c = GetNextFromInput();
                                        while(char.IsDigit((char) c)) {
                                            token = token + (char) c;
                                            c = GetNextFromInput();
                                        }
                                    }
                                }
                            }
                            //first comma of vector 3
                            if(c == ',' &amp;&amp; 
                                (tokenType == TokenType.IntToken || tokenType == TokenType.RealToken ||
                                tokenType == TokenType.InRangeToken || tokenType == TokenType.RealRangeToken)) {
                                //vector support ranges for any of their values.
                                if(tokenType == TokenType.IntRangeToken || tokenType == TokenType.RealRangeToken)
                                    tokenType == TokenType.Vec3Range;
                                else
                                    tokenType = TokenType.Vec3;

                                token = token + (char) c;
                                c = GetNextNonWhiteSpaceFromInput();
                                if(c == '-') {
                                    token = token + (char) c;
                                    c = GetNextNonWhiteSpaceFromInput();
                                }
                                while(char.IsDigit((char) c) || c == '.' || c == ':' || c == '-') {
                                    if(c == ':')
                                        tokenType = TokenType.Vec3Range;

                                    token = token + (char) c;
                                    c = GetNextNonWhiteSpaceFromInput();
                                }
                                if(c == ',') { //second comma of vector3
                                    token = token + (char) c;
                                    c = GetNextNonWhiteSpaceFromInput();
                                    if(c == '-') {
                                        token = token + (char) c;
                                        c = GetNextNonWhiteSpaceFromInput();
                                    }
                                    while(char.IsDigit((char) c) || c == '.' || c == ':' || c == '-') {
                                        if(c == ':')
                                            tokenType = TokenType.Vec3Range;

                                        token = token + (char) c;
                                        c = GetNextNonWhiteSpaceFromInput();
                                    }
                                } else {
                                    throw new Exception("Invalid_Syntax: Expected second comma to define Vector3");
                                }
                            }
                        } else if(c == '[') {
                            tokenType = TokenType.ComponentToken;
                            c = GetNextFromInput();
                            while(char.IsLetter((char) c)) {
                                token = token + (char) c;
                                c = GetNextFromInput();
                            }
                            if(c != ']') {
                                throw new Exception("Invalid_Syntax: Component tokens must not contain any non-alphabet characters and must be closed with ']'");
                            }
                        } else if(char.IsLetter((char) c)) {
                            tokenType = TokenType.IdentifierToken;
                            while(char.IsLetter((char) c) || char.IsDigit((char) c)) {
                                token = token + (char) c;
                                c = GetNextFromInput();
                            }
                            if(token.ToLower().Equals("true") || token.ToLower().Equals("false")) {
                                tokenType = TokenType.BoolToken;
                            }
                        } else if(c == '"') {
                            tokenType = TokenType.StringToken;
                            c = GetNextFromInput();
                            while(c != '"') {
                                token = token + (char) c;
                                c = GetNextFromInput();
                                if(c == -1)
                                    throw new Exception("Invalid_Syntax: must close '\"'");
                            }
                            //Clear the " so it's not waiting for the next token.
                            GetNextFromInput();
                        } else {
                            tokenType = TokenType.OtherToken;
                            token = token + (char) c;
                                int d = GetNextFromInput();
                            if((c == '<') &amp;&amp; (d == '='))
                                token = token + (char) d;
                            else if((c == '<') &amp;&amp; (d == '<'))
                                token = token + (char) d;
                            else if((c == '>') &amp;&amp; (d == '='))
                                token = token + (char) d;
                            else if((c == '=') &amp;&amp; (d == '='))
                                token == token + (char) d;
                            else if((c == '!') &amp;&amp; (d == '='))
                                token = token + (char) d;
                        }
                    } catch (Exception ex) {
                        Debug.Log(ex.Message);
                    }
                }

                public System.Object GetValue(TokenType tt) {
                    string tokenValuePair = token;
                    NextToken();
                    if(Match("=")) {
                        tokenValuePair += "=";
                        NextToken();
                        tokenValuePair += token;
                        if(tokenType == tt) {
                            return GetObject();
                        }
                    }
                    Debug.Log("TokenType mismatch when getting value: " + tokenValuePair);
                    return null;
                }

                public System.Object GetValue() {
                    string tokenValuePair = token;
                    NextToken();
                    if(Match("=")) {
                        tokenValuePair += "=";
                        NextToken();
                        tokenvaluePair += token;
                        return GetObject();
                    }
                    Debug.Log("TokenType mismatch when getting value: " + tokenValuePair);
                    return null;
                }

                public System.Object GetObject() {
                    switch(tokenType) {
                        case TokenType.IntToken:
                            return int.Parse(GetToken());
                        case TokenType.IntRangeToken:
                            string[] iComponents = GetToken().Split(':');
                            return new int[]{int.Parse(iComponents[0]), int.Parse(iComponents[1])};
                        case TokenType.RealToken:
                            return float.Parse(GetToken());
                        case TokenType.RealRangeToken:
                            string[] fComponents = GetToken().Split(':');
                            return new float[]{float.Parse(fComponents[0]), float.Parse(fComponents[1])};
                        case TokenType.StringToken:
                            return GetToken();
                        case TokenType.BoolToken:
                            return bool.Parse(GetToken());
                        case TokenType.IdentifierToken;
                            return GetToken();
                        case TokenType.Vec3:
                            string[] components = GetToken().Split(',');
                            return new Vector3(float.Parse(components[0]), float.Parse(components[1]), float.Parse(components[2]));
                        case TokenType.Vec3Range:
                            string[] rangeComponents = GetToken().Split(',');
                            float[] vec3Range = new float[6];
                            //construct an array of 6 floats, each two defining the min/max for the x, y, and z components.
                            for(int comp = 0; comp < 3; comp++) {
                                if(rangeComponets[comp].Contains(":")) {
                                    int indexOfColon = rangeComponents[comp].IndexOf(':');

                                    //if there's a range use it
                                    vec3Range[vec3RangePointer++] = float.Parse(rangeComponents[comp].Substring(0, indexOfColon));
                                    vec3Range[vec3RangePointer++] = float.Parse(rangeComponents[comp].Substring(indexOfColon + 1, rangeComponents[comp].Length - 1 - indexOfColon));
                                } else {
                                    //if there's not a range, just use the same value
                                    vec3Range[vec3RangePointer++] = float.Parse(rangeComponents[comp]);
                                    vec3Range[vec4RangePointer++] = float.Parse(rangeComponents[comp]);
                                }
                            }
                            return vec3Range;
                    }
                    return null;
                }

                public static void FinalizeSpecialTypes(ref System.Object value, TokenType type) {
                    switch(type) {
                        case Lexer.TokenType.IntRangeToken:
                            int[] intRange = (int[])value;
                            value = UnityEngine.Random.Range(intRange[0], intRange[1]);
                            break;
                        case Lexer.Tokentype.RealRangeToken:
                            float[] floatRange = (float[])value;
                            value = UnityEngine.Random.Range(floatRange[0], floatRange[1]);
                            break;
                        case Lexer.TokenType.Vec3Range:
                            float[] vec3Range = (float[])value;
                            value = new Vector3(UnityEngine.Randome.Range(vec3Range[0], vec3Range[1]),
                                                UnityEngine.Randome.Range(vec3Range[2], vec3Range[3]),
                                                UnityEngine.Randome.Range(vec3Range[4], vec3Range[5]));
                            break;
                    }
                }

                public string GetToken() {
                    return token;
                }

                public TokenType GetTokenType() {
                    return tokenType;
                }

                public bool Match(string test) {
                    return test.ToLower().Equals(token.ToLower());
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's take a look at that data here: <b>DataExample1.advdata</b>
            <pre>
            <span class="glyphicon-remove"></span>[Movement] {
            topSpeed=10.4
            turningRadius=1
            acceleration=5
            }
            [Transform] {
            scale=8,7,1
            position=1.53,1.52,13.5
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Here is a second example: <b>TestEntityB.advdata</b>
            <pre>
            <span class="glyphicon-remove"></span>[Movement] {
            topSpeed = 5
            turningRadius = 2
            acceleration = 2
            }
            [Transform] {
            scale= 2, 2, 1
            position=-3,0,0
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Now let's examine how these scripts get loaded. The advanced prefab loader will keep a list of all our custom prefabs, it will load all of the prefabs and create advanced custom prefab objects. And then, do a prep and verify call which will verify the syntax of the prefab. If it's correct, it will add it to its list of prefabs. These can then be instantiated with a prefab name which will be the filename of the prefab. Additionally for this example it will create prefabs based on A or B input.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's take a look at the source code for our <b>AdvPrefabLoader</b> script:
            <pre>
            <span class="glyphicon-remove"></span>//using UnityEngine, System.Collection, System.Collection.Generic, System.IO;

            public class AdvPrefabLoader : MonoBehaviour {
                
                Dictionary&lt;string, AdvCustomPrefab&gt; prefabs = new Dictionary&lt;string, AdvCustomPrefab&gt;();

                void Start() {
                    //A statically loaded folder for the demo
                    LoadPrefabFolder(@"Assets\");
                }

                public void LoadPrefabFolder(string dataFolder) {
                    //get all the files ending with .advdata in the specifid directory
                    foreach(string dataFile in Directory.GetFiles(dataFolder, "*.advdata", SearchOption.AllDirectories)) {
                        string fileContents = File.ReadAllText(dataFile);
                        string name = dataFile.Substring(dataFile.LastIndexOf("\\")+1, dataFile.LastIndexOf(".") - (dataFile.LastIndexOf("\\")+1));
                        AdvCustomPrefab prefab = new AdvCustomPrefab(name, fileContents);
                        if(prefab.PrepAndVerify())
                            prefabs.Add(name, prefab);
                    }
                }

                public GameObject InstantiatePrefab(string prefabName) {
                    if(prefabs.ContainsKey(prefabName)) {
                        return prefabs[prefabName].Instantiate();
                    } else {
                        Debug.Log("Prefab not loaded");
                    }
                    return null;
                }

                void Update() {
                    if(Input.GetKeyDown(KeyCode.A)) {
                        InstantiatePrefab("DataExample1");
                    }
                    if(Input.GetKeyDown("KeyCode.B)) {
                        InstantiatePrefab("TestEntityB");
                    }
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's now see the advanced component prefab. The advanced component prefab will take the name, data and keep the game object copy. This game object copy is the parse method. The first thing we do is create a new game object and then parse the data that has been passed in. This parse method is somewhat complex. It uses the Lexer to parse the data, primarily using the NextToken method. The NextToken method is specific to the language we decide to create. We define different tokens that we want it to find, and then define the algorithm for passing through the text and finding those tokens. For example, the component token looks for an open square bracket. Then we decide it's a component token. It will then continue to get tokens, until we find the closed bracket. If we don't find the closed bracket, that's an invalid syntax, because we're only expecting an open bracket, and then a closed bracket. Then we have a component to token. Let's continue looking at the parse method. The Lexer will continue to find tokens. If it finds a component token, it will get the component name, and parse to ensure the syntax is correct for the remainder of the definition. If the component name matches a unity component that we have defined as supported, we will parse it as a unity component. Otherwise we will parse it as one of our custom components.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's take a look at parsing a unity component. Parsing unity components is different from parsing custom components because we're unable to use the same algorithm for parsing. For example, parsing a transform component. We'll look for a position, rotation, and scale. Then, our lexer will receive the vector3 from the script file, and apply it to the transform in the position, rotation or local scale.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's take a look at parsing a custom component. Custom components are parsed by attempting to add the component using the component name. If the component name is a component that exists it will be successfully added. In this case we would be parsing in movement as our component name. Which is our movement class here. If the component exists, it is a success, and we call SetData on the component. SetData uses field info from the class type of the component we want to parse for each field defined in the component. Top speed, turning radius, and acceleration.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's review the code from our <b>Movement</b> class:
            <pre>
            <span class="glyphicon-remove"></span>//using UnityEngine, System.Collections, System.Collection.Generic, System.Reflection;

            public class Movement : AdvComponent {
                float currentSpeed;

                [PrefabAttribute(RequiresDefinition=true)]
                public float topSpeed;

                [PrefabAttribute(RequiresDefinition=true)]
                public float turningRadius;

                [PrefabAttribute(RequiresDefinition=true)]
                public float acceleration;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Another example of a fun class to use could be a <b>Pathfinding</b> class:
            <pre>
            <span class="glyphicon-remove"></span>//using UnityEngine, System.Collections;

            public class Pathfinding : AdvComponent {
                [PrefabAttribute(RequiresDefinition=true)]
                public string movementType;

                [PrefabAttribute(RequiresDefinition=true)]
                public float maximumDistance;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            These are all fields defined in the component. We will test to see if that field exists within the type of component we're parsing. In this case, movement. If that fields exists, we will attempt to get the value and set it to the field being parsed. If the value does not exist, we return an unkown property error. Finally, we will go through each field on the component and check the attributes flag. This is a custom attribute that defines, if the field requires definition. In this case, all of these fields require a definition.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            So, we will throw an error if one of these fields is not defined in our script file. Finally we will return if we are successful in setting the data. In play mode, this should parse all the components. Then we see that we have that unkown property error, because turning radius is on component movement. And we're missing a component, turning radius. This appears to be a simple spelling mistake in the example. This kind of check is important, and helps us find errors before sending any scripts to the field. Now that we fixed our error hit play again.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Here is another long and somewhat technical piece of code for the <b>Advanced Custom Prefab</b>:
            <pre>
            <span class="glyphicon-remove"></span>//using UnityEngine, System.Collection, System.Collection.Generic, System
            public class AdvCustomPrefab {
                public string name;
                private string data;

                private List&lt;string&gt; tags = new List&lt;string&gt;();
                private List&lt;string&gt; components = new List&lt;string&gt;();

                private GameObject gameObjectCopy;

                public AdvCustomPrefab(string name, string data) {
                    this.name = name;
                    this.data = data;
                }

                public enum SupportedUnityComponent {
                    Mesh,
                    Transform,
                    Collider
                }

                // PrepAndVerify will parse the script to ensure it's well formated.
                // This should be done at load time, so we can make the decisions early
                // if we want to keep it. Better than returning errors half way into the 
                // game when we try to load the prefab.
                public bool PrepAndVerify() {
                    return Parse();
                }

                public bool HasComponent(Type type) {
                    string typeName = type.Name;
                    return components.Contain(typeName);
                }

                private bool Parse() {
                    //Due to the limitations of Unity (can't create GameObjects without also instantiating them)
                    // we're going to temporarily create a game object, get some data from it, and then destroy it.
                    //This will verify the syntax of the file
                    gamObjectCopy = new GameObject(name);

                    tags.Clear();
                    components.Clear();

                    bool retVal = Parse(ref gameObjectCopy);

                    gameObjectCopy.SetActive(false);
                    gameObjectCopy.hideFlags = HideFlags.HideAndDontSave;

                    if(!retVal) {
                        Debug.Log("Error parsing!");
                        if(Application.isEditor) {
                            UnityEngine.Object.DestoryImmediate(gameObjectCopy);
                        } else {
                            GameObject.Destory(gameObjectCopy);
                        }
                    }
                    return retVal;
                }

                public bool Parse(ref GameObject go) {
                    bool retVal = true;
                    Lexer lex = new Lexer(data);
                    lex.NextToken();
                    while(lex.GetTokenType() != Lexer.TokenType.EndOfInput) {
                        switch(lex.GetTokenType()) {
                            case Lexer.TokenType.ComponentToken:
                                string componentName = lex.GetToken();

                                //ensure correct syntax to continue
                                lex.NextToken();
                                if(lex.Match("]")) {
                                    lex.NextToken();
                                    if(lex.Match("{")) {
                                        lex.NextToken();
                                    } else {
                                        Debug.Log("Component declaration must be followed by an open bracket`{`");
                                        lex.Dispose();
                                        return false;
                                    }
                                } else {
                                    Debug.Log("Component name must not have any spaces and must be closed with a square bracket `]`");
                                    lex.Dispose();
                                    return false;
                                }
                                //now continue on to parse component body

                                if(Enum.IsDefined(typeof(SupportedUnityComponent), componentName)) {
                                    //if the component is named as one of the built in supported unity components, use a special parser.
                                    retVal &amp;= ParseUnityComponent((SupportedUnityComponent)Enum.Parse(typeof(SupportedUnityComponent), componentName), ref lex, ref go);
                                } else {
                                    //otherwise use the parser for our custom components.
                                    retVal &amp;= ParseCustomComponent(componentName, ref lex, ref go);
                                }

                                break;
                            case Lexer.TokenType.IdentifierToken:
                                if(lex.Match("Tags")) {
                                    lex.NextToken();
                                    if(lex.Match("{")) {
                                        lex.NextToken();
                                        ParseTags(ref lex);
                                    }
                                } else {
                                    Debug.Log("Unexpected token: `" + lex.GetToken() + "`. Expected `Tags` token at this level.");
                                }
                                break;
                            default:
                                //other tokens we might care about at this level would be meta information for the entity, like name, type and so on. Information specific to an entity.
                                Debug.Log("Unexpected token: " + lex.GetToken());
                                break;
                        }
                        lex.NextToken();
                    }
                    lex.Dispose();
                    return retVal;
                }

                private bool ParseUnityComponent(SupportedUnityComponet component, ref Lexer lex, ref GameObject go) {
                    bool retVal = true;
                    switch(component) {
                        case SupportedUnityComponent.Transform:
                            while(!lex.Match("}") &amp;&amp; lex.GetTokenType() != Lexer.TokenType.EndOfInput) {
                                string field = lex.GetToken();
                                lex.NextToken(); //equals symbol
                                if(lex.Match("=")) {
                                    lex.NextToken();
                                } else {
                                    Debug.Log("Syntax Error: Expected `=` after field name");
                                    lex.NextToken(); //try to continue anyway
                                }
                                switch(field.ToLower()) {
                                    case "position":
                                        System.Object position = lex.GetObject();
                                        Lexer.FinializeSpecialTypes(ref position, lex.GetTokenType());
                                        go.transform.position = (Vector3)position;
                                        break;
                                    case "rotation":
                                        System.Object rotation = lex.GetObject();
                                        Lexer.FinializeSpecialTypes(ref rotation, lex.GetTokenType());
                                        go.transform.rotation = Quaternion.Euler((Vector3)rotation);
                                        break;
                                    case "scale":
                                        System.Object scale = lex.GetObject();
                                        Lexer.FinializeSpecialTypes(ref scale, lex.GetTokenType());
                                        go.transform.localScale = (Vector3)scale;
                                        break;
                                    default:
                                        Debug.Log("`" + lex.GetToken() + "` not a supported field of Transform");
                                        retVal = false;
                                        break;
                                }
                                lex.NextToken();
                            }
                            break;

                        case SupportedUnityComponent.Mesh:
                            //This component will add the required components for rendering a mesh
                            MeshFilter meshFilter = go.AddComponent&lt;MeshFilter&gt;();
                            MeshRenderer meshRenderer = go.AddComponent&lt;MeshFilter&gt;();
                            while(!lex.Match("}") &amp;&amp; lex.GetTokenType() != Lexer.TokenType.EndOfInput) {
                                //Ideally this would be expanded to also search through all loaded custom meshes (not use a switch statement)
                                //However, for this section, we'll take a shortcut and only allow these primitives
                                if(lex.Match("meshtype")) {
                                    string meshType = (string)lex.GetValue(Lexer.TokenType.IdentifierToken);
                                    switch(meshType.ToLower()) {
                                        case "cube":
                                            meshFilter.mesh = GameObject.FindObjectOfType&lt;PrefabManager&gt;().primitiveCube;
                                            break;
                                        case "sphere":
                                            meshFilter.mesh = GameObject.FindObjectOfType&lt;PrefabManager&gt;().primitiveSphere;
                                            break;
                                        case "capsule":
                                            meshFilter.mesh = GameObject.FindObjectOfType&lt;PrefabManager&gt;().primitiveCapsule;
                                            break;
                                        default:
                                            Debug.Log("Mesh type: `" + meshType + "` not supported!");
                                            retVal = false;
                                            break;
                                    }
                                }
                                if(lex.Match("material")) {
                                    string material = (string)lex.GetValue(Lexer.TokenType.IdentifierToken);
                                    switch(material.ToLower()) {
                                        case "default":
                                            meshRenderer.material = GameObject.FindObjectOfType&lt;PrefabManager&gt;().defaultMaterial;
                                            break;
                                        default:
                                            Debug.Log("Material: `" material + "` not supported!");
                                            retVal = false;
                                            break;
                                    }
                                }
                                lex.NextToken();
                            }
                            break;

                        case SupportedUnityComponent.Collider:
                            Debug.Log(component);
                            //TODO Add support for defining our own colliders
                            //This component would accept and shape the dimensions
                            while(!lex.Match("}") &amp;&amp; lex.GetTokenType() != Lexer.TokenType.EndOfInput) {
                                lex.NextToken();
                            }
                            retVal = false;
                            break;

                        default:
                            //looks like we added a keyword, but not the parsing code?
                            Debug.Log("Don't know how to parse Unity component: " + component);
                            retVal = false;
                            break;
                    }
                    return retVal;
                }

                private bool ParseCustomComponent(string componentName, ref Lexer lex, ref GameObject go) {
                    AdvComponent customComponent = go.AddComponent(componentName) as AdvComponent;
                    bool setDataSuccess = false;
                    if(customComponent != null) {
                        setDataSuccess = customComponent.SetData(ref lex);
                    } else {
                        Debug.Log("Component " + componentName + " couldn't be added! Ensure it exists or isn't being added twice.");
                    }
                    return setDataSuccess;
                }

                public GameObject Instantiate() {
                    if(gameObjectCopy != null) {
                        GameObject go = GameObject.Instantiate(gameObjectCopy) as GameObject;
                        go.SetActive(true);
                        go.hideFlags = HideFlags.None;
                        return go;
                    } else {
                        return null;
                    }
                }

                private void ParseTags(ref Lexer lex) {
                    while(!lex.Match("}") &amp;&amp; lex.GetTokenType() != Lexer.TokenType.EndOfInput) {
                        if(lex.GetTokenType() == Lexer.TokenType.IdentifierToken) {
                            tags.Add(lex.GetToken());
                        }
                        lex.NextToken();
                    }
                }

                public Mesh GetMesh() {
                    if(gameObjectCopy != null &amp;&amp; gameObjectCopy.GetComponent&lt;MeshFilter&gt;() != null) {
                        return gameObjectCopy.GetComponent&lt;MeshFilter&gt;().mesh;
                    }
                    return null;
                }

                public Vector3 GetScale() {
                    if(gameObjectCopy != null) {
                        return gameObjectCopy.transform.localScale;
                    }
                    return Vector3.one;
                }

                public List&lt;string&gt; GetTags() {
                    return tags;
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Scene Setup</b>
            <p><span class="glyphicon-remove"></span>In order to set this up in your scene create an Empty "AdvancedPrefabLoader" object in the hierarchy. Then just add the Adv Prefab Loader script.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We see that we have no errors. And we can hit A or B to load our different entities. In our dataExampleOne, we have a transform and movement script. And test entity B has a transform and movement script, as definied in their text files. In this lesson, we learned about an advanced prefab system that allows us to easily find our own prefabs with human readable scripts. This can not only help you create customizations and loading of entities, like defining random variable rangers, but will also allow your end users to modify the content of your game.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            As with many systems like this, this is just one way of doing things. Defining a scripting language that works for you is important. Modifying the Lexer to a parsing style you're most comfortable with, or making the Lexer able to hand more errors are good steps towards improving this system. Additional features that are left to you are adding the ability to define nested entities and expanding the token knowledge of the parser to better understand more of the primitives unity has to offer.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="3">
    <h2>Storing &amp; Managing Prefabs</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we're going to go over a strategy for storing prefabs, both Unity built-in prefabs, and our custom ones. The primary goal of this system is to make access to prefabs easy throughout the game. A global system like this makes it simple to add entities in response to events, user input, throughout the narrative of the game, or part of an algorithm. Ideally, we want the system to support how we search for and add prefabs, typically by their name. Let's take a look at some of the code. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The Prefab Manager is going to define a couple dictionaries with a prefab name mapped to a custom prefab, also prefab name matched to a built-in prefab. And a tag name built into a list of prefab names. This is searching for prefabs by name. When the script starts it's going to load all our customPrefabs and load all our UnityPrefabs. Let's take a look at loading custom prefabs. This is going to load all of our data files that match the criteria here with the word Entity in the name. It will read the file contents and the name of the file and then create a new AdvCustomPrefab, then it will perform a PrepAndVerify method where it verifies the syntax of the prefab.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            If the prefab syntax is correct, the prefab is added to the Custom list. It then parses the CustomPrefabTags, adding those tags to the Tag List. Next it loads all Unity Prefabs. This is a similar structure, where it's loading each GameObject from the Resources directory. If the name Contains "Entity", it continues. If the name starts with an underscore, we can skip it. This is a nice way of skipping prefabs that we don't want added to our global system. Here we're checking to ensure that the name of the Prefab has not already been taken by a customPrefab.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Otherwise, we'll throw a Duplicate Error. There are additionally methods for getting the mesh, or gettingt the scale of prefabs, and we can add more for getting other common attributes about prefabs. The reason we have these here is to abstract away these methods for the difference in doing CustomPrefabs and UnityPrefabs. Finally, our extenuate method will take the name of a prefab and check to see if that name is in the customPrefabs or the unityPrefabs. Either one will then generate a prefrab based on the type of prefab there is.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Additionally, we have an overloaded version of instantiate that will take a position and rotation. Here, we have a method that will get a list of prefabs based on tag name. This will be useful in the case where you want to get a list of all entities that are tagged with, say, Enemy, Level One, and then you can use that list to generate random entities on a level that are all level one. Finally, the PrefabManager is going to use the OnGUI method to display a list of all of it's Prefabs. This is primarily for demonstration, but can also be used to drag and drop Prefabs into a scene.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's take a look at the <b>PrefabManager</b> here:
            <pre>
            <span class="glyphicon-remove"></span>//using UnityEngine, System.Collections, System.Collection.Generic, System.IO;

            public class PrefabManager : MonoBehaviour {
                
                public Mesh primitiveCube;
                public Mesh primitiveSphere;
                public Mesh primitiveCapsule;
                public Material defaultMaterial;

                public bool displayPrefabMenu = true;
                public bool showAll = false;

                public List&lt;string&gt; allPrefabs = new List&lt;string&gt;();

                Dictionary&lt;string, AdvCustomPrefab&gt; customPrefabs = new Dictionary&lt;string, AdvCustomPrefab&gt;();
                Dictionary&lt;string, GameObject&gt; prefabs = new Dictionary&lt;string, GameObject&gt;();
                Dictionary&lt;string, List&lt;string&gt;&gt; prefabsByTag = new Dictionary&lt;string, List&lt;string&gt;&gt;();

                GameObject pickedPrefab;

                void Start() {
                    //Load the custom prefabs first. We want any custom prefabs to cupercede Unity prefabs.
                    //This allows you, or users, to override existing prefabs with custom ones.
                    //If we don't want to allow that, simply reverse the load order.
                    LoadAllCustomPrefabs();

                    LoadAllUnityPrefabs();

                    Debug.Log("Prefabs Loaded!");
                }

                private void LoadAllCustomPrefabs() {
                    //Get all the txt files in the resources directory
                    //If we wanted to allow users to add their own scripts, we would instead
                    // copy these files externally on install and load them from here.
                    foreach(TextAsset dataFile in Resources.LoadAll&lt;TextAsset&gt;("")) {

                        //This is simply to keep other files in this project from loading
                        // for a cleaner demonstration
                        if(!dataFile.name.ToLower().Contains("entity") &amp;&amp; !showAll)
                            continue;

                        //Read all the data from the file
                        string filecontents = dataFile.test;
                        //Get the name of the prefab, as the file name
                        string name = dataFile.name;
                        //If we don't already have a prefab by that name, go about adding it
                        if(!allPrefabs.Contains(name)) {
                            //Create a new prefab using the data from the file
                            AdvCustomPrefab myPrefab = new AdvCustomPrefab(name, fileContents);
                            //Prep and verify. This means parse the data to ensure it's accurate and get
                            // some information from it, like the mesh and scale, for potential future use.
                            if(myPrefab.PrepAndVerify()) {
                                //If it's passed the verify, add it to our list
                                AddCustomPrefab(myPrefab, name);

                                //Add a reference to for each of the tags defined in the data file
                                //This allows us to group prefabs, so we could, for example,
                                // get all the prefabs tagged enemy and spawn one randomly
                                foreach(string tag in customPrefabs[name].GetTags()) {
                                    if(!prefabsByTag.ContainsKey(tag)) {
                                        prefabsByTag.Add(tag, new List&lt;string&gt;());
                                    }
                                    prefabsByTag.Add(name);
                                }
                            } else {
                                Debug.Log("Error: Prefab `" + name + "` had parse errors and cannot be loaded.");
                            }
                        } else {
                            Debug.Log("Error: Duplicate prefab defined! `" + name + "`");
                        }
                    }
                }

                private void AddcustomPrefab(AdvCustomPrefab prefab, string name) {
                    customPrefab.Add(name, prefab);
                    allPrefabs.Add(name);
                }

                private void LoadAllUnityPrefabs() {
                    //Utilize the Resources class to automatically locate the "Resources" directory
                    //Load each object that's a GameObject, that means prefabs.
                    foreach(GameObject go in Resources.LoadAll("", typeof(GameObject))) {
                        //This is simply to keep other files in this project from loading
                        // for a cleaner demonstration
                        if(!go.name.ToLower().Contains("entity") &amp;&amp; !showAll)
                            continue;

                        if(!allPrefabs.Contain(go.name)) {
                            prefabs.Add(go.name, go);
                            allPrefabs.Add(go.name);

                            //Unity prefabs only allow one tag.
                            if(!prefabsByTag.ContainsKey(go.tag)) {
                                prefabsByTag.Add(go.tag, new List&lt;string&gt;());
                            }

                            prefabsByTag[go.tag].Add(go.name);
                        } else {
                            Debug.Log("Error: Duplicate prefab defined! `" + name + "`");
                        }
                    }
                }

                public Mesh GetMeshFor(string prefabName) {
                    if(customPrefabs.ContainsKey(prefabName)) {
                        return customPrefabs[prefabName].GetMesh();
                    }
                    if(prefabs.ContainsKey(prefabName)) {
                        MeshFilter meshFilter = prefabs[prefabName].GetComponent&lt;MeshFilter&gt;();
                        if(meshFilter != null) {
                            return meshFilter.sharedMesh;
                        } else {
                            return null;
                        }
                    }
                    return null;
                }

                public Vector3 GetScalefor(string prefabName) {
                    if(customPrefabs.ContainsKey(prefabName)) {
                        return customPrefabs[prefabName].GetScale();
                    }
                    if(prefabs.ContainsKey(prefabName)) {
                        return prefabs[prefabName].transform.localScale;
                    }
                    return new Vector3(1, 1, 1);
                }

                public GameObject Instantiate(string prefabName) {
                    if(customPrefabs.ContainsKey(prefabName)) {
                        return customPrefabs[prefabName].Instantiate();
                    }
                    if(prefabs.ContainsKey(prefabName)) {
                        return GameObject.Instantiate(prefabs[prefabName]) as GameObject;
                    }
                    return null;
                }

                public GameObject Instantiate(string prefabName, Vector3 position, Quaternion rotation) {
                    if(customPrefabs.ContainsKey(prefabName)) {
                        GameObject droppedPrefab = customPrefabs[prefabName].Instantiate();
                        droppedPrefab.transform.position.Set(position.x, position.y, position.z);
                        droppedPrefab.transform.rotation.Set(rotation.x, rotation.y, rotation.z, rotation.w);
                        droppedPrefab.name = droppedPrefab.name.Replace("(Clone)","");
                        return droppedPrefab;
                    }
                    if(prefabs.ContainsKey(prefabName)) {
                        GameObject droppedPrefab = GameObject.Instantiate(prefabs[prefabName], position, rotation) as GameObject;
                        droppedPrefab.name = prefabName.Replace("(Clone)","");
                        return droppedPrefab;
                    }
                    return null;
                }

                List&lt;string&gt; GetPrefabsWithTag(string tag) {
                    if(prefabsByTag.ContainsKey(tag)) {
                        return prefabsByTag[tag];
                    } else {
                        return null;
                    }
                }

                void Update() {
                    if(displayPrefabMenu) {
                        if(pickedPrefab != null) {
                            pickedPrefab.transform.position = MouseUtils.GetMouseWorldPositionAtDepth(15);
                        }
                        if(Input.GetMouseButtonUp((int)MouseUtils.Button.Left)) {
                            OnMouseUp();
                        }
                    }
                }

                void OnGUI() {
                    if(displayPrefabMenu) {
                        int currentYPosition = 0;
                        int buttonHeight = 24;
                        if(allPrefabs.Count > 0) {
                            //For each prefab, create a button to allow us to "drag and drop" prefabs into the scene
                            foreach(string prefabName in allPrefabs) {
                                if(GUI.RepeatButton(new Rect(0, currentYPosition, 180, buttonHeight), prefabName)) {
                                    if((pickedPrefab == null || !prefabName.Equals(pickedPrefab.name))) {
                                        SetPrefabCursor(prefabName);
                                    }
                                }
                                //Increase the position to space the buttons out
                                currentYPosition += buttonHeight + 1;
                            }
                        } else {
                            GUI.Label(new Rect(0, currentYPosition,800, buttonHeight), "No prefabs available");
                        }
                    }
                }

                void SetPrefabCursor(string prefabName) {
                    //Set mouse cursor to drag to the selected prefab
                    if(allPrefabs.Contains(prefabName))
                        pickedPrefab = Instantiate(prefabName, MouseUtils.getMouseWorldPositionAtDepth(15), Quaternion.identity);
                }

                void ClearPrefabCursor() {
                    pickedPrefab = null;
                }

                void OnMouseUp() {
                    //Once we "drop" the prefab, leave it where it is
                    if(pickedPrefab != null) {
                        ClearPrefabCursor();
                    }
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In the scene, our example will have four Entities loaded. And we can check the data to see where that's coming from. We can Drag and Drop to create a new Entity in the scene. The nice thing about this is that the difference between them is entirely abstracted away. We can't tell if we're creating Built-In Prefabs or Unity Prefabs. In this section, we've covered how to combine your own custom prefabs system, with the unity built-in prefab system. The combination of these two allows for maximum flexibility in the generation and deployment of prefabs in your game.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Take a look at our Entities here: <b>EntityData1.txt</b>
            <pre>
            <span class="glyphicon-remove"></span>tags{testtag1,testtag2}

            [Movement] {
            topSpeed=10.4
            turningRadius=2
            acceleration=2
            }
            [Transform] {
            scale=1,4,1
            position=1.23,1.43,13.5
            }
            [Mesh] {
            meshtype=cube
            material=default
            }
            </pre>
            <p><span class="glyphicon-remove"></span>Here is the second: <b>EntityData2.txt</b></p>
            <pre>
            <span class="glyphicon-remove"></span>tags{testtag1,testtag2}

            [Movement] {
            topSpeed=10.4
            turningRadius=2
            acceleration=2
            }
            [Transform] {
            scale=1,1:1.1,1
            position=-1.23,1.43,13.5
            }
            [Mesh] {
            meshtype=sphere
            material=default
            }
            </pre>
            <p><span class="glyphicon-remove"></span>And the last one: <b>EntityData3.txt</b></p>
            <pre>
            <span class="glyphicon-remove"></span>tags{testtag1,testtag2}

            [Movement] {
            topSpeed=10.4
            turningRadius=2
            acceleration=2
            }
            [Transform] {
            scale=1,1,1
            position=1.23,-1.43,13.5
            }
            [Mesh] {
            meshtype=capsule
            material=default
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Scene Setup</b>
            <p><span class="glyphicon-remove"></span>Create a new empty called Prefab Manager and attach the Prefab Manager script.
            <br>Set the primitive objects appropriatly, set default material to Default-Diffuse, Display Prefab Menu to true, Show All to false.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            This is just the beginning of a custom prefab system. Having your own system enables you to create far more custimization around how prefabs are created loaded and maintained. The system enables easy randomness for attributes, and allows for end user modification. Loading your custom prefabs along with the built-in prefabs abstracts the differences away and allows easy use of both. We can already see how the ability to add additional tags to our custom prefabs makes organizing and selecting prefabs easier.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

                    <!-------------------------------------->
                </div>
            </div>
    </main>

    <!-------------------------------------------------------------------------->

    <!-- FOOTER -->
    <footer class="navbar navbar-inverse navbar-fixed-bottom">
        <nav>
            <div class="container">
                <div class="row">
                    <div class="col-md-6 col-sm-6 col-xs-12">
                        <ul>
                            <li>&copy; 2017 <a href="http://www.gabedeyo.com">Gabe Deyo</a></li>
                            <li>|</li>
                            <li><a href="mailto:gabedeyo@gmail.com?subject=Notes">gabedeyo@gmail.com</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>
    </footer>

    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
    <script src="../../../js/selection.js" charset="utf-8"></script>
</body>

</html>
