<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Advanced Scripting</title>

    <meta name="viewport" content="width=device-width,initial-scale=1.0, shrink-to-fit=no" />

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/page.css">
</head>

<body>

    <!-- Top Navigation -->
    <header>
        <nav class="navbar navbar-inverse">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapsemenu" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a href="../index.html" class="navbar-brand">Personal Notes</a>
                </div>

                <div class="collapse navbar-collapse" id="collapsemenu">
                    <ul class="nav navbar-nav">

                        <!-- GAME DEVELOMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Game Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- CONCEPTS -->
                                <li><a href="concepts.html">Concepts <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ENGINE -->
                                <li><a href="engine.html">Engine <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- IMPLEMENTATIONS -->
                                <li><a href="implementations.html">Implementations <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- PROGRAMMING -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Programming <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- ALGORITHMS -->
                                <li><a href="../code/algorithms.html">Algorithms <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PROBLEMS -->
                                <li><a href="../code/problems.html">Problems <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- RANDOM -->
                                <li><a href="../code/random.html">Random <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- GABE DEVELOPMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Gabe Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- FITNESS PAGE -->
                                <li><a href="../gabe/fitness.html">Fitness <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- STYLE & GROOMING PAGE -->
                                <li><a href="../gabe/style.html">Style <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- FINANCE PAGE -->
                                <li><a href="../gabe/finance.html">Finance <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PHILOSOPHY PAGE -->
                                <li><a href="../gabe/philosophy.html">Philosophy <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                    </ul>
                </div>

            </div>
        </nav>
    </header>

    <!-------------------------------------------------------------------------->

    <!-- MAIN -->
    <main>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h1 id="title">Advanced Scripting</h1>

                    <aside>
                        <button type="button" class="btn btn-default" name="button" id="selectAll">Select All</button>
                        <button type="button" class="btn btn-default" name="button" id="clearAll">Clear All</button>
                    </aside>

                    <div class="jumbotron heliList">
                        <h2>Index</h2>
                        <ul>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#1">Coroutines</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#2">Event &amp; Messaging Systems</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#3">Saving and Loading Games</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#4">Ray Casting</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#5">Mini Maps</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#6">Dynamic Meshes</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#7">Quad Tree</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#8">Extension Methods</a>
                                </p>
                            </li>
                        </ul>
                    </div>

<div class="jumbotron col-md-12 heliList" id="1">
    <h2>Coroutines</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we're going to learn about coroutines. Coroutines are a coding structure, that allows us to delay the execution of code. We can essentially pause the execution at a specific section of code, and then pick up where we left off at a later time. This can be used not only as an optimization technique, but also is an easy way to make an event happen at regular intervals. Let's take a look.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's take a look at the beginning of our Coroutines class. So far, we'll see what functions are covered later:
            <pre>
            <span class="glyphicon-remove"></span>public class Coroutines : MonoBehaviour {

                public float secondsToWait = 5f;
                public bool move = false;

                public bool complete = true;

                public bool useYieldForHeavy = false;

                public void OnMouseDown() {
                    move = true;

                    NaiveMovement();

                    StartCoroutine(NaiveMovementFixed());

                    StartTogglePulse();

                    StartHeavyTask();
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            A common mistake when starting game programming, is to implement a for loop for movement. Of course, we know the entire for loop, will execute within one frame. Meaning all of these translates, are added together and no visible movement occurs. Even worse, this method moves back to the starting position at the end. Meaning all of this movement is for nothing. This function will be called NaiveMovement().
            <pre>
            <span class="glyphicon-remove"></span>public void NaiveMovement() {
                //A common mistake when starting programming with games.
                //When attempting to move an object little by little, a for loop is used
                // this approach moves the object little by little, however all the movement
                // happens in one frame, so visually the movement is instantaneous
                for(int i = 0; i < 100; i++) {
                    this.transform.Translate(0.1f, 0f, 0f);
                }
                move = false;

                //reset position at the end
                this.transform.position = new Vector3.zero;
                Debug.Log("Completed moving");
            }
            </pre>
            <p><span class="glyphicon-remove"></span>So we see that on MouseDown we're activating our NaiveMovement function. We've completed moving, even through there was no visible movement. We can modify this with a coroutine, using the start coroutine method, and passing in our movement fixed method.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's take a look at that NaiveMovementFixed coroutine:
            <pre>
            <span class="glyphicon-remove"></span>//Looks like a regular function - has actually been converted into an object by the compiler
            //An object that is essentially a state machine delimited by the yield statements
            public IEnumerator NaiveMovementFixed() {
                //Slightly modified with coroutine functionality, this works closer to expected.
                for(int i = 0; i < 100; i++) {
                    this.transform.Translate(0.1f, 0f, 0f);
                    yield return 0; //yield execution for one frame
                }
                move = false;

                //reset position at the end
                this.transform.position = new Vector3.zero;
                Debug.Log("Completed moving");
            }
            </pre>
            <p><span class="glyphicon-remove"></span>So we notice that instead of returning void, we're going to return an IEnumerator, and we're going to call it, with yield return zero. This will yield execution of the code for one frame. We now see that executing one iteration per frame.</p>
            <p><span class="glyphicon-remove"></span>So what's actually happening behind the scenes? The compiler takes this method of IEnumerator, and converts it into an object. The object is broken apart into a state machine, based on the yield return statement.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            So how else can we use coroutines? We could use them to make an event happen at regular intervals. For example, if we want to toggle a pulse. Let's first look at the code:
            <pre>
            <span class="glyphicon-remove"></span>public void StartTogglePulse() {
                StartCoroutine(TogglePulse());
            }

            public IEnumerator TogglePulse() {
                bool big = false;
                while(true) { //normally a very bad thing. Typically starts an infinite loop
                    //Alternate between small and large, use the `big` boolean as a toggle to decide
                    if(big) {
                        this.transform.localScale = new Vector3(2f, 2f, 2f);
                    } else {
                        this.transform.localScale = new Vector3(0.5, 0.5f, 0.5f);
                    }
                    big = !big;

                    //WaitForSeconds is a YieldInstruction. These are like special states to add to the
                    // state machine. In this case, it's a state that won't return for another 1 second.
                    yield return new WaitForSeconds(1f); //yield execution for 1 seconds.
                }
            }
            </pre>
            Essentially we're going to say, if it's big, make it small, if it's small, make it big. And in this case we're going to do a while true loop, which is typically a bad thing. If we didn't have this yield in here this would be an infinite loop and we'd be locked out. Here we're going to yield return and we're going to wait for one second. This is causing the state machine to wait one second before jumping to the next state. And let's take a look at this. Clicking, we see that we have one second between getting big and small.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Finally, we can use coroutines to optimize code. For example, when running heavy tasks and doing other things on screen, like moving, we can see that, starting a heavy task and moving at the same time means we have to wait for the heavy task to finish before continuing to our movement code. This is because the entire heavy task has to complete before we can start on our move code. Let's see how we can fix this. Onto some code:
            <pre>
            <span class="glyphicon-remove"></span>//Start a heavy task
            //Select the method based off the `useYieldForHeavy` Boolean
            public void StartHeavyTask() {
                if(useYieldForHeavy)
                    StartCoroutine(HeavyTask_WithYield());
                else
                    HeavyTask();
            }

            //Perform that task as is, without coroutines
            public void HeavyTask() {
                int processed = 0;
                int maxProcessed = 100;
                while(processed < maxProcessed) {
                    Process();
                    processed++;
                }
                Debug.Log("Completed Heavy Task");
            }

            //Use Coroutines to yield between processing
            public IEnumerator Heavytask_WithYield() {
                int processed = 0;
                int maxProcessed = 100;
                while(processed < maxProcessed) {
                    Process();
                    processed++;
                    yield return 0;
                }
                Debug.Log("Completed heavy task with yield");
            }

            //A complex task, like processing a detailed path or calculating AI response
            //In this case, a fake heavy processing task to take up CPU
            private void Process() {
                double t = double.MinValue;
                for(int i = 0; i < int.MaxValue/1000f; i++) {
                    t = Mathf.Sqrt(i);
                }
            }
            </pre>
            <p><span class="glyphicon-remove"></span>It's going to take a number of items to be processed and process them, until it's completed. If we have a heavy task with yield, it's going to take a number of items to be processed, and process one per frame until it's completed. Let's see what the difference makes. If we turn on, UseYieldForHeavy, and then click our object, we'll see that it's going to move at the same time that it's processing the heavy task. And actually going to finish right around the same time.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Scene Setup</b>
            <p><span class="glyphicon-remove"></span>Create a new sphere object called Sphere and attach the Coroutines script.
            <br>Set Seconds To Wait to 5, Move to false, Complete to false, and Use Yield For Heavy to false.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The coroutine is a powerful coding structure that allows further control and execution of our code. Common uses include distributing the processing of a heavy method over multiple frames. Offering an alternative for control of structures in our code, or making something happen regularly in game.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="2">
    <h2>Event &amp; Messaging Systems</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we're going to go over a common control structure in game event systems. Event systems are used to communicate between objects, systems, and game managers. These systems typically have events and listeners. The listeners will subscribe to the events, also called messages, of a certain type. When an event is broadcast of a certain type, its sent to each of the listeners for that type. What each listener does with that event depends on that event. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Event message could be something "This building has been damaged". Then we can have a GUI listener that will display a message on screen about the building being damaged or where it is, a worker listener that will try to repair the building, and finally, perhaps the score listener that deducts points for letting your building get damaged. The primary benefit of these systems is flexibility. It's simple to have an object start listening for events and have it respond appropriately without needing to touch the code that is generating the event.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's check out our first <b>Event Broadcaster</b>:
            <pre>
            <span class="glyphicon-remove"></span>public class EventBroadcaster : MonoBehaviour {
                //A delegate is a type that allows you to create a method like a parameter
                // essentially it allows you to then create an instance of the delegate you can
                //pass around and call as if it were a regular method.
                //For this situation we're going to use it to attach other methods to
                //it will be the method that's called and thus calls the methods of our listeners
                public delegate void EventAction();

                //Static means that this EventAction is going to be accessable without needing to
                // instantiate an instance of this object.
                //The event keyword is also key here. It allows us to notify the listener classes
                // when the event action method is called.
                public static event EventAction OnEventAction;

                void OnMouseDown() {
                    //When this object is clicked, it will activate its event,
                    // this will then notify all listeners that the event has happened.
                    OnEventAction();
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Here we have an EventBroadcaster that's going to create a delegate. Each of the event listeners is going to create a method that matches the signature of this delegate where it returns void and takes no parameters. Then we're going to create an instance of that EventAction, with the event keyword name OnEventAction. This is essentially a hub where all event listeners can attach to so that their event action delegatees can be actived when this one is. In this case, in the OnMousedown method, we're going to activate this method. And thus, send an event to all the listeners.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's take a look at our <b>Event GUI Listener</b>:
            <pre>
            <span class="glyphicon-remove"></span>public class EventGUIListener : MonoBehaviour {
                public string messageToDisplay = "Event Recieved!";
                public float secondsToShowMessage = 3f;

                private bool showMessage = false;

                //When this component is first enabled, we want to subscribe to events
                // from the eventBroadcaster
                void OnEnable() {
                    //We're adding our notification method `RespondToEvent` to the OnEventAction
                    // now, whenever OnEventAction is called, our method RespondToEvent will also be called
                    EventBroadcaster.OnEventAction += EventRecieved;
                }

                //When this component is disabled, we want to "unsubscribe" from events.
                void OnDisable() {
                    //Now we're removing our notification method, no longer taking any action when OnEventAction is called
                    EventBroadcaster.OnEventAction -= EventRecieved;
                }

                void OnGUI() {
                    if(showMessage)
                        GUI.Label(new Rect(100, 100, 300, 20), messageToDisplay);
                }

                //This method matches the signature of 
                // public delegate void EventAction();
                //Returns void and takes no arguments
                //This means we can add it to the OnEventAction event
                void EventRecieved() {
                    ShowTimedMessage();
                }

                void ShowTimedMessage() {
                    StartCoroutine(TimedMessage());
                }

                IEnumerator TimedMessage() {
                    showMessage = true;
                    yield return new WaitForSeconds(secondsToShowMessage);
                    showMessage = false;
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Here we have our GUI listener. When the object this script is attached to is enabled it's going to attach itself to the OnEventAction of the Event Broadcaster. It's going to attach its event received method, and we can see that it matches the delegate signature where it returns void and takes no arguments. So when this method is activated here, we're going to show a timed message, which is simply a coroutine that toggles a boolean from true, waits a couple of seconds, and toggles it off.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's see another listener called <b>Event Move Listener</b>:
            <pre>
            <span class="glyphicon-remove"></span>public class EventMoveListener : MonoBehavior {
                public Vector3 eventMoveDirection = new Vector3(0, 1, 0);

                //When this component is first enabled, we want to subscribe to events
                //from the eventbroadcaster
                void OnEnable() {
                    //We're adding our notification method `RespondToEvent` to the OnEventAction
                    // now, whenever OnEventAction is called, our method RespondToEvent will also be called
                    EventBroadcaster.OnEventAction += RespondToEvent;
                }

                //When this component is disabled, we want to "unsubscribe" from events.
                void OnDisable() {
                    //Now we're removing our notification method, no longer taking any action when OnEventAction is called
                    EventBroadcaster.OnEventAction -= RespondToEvent;
                }

                //Our RespondToEvent method is used to respond to events
                //In this case, we'll just move ourselves to show that we've responded
                void RespondToEvent() {
                    this.transform.Translate(eventMoveDirection);
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Once again, when the object script is attached too, is activated, it's going to attach itself to the on event action with its respond to event method. In this case the respond to event method is fairly simple. It's just going to translate the object it's attached to in the event move direction which is defined here.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's move on to a more advanced example. In this example, we're going to see an event relay. This is an event relay class, so that we can send events from any script without having to attach an additional sender script. This will relay events between a sender of listeners. The delegate for this method is slightly different than the last. It's going to return a string, and it takes two arguments; an event message type and a sender, which is a mono behaviour.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's take a look at the <b>Advanced Event Sender</b>:
            <pre>
            <span class="glyphicon-remove"></span>public class AdvancedEventSender : MonoBehaviour {
                public bool mouseIsOverThis = false;

                void Update() {
                    if(mouseIsOverThis) {
                        if(Input.GetMouseButtonDown((int)Mouse.Utils.Button.Left)) {
                            string value = AdvancedEventRelay.RelayEvent(
                                AdvancedEventRelay.EventMessageType.StructureBuilt, this);
                            Debug.Log("StructureBuilt Event was seen by: " + value);
                        }
                        if(Input.GetMouseButtonDown((int)Mouse.Utils.Button.Right)) {
                            string value = AdvancedEventRelay.RelayEvent(
                                AdvancedEventRelay.EventMessageType.UnitDestroyed, this);
                            Debug.Log("UnitDestroyed Event was seen by: " + value);
                        }
                    }
                }

                public void OnMouseEnter() {
                    mouseIsOverThis = true;
                }

                public void OnMouseExit() {
                    mouseIsOverThis = false;
                }   
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this case, when the mouse is over this object, if we click with the left mouse button we're going to relay an event of event type StructureBuilt. We're going to send us as the sender, and then we're going to log the value returned from that event. Likewise, if the right mouse button is pressed, we're going to relay an event of type UnitDestroyed with ourselves as the sender and log the value of the returned string from that event.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's now see how our <b>Advanced Event Listener</b> works:
            <pre>
            <span class="glyphicon-remove"></span>public class AdvancedEventListener : MonoBehaviour {
                public List&lt;AdvancedEventRelay.EventMessageType&gt; eventsHandled = 
                    new List&lt;AdvancedEventRelay.EventMessageType&gt;();

                void OnEnable() {
                    AdvancedEventRelay.OnEventAction += HandleEvent;
                }

                void OnDisable() {
                    AdvancedEventRelay.OnEventAction -= HandleEvent;
                }

                //This method matches the signature of:
                // public delegate string EventAction(EventMessageType type, MonoBehaviour sender);
                //This means we can add it to the OnEventAction

                string HandleEvent(AdvancedEventRelay.EventMessageType messageType, MonoBehaviour sender) {
                    if(eventsHandled.Contains(messageType)) {
                        Debug.Log("Handled event: " messageType + " from sender: " + sender
                         + " " + Vector3.Distance(this.transform.position, sender.transform.position)
                         + " units away from me");

                         return this.ToString();
                    } else {
                        //ignore event
                        return this.ToString();
                    }
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Listeners are going to define a list of events that they handle, and they're going to attach themselves tothe onEventAction of the advanced event relay when they are enabled. And when handling an event, they check to see if this is an event type that they handle. If it is, they're going to log a message that says they handled this event from a sender, and then we're going to output the distance from the sender just to show that we can get some more information from this event system. Finally, they're going to return their name as the event handler. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The last thing we'll need is the <b>Advanced Event Relay</b>:
            <pre>
            <span class="glyphicon-remove"></span>public class AdvancedEventRelay : MonoBehaviour {

                public delegate string EventAction(EventMessageType type, MonoBehaviour sender);
                public static event EventAction OnEventAction;

                public enum EventMessageType {
                    StructureDamage,
                    StructureBuilt,
                    StructureDestroyed,
                    UnitDamage,
                    UnitBuilt,
                    UnitDestroyed
                }

                public static string RelayEvent(EventMessageType messageType, MonoBehaviour sender) {
                    return OnEventAction(messageType, sender);
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Scene Setup</b>
            <p><span class="glyphicon-remove"></span>Create a new cube named Broadcaster with the Event Broadcaster script attached.</p>
            <p><span class="glyphicon-remove"></span>Create a new sphere named Sphere Down with the Event Move Listener attached.
            <br>Set Event Move Direction to (0, -1, 0)</p>
            <p><span class="glyphicon-remove"></span>Create a new sphere named Sphere Up with the Event Move Listener attached.
            <br>Set Event Move Direction to (0, 1, 0)</p>
            <p><span class="glyphicon-remove"></span>Create a new empty called GUI Event Listener and attach the Event GUI Listener script.
            <br>Set Message To Display to "Event recieved!", and Seconds To Show to 3.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Event systems are a great flexible way to communicate between objects without the objects even needing to know about each other in advance, or at all. It's important to note that there's not just one way to create event systems. There are dozens of ways to implement event systems and many different ways to use each implementation. However, event systems, in some form or another, are a very important aspect of game design. Without events, game objects come to rely heavily on each other, and changing one object can have a cascade effect throughout a number of objects. Messaging systems help reduce special case coding, improve seperation of game logic and user interface, and keep objects independent of each other.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="3">
    <h2>Saving and Loading Games</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we'll cover saving the state of a game to disk for later loading, commonly referred to as saving and loading a game. There's not built-in functionality for adding a saved game in Unity because saving a game is unique to the game. Each game has a different set of data that needs to be saved and loaded to represent the game state. This lesson will cover both PC and mobile games as well as web. There is a distinction between the two because web games are a more limited platform. In this case with tighter security. We don't have the same freedom to read and write files on the system when using web.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Since saving is so specific for each game, in this lesson we're going to focus on the general techniques used to serialize object. Lets start of with our <b>Save Load Simple Object</b> script:
            <pre>
            <span class="glyphicon-remove"></span>//using UnityEngine, System.IO;

            public class SaveLoadSimpleObjects : MonoBehavior {
                public string saveFile = @"SaveFile.save";

                void Update() {
                    if(Input.GetKeyDown(KeyCode.L)) {
                        ReadSimpleObjects();
                    }
                    if(Input.GetKeyDown(KeyCode.S)) {
                        WriteSimpleObject();
                    }
                }

                void ReadSimpleObjects() {
                    if(File.Exists(saveFile)) {
                        using(FileStream fs = File.OpenRead(saveFile)) {
                            BinaryReader fileReader = new BinaryReader(fs);
                            int simpleObjectCount = fileReader.ReadInt32();
                            for(int simpleCount = 0; simpleCount < simpleObjectCount; simpleCount++) {
                                GameObject simpleObject = new GameObject();
                                SimpleObject simpleScript = simpleObject.AddComponent&lt;SimpleObject&gt;();
                                simpleScript.ReadObjectState(fileReader);
                            }
                        }
                    }
                }

                void WriteSimpleObjects() {
                    //using statement will dispose of the object inside when we're done using it.
                    //This is important for objects like files that we don't want to leav open.
                    using(FileStream fs = File.OpenWrite(saveFile)) {
                        SimpleObject[] simpleObjects = UnityEngine.Object.FindObjectsOfType&lt;SimpleObject&gt;();
                        BinaryWriter fileWriter = new BinaryWriter(fs);
                        fileWriter.Write(simpleObjects.Length);
                        foreach(SimpleObject simpleObject in simpleObjects) {
                            simpleObject.WriteObjectState(fileWriter);
                        }
                    }
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this script we have a save/load simple object class. It's going to handle saving and loading for us. In this case, when writing simple objects, which are a type of object in our scene, we're going to open a file, collect a list of all the simple objects in the scene. Create a new BinaryWriter and write the number of objects that we have. And then each object in our list is going to write its own state.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Now let's check out or <b>Simple Object</b> script that will be attached to objects that we want to be saved or loaded.:
            <pre>
            <span class="glyphicon-remove"></span>//using UnityEngine, System.IO;

            public class SimpleObject : MonoBehaviour {

                public string aStringObject = "test";
                public float aFloatValue = 43.2f;

                public void WriteObjectState(BinaryWriter binaryWriter) {
                    //Get all the subObjects that are children of this object.
                    SimpleSubObject[] subObjects = this.transform.GetComponentsInChildren&lt;SimpleSubObject&gt;();
                    //Write out how many objects there are, so we know how many to read in later
                    binaryWriter.Write(subObjects.Length);

                    //Each object is responsible for writing it's own state
                    foreach(SimpleSubObject subObject in subObjects) {
                        subObject.WriteObjectState(binaryWriter);
                    }

                    //Now write our own state
                    binaryWriter.Write(aStringObject);
                    binaryWriter.Write(aFloatValue);

                    binaryWriter.Write(this.gameObject.name);
                }

                public void ReadObjectState(BinaryReader binaryReader) {
                    //Get the subObjects count
                    int simpleSubCount = binaryReader.ReadInt32();
                    for(int subCount = 0; subCount < simpleSubCount; subCount++) {
                        GameObject simpleSub = new GameObject();
                        SimpleSubObject simpleSubScript = simpleSub.AddComponent&lt;SimpleSubObject&gt;();
                        simpleSubScript.ReadObjectState(binaryReader);
                        simpleSub.transform.parent = this.transform;
                    }

                    this.aStringObject = binaryReader.ReadString();
                    this.aFloatValue = binaryReader.ReadSingle();

                    this.gameObject.name = binaryReader.ReadString();
                }

                public void WriteObjectState_Web(string prependKey) {
                    //Get all the subObjects that are children of this object
                    SimpleSubObject[] subObjects = this.transform.GetComponentsInChildren&lt;SimpleSubObjects&gt;();
                    //Write out how many objects there are, so we know how many to read in later
                    PlayerPrefs.SetInt(prependKey + "subObjectCount", subObjects.Length);

                    //Each object is responsible for writing its own state.
                    //Maintain a subCount variable to add distinction between objects
                    int subCount = 0;
                    foreach(SimpleSubObject subObject in subObjects) {
                        subObject.WriteObjectState_Web(prependKey + subCount++);
                    }

                    PlayerPrefs.SetString(prependKey + "aStringObject", aStringObject);
                    PlayerPrefs.SetFloat(prependKey + "aFloatValue", aFloatValue);

                    PlayerPrefs.SetString(prependKey + "objectName", this.gameObject.name);
                }

                public void ReadObjectState_Web(string prependKey) {
                    //Get the subObjects count
                    int simpleSubCount = PlayerPrefs.GetInt(prependKey + "subObjectCount");
                    for(int subCount = 0; subCount < simpleSubCount; subCount++) {
                        GameObject simpleSub = new GameObject();
                        SimpleSubObject simpleSubScript = simpleSub.AddComponent&lt;SimpleSubObject&gt;();
                        simpleSubScript.ReadObjectState_Web(prependKey + subCount);
                        simpleSub.transform.parent = this.transform;
                    }

                    this.aStringObject = PlayerPrefs.GetString(prependKey + "aStringObject");
                    this.aFloatValue = PlayerPrefs.GetFloat(prependKey + "aFloatValue");

                    this.gameObject.name = PlayerPrefs.GetString(prependKey + "objectName");
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We'll also need to cover the <b>Simple Sub Object</b> script attached to sub objects:
            <pre>
            <span class="glyphicon-remove"></span>using UnityEngine, System.IO;

            public class SimpleSubObject : MonoBehaviour {

                public string subString = "this is a sub string";
                public int valueX = 43;
                public byte valueB = 2;

                public void WriteObjectState(BinaryWriter binaryWriter) {
                    //write our own state
                    binaryWriter.Write(subString);
                    binaryWriter.Write(valueX);
                    binaryWriter.Write(valueB);

                    binaryWriter.Write(this.gameObject.name);
                }

                public void ReadObjectState(BinaryReader binaryReader) {

                    this.subString = binaryReader.ReadString();
                    this.valueX = binaryReader.ReadInt32();
                    this.valueB = binaryReader.ReadByte();

                    this.gameObject.name = binaryReader.ReadString();
                }

                public void WriteObjectState_Web(string prependKey) {
                    PlayerPrefs.SetString(prependKey + "subString", subString);
                    PlayerPrefs.SetInt(prependKey + "valueX", valueX);
                    PlayerPrefs.SetInt(prependKey + "valueB", valueB);
                    PlayerPrefs.SetString(prependKey + "objectName", this.gameObject.name);
                }

                public void ReadObjectState_Web(string prependKey) {
                    subString = PlayerPrefs.GetString(prependKey + "subString");
                    valueX = PlayerPrefs.GetInt(prependKey + "valueX");
                    valueB = (byte)PlayerPrefs.GetInt(prependKey + "valueB");
                    this.gameObject.name = PlayerPrefs.GetString(prependKey + "objectName");
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's go through the writing process. WriteObjectState is going to accept that BinaryWriter we created before and it's going to collect a list of its children, and write the number of it's children, then each of it's children are going to write their own state. This is a typical pattern when doing recursive serialization. Each object will be responsible for writing its own state when called upon. Finally, this object is going to write its own state at the end. Let's go one deeper and take a look at the sub object writing its own state. The sub object has no sub objects of its own so it's just going to write its own state and then return.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's move on to the reading process. When reading a save file we're going to open our file, create a new binary reader. And from the file, we're going to get the number of objects we need to read. And for each of those objects, we're going to create a new object, create a new script and then have that script read its own state from the file. When an object is reading its own state from the file, it's going to get the number of sub-objects it has. And for each of those sub objects create a new game object and create a new component. Then that component is going to read its own state. As you can see this is identical to the write procedure where we write the number of objects and then each object writes it's own state. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Saving and loading are going to be mirror images of each other. Because when writing state in this way, the data is in a precise order to make reading and writing simple. This means data is byte for byte exactly in the same order when we save and load. If we're off by one byte we'll throw off the entire sequence. The web version of this is nearly identical, except the web version is limited to a dictionary key system. When using the web player, we have restricted access to the hard drive. We can only access the player preferences file. This is limited to one megabyte. Data is stored by a string reference and we can only store strings, floats or ints. It's possible to abuse this system to utilize the same method as we did before, creating a key structure to allow us to set unique keys for each object.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this case we're going to do the same thing where we get the number of sub objects, write the number of sub objects to the player preferences file, and then for each sub object, they will write their own state to the player preferences file. This is not an ideal system for web games since we are limited to one megabyte and can only store strings, floats, and ints. In a web environment the ideal situation would be to use a database. A similar tactic for data can be used in databases. We can break apart the serialization by object and store into tables, or it can combine together into a single binary data block.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Scene Setup</b>
            <p><span class="glyphicon-remove"></span>Create an empty called The Simple Save Loader and attach the Save Load Simple Objects script.
            <br>Set Save File to Assets\SaveFile.save</p>
            <p><span class="glyphicon-remove"></span>Create a new empty called Simple One and attach the Simple Object script.
            <br>Set A String Object to "First test string", and A Float Value to 23445.
            <br>Create as a child, an empty called SubSimple with the Simple Sub Object script attached.
            <br>Set Sub String to "Simple one sub simpler", Value X to 573452, and Value B to 9.</p>
            <p><span class="glyphicon-remove"></span>Create a new empty called Simple Two and attache the Simple Object script.
            <br>Set A String Object to "TwoSimple", and A Float Value to 2345.456
            <br>Create as a child, an empty called Sub Simple, with the Simple Sub Object attached.
            <br>Set Sub String to "Simple two sub simple", Value X to 364562, and Value B to 4
            <br>Create as a second child, an empty called Sub Simple 2 with the Simple Sub Object attached.
            <br>Set Sub String to "Simple two sub simple", Value X to 364562, and Value B to 4</p>
            <p><span class="glyphicon-remove"></span>Create a new empty called Simple Three with the Simple Object script attached.
            <br>Set A String Object to "Three", and A Float Value to 43.2.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we've covered a simple strategy for saving games. There are a lot of different strategies for saving games, and they vary depending on the game type, game mechanics requirements, and even the devlopers personal style. Some games will only ever need to save the high score because the game state doesn't persist beyond that. Other games will need to save the state of hundreds of objects, with each object having dozens of data structures that need to be saved as they are. The strategy we've covered is just one of many. Choosing the right strategy for your game is an important decision that only you can make.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="4">
    <h2>Ray Casting</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Raycasting is used for lots of things in games, including projectiles, path finding, steering, visibility testing, and so on. Unity does provide some pretty robust raycasting with their physics system. However, this does require that objects have physics components, in this case, any kinds of bounding volume, like a box collider.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Raycasting has a few input parameters that allow us to control the behavior of the cast as well. For example, we can define a maximum length and a layer mask. The maximum length is fairly self explanatory, where any hits beyond the maximum distance are ignored. But the layer mask is slightly more tricky. It's a bit mask that allows us to filter what type of object we want to interact with. We'll look at some code that should make this easier to understand.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Scene Setup</b>
            <br>You'll need 4 walls made from cubes with box colliders.
            <br>Name the first two Wall 1. Name the third Wall 2. Name the last Wall 3.
            <br>Place Wall 1's next to each other with a gap. Behind those, place Wall 2. Behind that place Wall 3.
            <br>Give each numbered wall it's own layer. Ex. Wall 1's = Layer 1
            <br>Create another Cube as the "Caster" which will have our script on it.
            <br>Place this caster in front of the two Wall 1s.
            <br>Make sure Gizmos are on.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We'll be casting a ray from this cube along this forward vector. Typically rays are invisible, but we're going to draw the ray using some visual debugging. This ray currrently has a bitmask of zero. Meaning it's not going to hit anything, making it a pretty uniteresting ray. Let's see the <b>Raycaster</b> code and make the ray useful:
            <pre>
            <span class="glyphicon-remove"></span>//using UnityEngine, System.Collections.Generic, System.Text;

            public class Raycaster : MonoBehaviour {
                public float maxDistance = 10;
                public int layerMask = 0;

                public List&lt;Vector3&gt; rayHitPositions = new List&lt;Vector3&gt;;
                public List&lt;Vector3&gt; sphereHitPositions = new List&lt;Vector3&gt;;

                ComboBox layerChooser;

                void Start() {
                    layerChooser = new ComboBox();
                    layerChooser = SetAllowMultiple(true);

                    //There's no built in way to get layers, so LayerUtils was created to get the currently set layers.
                    Dictionary&lt;string, int&gt; layers = LayerUtils.GetLayers();
                    foreach(string layerName in layers.Key) {
                        layerChooster.AddItem(layerName, layers[layerName], OnLayerSelected, OnLayerUnselected);
                    }
                }

                void OnLayerSelected(ComboBox.ComboItem item) {
                    layerMask = layerMask | (1&lt;&lt;(int)item.value);
                }

                void OnLayerUnselected(ComboBox.ComboItem item) {
                    layerMask = layerMask &amp; ~(1&lt;&lt;(int)item.value);   
                }

                void Update() {
                    //Allow us to rotate the caster at 20 degrees per second
                    if(Input.GetKey(KeyCode.A)) {
                        this.transform.Rotate(Vector3.up, 20f * Time.deltaTime);
                    }

                    if(Input.GetKey(KeyCode.D)) {
                        this.transform.Rotate(Vector3.up, -20f * Time.deltaTime);
                    }

                    rayHitPositions.Clear();
                    sphereHitPositions.Clear();

                    if(Input.GetKey(KeyCode.Space)) {
                        DrawRayHitAll();
                    } else {
                        DrawRayHit();
                    }

                    //DrawRayHit();

                    //DrawRayHitAll();

                    //DrawSphereHit();

                    //DrawSphereHitAll();
                }

                /* (Summary)
                    Int to a string 1's and 0's representing the bits of the integer
                    @returns A string representing the bits of an integer
                    @param name="toConvert" - Integer to convert
                */
                string IntToBits(int toConvert) {
                    StringBuilder sb = new StringBuilder();
                    for(int index = 0; index < 32; index++) {
                        if((1&lt;&lt;index &amp; toConvert) > 0)
                            sb.Insert(0, "1");
                        else
                            sb.Insert(0, "0");
                    }

                    return sb.ToString();
                }

                //Draws a ray cast, displaying hit information
                void DrawRayHit() {
                    RaycastHit hitInfo;
                    if(Physics.Raycast(this.transform.position, this.transform.forward, out hitInfo, maxDistance, layerMask)) {
                        //We have a hit
                        Debug.DrawLine(this.transform.position, hitInfo.point, Color.red, 0.01f, true);
                        rayHitPositions.Add(hitInfo.point);
                    } else {
                        Debug.DrawLine(this.transform.position, this.transform.forward * maxDistance, Color.green, 0.01f, true);
                    }
                }

                //Raises the draw gizmos event
                void OnDrawGizmos() {
                    //Draw the hit locations
                    foreach(Vector3 rayHitPosition in rayHitPositions) {
                        Gizmos.DrawWireCube(rayHitPosition, new Vector3(1f, 0.1f, 0.1f));
                    }
                    foreach(Vector3 sphereHitPosition in sphereHitPositions) {
                        Gizmos.DrawWireSphere(sphereHitPosition, 0.5f);
                    }
                }

                //Raises the GUI event
                void OnGUI() {
                    layerChooser.Draw(GUI.skin.box, new Rect(0, 0, 110, 250));
                    GUI.Label(new Rect(130, 0, 230, 40), "LayerMask: " + IntToBits(layerMask));
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            So we'll first look at updating the layer mask. A combo box list here on the left is something being used to easily add or remove layers from the mask. As we check items in the list, our layer mask is updated, as well as our array. We can see that updating it to include Layer1, means that is will now interact with Layer1 object, which both of these one walls are set to Layer 1.
            <br>In Unity there is no built in way to get a list of all the layers, so we've created a get layers method here. That will go through and create a dictionary of the layer names along with their layer value. The Raycaster is going to get a list of all those layers and add them to our Combo Box so that when we select and item, we can OR our current layer mask with the value of the layer mask selected. The layer value stored is the placement of the bit for that layer mask.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We then need to create a new integer by shifting one over at that value, and OR it with our layer maks. So for example the default layer mask is zero. So by adding it to our layer mask we are going to take one and bit-shift it by zero, which means it is going to stay here at the first position. Traparent FX is going to have a value of one, so we're going to take a one, we're going to shift it into our layer mask by one, resulting int this one here. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            So how about hitting multiple objects, by default the array will stop at the first layer that it interacts with. However there is an option to cast array to collect all of the hits that array interacts with. Let's check out that function:
            <pre>
            <span class="glyphicon-remove"></span>//Draws a ray cast, displaying multiple hit inforamtion
            void DrawRayHitAll() {
                Debug.DrawLine(this.transform.position, this.transform.forward * maxDistance, Color.green, 0.01f, true);
                RaycastHit[] hits = Physics.RaycastAll(this.transform.position, this.transform.forward, maxDistance, layerMask);
                if(hits.Length > 0) {
                    foreach(RaycastHit hit in hits) {
                        //We have a hit(s)
                        Debug.DrawLine(this.transform.position, hit.point, Color.red, 0.1f, true);
                        rayHitPositions.Add(hit.point);
                    }
                }
            }
            </pre>
            <p><span class="glyphicon-remove"></span>With this method, we can now interact with multiple layers, and see all of the objects that have been hit. This might be useful if you're shooting a projectile that can go through walls.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Further, one of the other uses I mentioned for Raycasting is path finding. And that might be to see if we can fit our object through a certain area. To do that, we might want to cast a sphere that's the size of the object, to see if it will fit. Let's see that function:
            <pre>
            <span class="glyphicon-remove"></span>//Draws the sphere hit
            void DrawSphereHit() {
                RaycastHit hitInfo;
                if(Physics.SphereCast(this.transform.position, 0.5f, this.transform.forward, out hitInfo, maxDistance, layerMask)) {
                    //We have a hit
                    Debug.DrawLine(this.transform.position, hitInfo.point, Color.red, 0.01f, true);
                    sphereHitPosition.Add(hitInfo.point);
                } else {
                    Debug.DrawLine(this.transform.position, this.transform.forward * maxDistance, Color.green, 0.01f, true);
                }
            }
            </pre>
            <p><span class="glyphicon-remove"></span>Here we're going to cast a sphere, and we're going to see if that sphere will fit through a gap. Here we can see a cylinder acting at the edge, and there we see the ray is now cast through this gap, allowing the sphere to fit. It's could be a close or far gap depending on the scene setup. Additionally, just like the multiple hits for a single ray, there's also a multiple hit for the sphere ray. This might be useful if you're creating a very large projectile, and you want to destroy multiple objects along it's path.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this section we've covered using raycasting functions in Unity. We also discussed some uses for rays. Raycasting is a powerful tool when making decisions in your game. And with plenty of cases, it's likely to make an apprearance in your games. The Raycast in Unity does use the physics system. So be sure to add a collider and layer information to any game object you'd like it to interact with using a ray.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="5">
    <h2>Mini Maps</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section we'll go over adding a mini map to your game. This mini map updates live with the scene and is centered on the players character. Mini maps are frequently used to help guide players to specific locations or just help them find their way around. Many include additional information that's not displayed in the game world, such as areas of interest or quest markers. In the scene, it will be easy to add the map to your scene simply by adding an additional camera to your scene. This camera will sit above the player character, rendering a wider view of the scene and witht the use of layers, we can add additional information to the minimap that's not displayed in the main camera. Lets take a look at the scene.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Scene Setup</b>
            <p><span class="glyphicon-remove"></span>Add 4 floor 2x0.5x2 blocks on the floor in random positions. Set all to Layer 1</p>
            <p><span class="glyphicon-remove"></span>Create 10x10x1 "MiniMapZone" box collider with the image of your interesting location on it using a "Legacy Shaders/Transparent/Diffuse" material with your image attached. Make the collider tall. Make it's layer "MiniMap". This object will have attached our "ZoneOfIntrigue" script.</p>
            <p><span class="glyphicon-remove"></span>Create a 1x1x1 "Character" box collider. Make it's layer "Ignore Raycast". Attach a rigidbody. This will have attached our "MoveTowardsClick" script, and our "MiniMap" script.</p>
            <p><span class="glyphicon-remove"></span>Make the Camera a child of the Character and rotate to (90, 0, 90) and position above the character. Make the tag "MainCamera" and keep in perspective mode with a field of view at 36.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Resources</b>
            <p><span class="glyphicon-remove"></span>characterIconImage (25x25 png) - Red circle. Default import settings.</p>
            <p><span class="glyphicon-remove"></span>CharacterIconMaterial (LegacyShaders/Transparent/VertexLit) - Has the characterIconImage attached. Default import settings.</p>
            <p><span class="glyphicon-remove"></span>CharacterIcon (Prefab) - Layer: "MiniMap", Transform: pos(0,0,0) rot(90,0,0) scale(2,2,1), Quad Mesh, Mesh Renderer (Character Icon Material).</p>
            <p><span class="glyphicon-remove"></span>MiniMapBorder (24x24 png) - White box, Black border. Default import settings.</p>
            <p><span class="glyphicon-remove"></span>ZoneOfIntrigue (24x24 png) - White box, Red border, patterned red corners. Default import settings.</p>
            <p><span class="glyphicon-remove"></span>ZoneOfIntriqueMaterial (LegacyShaders/Transparent/Diffuse) - Has the ZoneOfIntrigue attached. Default import settings.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's now take a look at our <b>Mini Map</b> script:
            <pre>
            <span class="glyphicon-remove"></span>public class MiniMap : MonoBehaviour {

                Camera miniMapCamera;

                public float viewSize = 10f;
                public Vector2 positionOnScreen = new Vector2(0f, 0f);
                public Vector2 size = new Vector2(200f, 150f);
                Texture2D miniMapBorder;
                Rect miniMapRectangle;
                Rect miniMapGUIBorder;
                public bool transparent;

                void Start() {
                    miniMapRectange = new Rect(positionOnScreen.x, (Screen.height - positionOnScreen.y) - size.y, size.x, size.y);
                    miniMapGUIBorder = new Rect(positionOnScreen.x - 5, positionOnScreen.y - 5, size.x + 10, size.y + 10);
                    GameObject miniCam = new GameObject("MiniMapCamera", typeof(Camera));
                    miniMapCamera = miniCam.GetComponent&lt;Camera&gt;();
                    SetupMinimapCamera();

                    GameObject characterIcon = GameObject.Instantiate(Resources.Load("CharacterIcon") as GameObject) as GameObject;
                    characterIcon.transform.parent = this.transform;

                    miniMapBorder = Resrouces.Load("MinimapBorder") as Texture2D;
                }

                private void SetupMinimapCamer() {
                    miniMapCamera.transform.parent = this.transform;
                    miniMapCamera.transform.position = new Vector3(0f, 20f, 0f);
                    miniMapCamera.transform.Rotate(Vector3.right, 90f);
                    miniMapCamera.orthographic = true;
                    miniMapCamera.orthographicSize = viewSize;

                    int layerMask = 0;
                    layerMask |= 1<&lt;&lt;LayerMask.NameToLayer("MiniMap");
                    layerMask |= 1&lt;&lt;LayerMask.NameToLayer("Layer1");

                    miniMapCamera.cullingMask = layerMask;

                    //Convert to viewport coordinates (i.e. 0,0 bottom left, 1,1 top right)
                    miniMapCamera.rect = new Rect(miniMapRectangle.x/Screen.width, miniMapRectangle.y/Screen.height,
                                                    miniMapRectangle.width/Screen.width, miniMapRectangle.height/Screen.height);
                }

                void Update() {
                    //We're simply putting this here so we can see it change live in the demo
                    //Ideally it would go in the setup method above.
                    if(transparent)
                        miniMapCamera.clearFlags = CameraClearFlags.Depth;
                    else
                        miniMapCamera.clearFlags = CameraClearFlags.Skybox;
                }

                void OnGUI() {
                    GUI.DrawTexture(miniMapGUIBorder, miniMapBorder);
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We're going to start by creating a game object, with a component of camera. And then setup that minimap camera by making a child of this object, setting its position above the character. Rotating it, so that it's pointing down, and setting it to an orthographic camera so we don't have the perspective view. Next we're going to add some layer masks to ensure that it shows the extra information we want from the mini map. Finally, we're going to change the view rectangel, so it's in the top left and smaller. In the scene you can see it's in the top left and smaller. And it has a black border around it, which was added as a GUI texture. We can see that we have a different icon for our player in the mini map than we do in the real world. And there's also a red box displayed in the mini map, or a "zone of intrigue", thats not displayed in the game world. The character icon in the mini map is simply an additional object that's rendering a red circle in the mini map layer. This mini map zone is simply a box collider that has a red rectangle, rendered in the mini map layer using a mesh renderer.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's view the <b>Zone of Intrigue</b> code:
            <pre>
            <span class="glyphicon-remove"></span>public class ZoneOfIntrigue : MonoBehaviour {
                void OnTriggerEnter(Collider other) {
                    Debug.Log("Intrigued...");
                }
            }
            </pre>
            <p><span class="glyphicon-remove"></span>This has some detection code, so that when entering the box collider we are displaying a message. At the moment, the minimap also displays a background. We can disable this by checking the Transparent boolean on the minimap camera, allowing us to see through the background. That's done using clear flags, which we can see here, or we can either clear the depth, or we can clear with sky box. Clearing the depth makes it transparent, as there is nothing beyond the background here.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            A little extra script here is the <b>Move Towards Click</b> script:
            <pre>
            <span class="glyphicon-remove"></span>public class MoveTowardsClick : MonoBehaviour {

                Vector3 targetPosition;

                //Speed, in units per second, we want to move towards the target
                public float speed = 5f;

                public bool holdToFollow = true;

                public bool targetSet = false;

                public float stoppingAccuracy = 2f;

                public MouseUtils.Button respondToMouseButton = MouseUtils.Button.Left;

                void Update() {
                    if(holdToFollow) {
                        if(Input.GetMouseButton((int)respondToMouseButton)) {
                            //mouse has been clicked, update position
                            //use the objects current depth, so we can move around on a 2D plane
                            targetPosition = GetMouseAtObjectDepth();
                            //make sure we "turn on" the movement
                            targetSet = true;
                        }
                    } else {
                        if(Input.GetMouseButtonDown((int)respondToMouseButton)) {
                            //mouse has been clicked, update position
                            //use the objects current depth, so we can move around on a 2D plane
                            targetPosition = GetMouseAtObjectDepth();
                            //make sure we "turn on" the movement
                            targetSet = true;
                        }
                    }

                    MoveTowardsTarget();
                }

                //Get position of the mouse at the depth of an object
                Vector3 GetMouseAtObjectDepth() {
                    //Find the depth into the scene, the distance won't work here because objects
                    // directly in front of the camera are closer than object at the edge of the screen.
                    //So we'll get the vector that points to the object, then use the dot product to see
                    // how much of that overlaps with the forward heading of the camera.
                    //Get the vector from the camera to the object
                    Vector3 headingToObject = this.transform.position - Camera.main.transform.position;
                    //Find the projection on the forward vector of the camera.
                    float depth = Vector3.Dot(headingToObject, Camera.main.transform.forward);
                    return GetMouseAtSpecifiedDepth(depth);
                }

                Vector3 GetMouseAtSpecifiedDepth(float depth) {
                    Vector3 mouseScreenPosition = Input.mousePosition;
                    mouseScreenPosition.x = depth;
                    Vector3 mouseWorldPosition = Camera.main.ScreenToWorldPoint(mouseScreenPosition);
                    return new Vector3(mouseWorldPosition.x, mouseWorldPosition.y, mouseWorldPosition.z);
                }

                public void OnDrawGizmos() {
                    if(targetSet) {
                        //Show a line from our current position to the target position
                        Gizmos.DrawLine(this.transform.position, targetPosition);

                        //Show us where the minimum stopping distance is
                        Gizmos.DrawWireSphere(targetPosition, stoppingAccuracy);
                    }
                }

                //Move towards a target at a set speed
                private void MoveTowardsTarget() {
                    //only do work if we have a valid target
                    if(targetSet) {
                        Vector3 currentPosition = this.transform.position;

                        //First, check to see if we're close enough to the target
                        //This check prevents us from oscillating back and forth over the target
                        //If we're farther than 1 unit away, do the movement, otherwise don't
                        if(Vector3.Distance(currentPosition, targetPosition) > stoppingAccuracy) {
                            //Get the direction we need to go by subtracting the current position from the target position
                            Vector3 directionOfTravel = targetPosition - currentPosition;

                            //Now normalize the direction, since we only want the direction information
                            directionOfTravel.Normalize();

                            this.transform.Translate(
                                    (directionOfTravel.x * speed * Time.deltaTime),
                                    (directionOfTravel.y * speed * Time.deltaTime),
                                    (directionOfTravel.z * speed * Time.deltaTime),
                                    Space.World);
                        } else {
                            //We've completed the move, indicate we're done by turning off targetSet
                            targetSet = false;
                        }
                    }
                }

                public override string ToString() {
                    return string.Format("[MoveTowardsClick]: " + targetPosition + " @ "
                                            + speed + "m/s, target set: " + targetSet);
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We're not limited to a top down perspective with our mini map camera. It can be pointed any direction and could even be a first person or rear view camera for a racing game. In this section, we've covered a strategy for creating a mini map camera. The mini map is an important feature for many games, and can be useful for showing additional information, without cluttering up the game world.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="6">
    <h2>Dynamic Meshes</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section we're going to go over creating dynamic meshes with scripts. Creating meshes on the fly is a foundation of a number of modern games. For example, creating meshes at runtime allows us to create proceduraly generated terrain, or destructible environments. Meshes are, at a very basic level, composed of points, in 3D space, along with the instructions on how to connect the dots, and what colors to use when doing that. The primary buildilng blocks of meshes are vertices. The most basic vertices is just to find a point in 3D space.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The instructions for constructing a mesh, are list of indices that define the order of the vertices. At a minimum, a mesh needs three vertices to form a triangle. The simplest 3D shape available for drawing. Let's see our <b>Dynamic Mesh Interface</b> code:
            <pre>
            <span class="glyphicon-remove"></span>//using UnityEngine, System.Collections.Generic;

            [RequireComponent (typeof(MeshFilter))]
            [RequireComponent (typeof(MeshRenderer))]
            [AddComponentMenu("Mesh/Dynamic Mesh Generator")]
            public class DynamicMeshInterface : MonoBehaviour {

                //Clockwise winding order defines the front of the vertex

                List&lt;Vector3&gt; triangleVertices = new List&lt;Vector3&gt;() {
                    new Vector3(0, 0, 0), new Vector3(0, 1, 0), new Vector3(1, 1, 0)
                };

                List&lt;Vector3&gt; quadVertices = new List&lt;Vector3&gt;() {
                    new Vector3(0, 0, 0), new Vector3(0, 1, 0), new Vector3(1, 1, 0), new Vector3(1, 0, 0)
                };

                List&lt;GameObject&gt; customShape = new List&lt;GameObject&gt;();

                bool regenerateCustom = false;

                void Update() {
                    if(Input.GetKeyDown(KeyCode.Alpha1)) {
                        ApplyMesh(triangleVertices);
                    }

                    if(Input.GetKeydown(KeyCode.Alpha2)) {
                        ApplyMesh(quadVertices);
                    }

                    if(Input.GetKeyDown(Keycode.Alpha3)) {
                        AddPointToScene(MouseUtils.GetMouseWorldPositionAtDepth(10));
                    }

                    if(Input.GetKeyDown(KeyCode.Alpha4)) {
                        foreach(GameObject point in customShape)
                            GameObject.Destroy(point);
                        customShape.Clear();
                        regenerateCustom = true;
                    }

                    if(Input.GetMouseButton((int)MouseUtils.Button.Left)) {
                        regenerateCustom = true;
                    }

                    if(regenerateCustom) {
                        List&lt;Vector3&gt; customPoints = new List&lt;Vector3&gt;();
                        foreach(GameObject go in customShape)
                            customPoints.Add(go.transform.position);

                        ApplyMesh(customPoints);
                        regenerateCustom = false;
                    }
                }

                void ApplyMesh(List&lt;Vector3&gt; vertices) {
                    Mesh mesh = DynamicMeshGenerator.GenerateMesh(vertices);
                    GetComponent&lt;MeshFilter&gt;().mesh = mesh;
                }

                void AddPointToScene(Vector3 point) {
                    GameObject newPoint = GameObject.CreatePrimitive(PrimitiveType.Sphere);
                    newPoint.transform.position = point;
                    newPoint.transform.localScale = new Vector3(.3f, .3f, .3f);
                    MouseDragObject mdo = newPoint.AddComponent&lt;MouseDragObject&gt;();
                    customShape.Add(newPoint);
                    regenerateCustom = true;
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            So we've added some attribtes to this model behaviour you may have not seen before. We have some attributes that both require components. This means that when this component is added to the object, these components will also be added, we can't remove these components without first removing this one.
            <p><span class="glyphicon-remove"></span>Next theres an add component menu attribute. This is going to add this component to a specific spot under the Add Component menu, under Mesh/Dynamic Mesh Generator. So we have our dynamic mesh object in our, Add Component menu under Mesh/Dynamic Mesh Generator. We're going to see that mesh filter and mesh renderer were automatically added when we added our dynamic mesh interface.</p>
            <p><span class="glyphicon-remove"></span>Next we're going to set a material so we have something to look at when these meshes get generated, and we can see some simple meshes.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The most simple mesh we'll make is just one triangle. And this list of Vector3s dedfines the points in 3D space that would make a traingle. We can see this with our first template which generates a traignel using the vertices defined in it's list. Number two generates a quad using the vertices defined in it's quad list. It is important to note that these vertices need to be defined in clockwise winding order. That's clockwise winding order when viewing the triangle from the front.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            So what's happening when this mesh is generated? When the number one key is pressed we're passing in our triangle vertices list into the Applymesh method. The Applymesh method, takes lists of vertices and generates a mesh based on those vertices. That mesh generation process is essentially just taking our list of vertices and we're going to create a new list of integers. This list of integers, is going to be indexes into the vertex array.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The mesh generator supports both quads and triangles. In the case of quads, we're just going to look for a number of vertices that  is divisible by four, if it is, we'll attempt to make quads. In this case, quads is just going to take four vertices and create two triangles, at indices 012 and 023. Otherwise we're going to create a triangle. And that's just going to create indexes into the vertex array, at 0, 1, and 2.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Next we're going to create texture coordinates, in this case it's just going to be 0s because we're not going to support any textures in this mesh generator. Finally we create a new mesh, and add our vertices to it, along with the indices defining the triangles. Then take the texture coordinates we created and recalculate the normals and the bounds, then return a mesh to set to our mesh filter to be displayed on screen. Now that we've seen meshes generated with these predefined lists, let's see how we can make up our own at runtime.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Using the number three key, we can place vertices in the world. These are going to be represented by spheres that we can move around. So placing three vertices, will draw us a trianble. If you hit four, you'll clear and you can see the order that I defined these vertices in a counter clockwise direction. We actually don't see a mesh. It's still being generated but it's not visible from this side. This is called <b>back face culling</b> and it's done to save rendering time.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We can see if we go to the scene view, and look at the other side. This is the camera over here, looking towards us. The opposite of this mesh is rendered here. We can change the winding order by, moving instead of one way, to a better position so it will be clockwise.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We're also supporting quads, which is simply two triangles. If we wanted to create a more complex mesh, we can see that we can overlap vertices, to create more complex shapes. Always making sure to define the vertices in clockwise order. If we add more, we'll start to disappear in the middle because now it's divisible by three, so we're attempting to create triangles. And that's not how our vertices are laid out. Put down one more and then we are again divisible by four, and we can create quads again.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Points will overlap, and that is fine because we can't share all of our points with each triangle, since this is more than just a position. Texture data and normals for lighting are also contained within the vertices. This system will need some experimenting to get used to but it is very powerful once figured out.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Scene Setup</b>
            <p><span class="glyphicon-remove"></span>Create a new empty called Dynamic Mesh Object and attach the Dynamic Mesh Interface script.
            <br>Set the Material to whatever material you would like.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this section we've gone over how to generate meshes at runtime. This opens up a number of possibilities for various types of gameplay and reducing content creation to algorithms. We saw that meshes are composed of vertices, and the order thaat they're defined does matter. We should define the vertices clockwise from the direction we want to view them in.
            <p><span class="glyphicon-remove"></span>Using the knowledge learned here, we can create procedurally generated meshes, or destructible terrain. Procedural generation doesn't just mean meshes that can be modified or random for everyone. The terrain objects generated could be the same for everyone and static. However, instead of defining all the vertices in a content generation program, like Blender or 3D Studio Max, we could define a series of algorithms and formulas that generate the mesh during runtime.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="7">
    <h2>Quad Tree</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section we're going to go over how to create and use a Quad Tree. Quad trees are frequently used in game development. Their most common use is for spatial partitioning. Spatial partitioning is a technique for dividing a game world into logical nodes. Quad trees, as the name implies, divide into four when split. The division of nodes allows for faster operations like finding nearby objects or culling a scene for visibility. Each node contains some kind of object. In our case, we'll fill them with game objects. This will allow us to find nearby game objects quickly and easily.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Scene Setup</b>
            <p><span class="glyphicon-remove"></span>Simply create an empty "QuadTreeInterface" object and attach a "Quad Tree Interface" script.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's check out our <b>Quad Tree</b> class:
            <pre>
            <span class="glyphicon-remove"></span>public class QuadTree {

                static int childCount = 4;
                static int maxObjectCount = 100;
                static int maxDepth;

                //Used for visual debugging/demonstration
                private bool searched = false;

                private QuadTree nodeParent;
                private QuadTree[] childNodes;

                private List&lt;GameObject&gt; objects = new List&lt;GameObject&gt;();

                private int currentDepth = 0;

                private Vector2 nodeCenter;
                private Rect nodeBounds = new Rect();

                private float nodeSize = 0f;

                public QuadTree(float worldSize, int maxNodeDepth, int maxNodeObjects, Vector2 center) : this(worldSize, 0, center, null) {
                    maxDepth = maxNodeDepth;
                    maxObjectCount = maxNodeObjects;
                }

                private QuadTree(float size, int depth, Vector2 center, QuadTree parent) {
                    this.nodeSize = size;
                    this.currentDepth = depth;
                    this.nodeCenter = center;
                    this.nodeParent = parent;

                    if(this.currentDepth == 0) {
                        this.nodeBounds = new Rect(center.x - size, center.y - size, size*2, size*2);
                    } else {
                        this.nodeBounds = new Rect(center.x - (size/2), center.y - (size/2), size, size);
                    }
                }

                public bool Add(GameObject go) {
                    if(this.nodeBounds.Contains(go.transform.position)) {
                        return this.Add(go, new Vector2(go.transform.position.x, go.transform.position.y)) != null;
                    }
                    return false;
                }

                private QuadTree Add(GameObject obj, Vector2 objCenter) {
                    if(this.childNodes != null) {
                        // Four nodes
                        //  ^ z plus
                        //  [2][3]
                        //  [0][1]   > x plus
                        //

                        int index = (objCenter.x < this.nodeCenter.x ? 0 : 1)    //Add one to select between 3,1. Add zero to select between 2, 0.
                                    + (objCenter.y < this.nodeCenter.y ? 0 : 2); // Add two to select between 2,3. Add zero to select between 0,1.

                        return this.childNodes[index].Add(obj, objCenter);
                    }

                    //We've reached a root
                    if(this.currentDepth < maxDepth &amp;&amp; this.objects.Count + 1 > maxObjectCount) {
                        //If adding this object puts this node past its limit, and we're not at the 
                        // maximum depth, split this node and redistribute its object to its children.
                        Split(nodeSize);
                        foreach(GameObject nodeObject in objects) {
                            Add(nodeObject);
                        }
                        this.objects.Clear();

                        //And don't forget to add the object that cause us to split!
                        return Add(obj, objCenter);
                    } else {
                        //Otherwise just add this object to this node pool
                        this.objects.Add(obj);
                    }

                    return this;
                }

                public bool Remove(GameObject obj) {
                    if(objects.Contains(obj)) {
                        objects.Remove(obj);
                        return true;
                    } 
                    else if(childNodes != null) {
                        foreach(QuadTree child in childNodes) {
                            if(child.Remove(obj))
                                return true;
                        }
                    }
                    return false;
                }

                private void Split(float parentSize) {
                    this.childNodes = new QuadTree[QuadTree.childCount];
                    int depth = this.currentDepth + 1;
                    float quarter = parentSize / 4f;

                    this.childNodes[0] = new QuadTree(parentSize/2, depth, this.nodeCenter + new Vector2(-quarter, -quarter), this);
                    this.childNodes[1] = new QuadTree(parentSize/2, depth, this.nodeCenter + new Vector2(quarter, -quarter), this);
                    this.childNodes[2] = new QuadTree(parentSize/2, depth, this.nodeCenter + new Vector2(-quarter, quarter), this);
                    this.childNodes[3] = new QuadTree(parentSize/2, depth, this.nodeCenter + new Vector2(quarter, quarter), this);
                }

                public GameObject FindNearest(Vector3 position) {
                    return FindNearest(position.x, position.y, positon.z);
                }

                public GameObject FindNearest(float x, float y, float z) {
                    double maxDistance = double.MaxValue;
                    return FindNearest(x, y, z, ref maxDistance);
                }

                private GameObject FindNearest(float x, float y, float z, ref double shortestDistance) {
                    GameObject closest = null;

                    //Reached a root node, check its objects
                    if(childNodes == null) {
                        searched = true;
                        //We're a root node, check the objects we have
                        foreach(GameObject obj in objects) {
                            double distance = Mathf.Sqrt(
                                Mathf.Pow(x - obj.transform.position.x, 2.0f) + 
                                Mathf.Pow(y - obj.transform.position.y, 2.0f) +
                                Mathf.Pow(z - obj.transform.position.z, 2.0f));

                            if((distance > shortestDistance))
                                continue;

                            shortestDistance = distance;
                            closest = obj;
                        }
                        return closest;
                    }

                    //Keep stepping into the children until we reach a root (above)
                    foreach(QuadTree child in childNodes) {
                        double childDistance = GeneralUtils.DistanceToRectEdge(child.nodeBounds, x, y);
                        if(childDistance > shortestDistance)
                            continue;

                        GameObject tmpObject = child.FindNearest(x, y, z, ref shortestDistance);
                        if(tmpObject != null)
                            closest = tmpObject;
                    }
                    return closest;
                }

                private QuadTree GetNodeContaining(float x, float y) {
                    if(this.childNodes != null) {
                        //Find the index of the child that contains the center of the object
                        int index = (x < this.nodeCenter.x ? 0 : 1)
                                    + (y < this.nodeCenter.y ? 0 : 2);

                        return this.childNodes[index].GetNodeContaining(x, y);
                    } else {
                        return this;
                    }
                }

                public void ClearSearch() {
                    searched = false;
                    if(childNodes != null) {
                        foreach(QuadTree child in childNodes) {
                            child.ClearSearch();
                        }
                    }
                }

                public void Clear() {
                    objects.Clear();
                    if(childNodes != null) {
                        foreach(QuadTree child in childNodes) {
                            child.Clear();
                        }
                        childNodes = null;
                    }
                }

                public void Draw() {
                    Gizmos.DrawWireCube(nodeCenter, new Vector3(nodeSize, nodeSize, 5));

                    if(searched) {
                        Gizmos.color = Color.red;
                        Gizmos.DrawWireSphere(nodeCenter, (nodeSize/2));
                        Gizmos.color = Color.white;
                    }

                    if(childNodes != null) {
                        foreach(QuadTree child in childNodes) {
                            child.Draw();
                        }
                    }
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Each Quad Tree is going to have a certian number of children, maxObject count, and a max depth. The maximum depth defines the maximum number of splits that QuadTree can have. Each time a QuadTree splits, QuadTree will add childNodes, and set itself the nodeParent on all of those childNodes. Further, QuadTrees at the root level are going to contain objects. The root level means QuadTrees that do not have any childNodes. Finally each node will define a nodeCenter, nodeBound, and nodeSize.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In the scene, we're using Gizmos to draw the QuadTree so we have something to look at. And it's easier to Debug issues. Our QuadTree interface defines a maximum node depth, a maximum number of objects per node. And the Items to Add is, when adding items, how many we want to add at a time. The maximum node objects is a count that when the number of objects in a node goes over the maximum node objects, it will perform a split operation and this is where the node will add those childNodes and add it's own objects to all of it's children.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Our next piece is the <b>Quad Tree Interface</b> script:
            <pre>
            <span class="glyphicon-remove"></span>public class QuadTreeInterface : MonoBehaviour {

                QuadTree quadTree;
                public int maxNodeDepth = 5;
                public int maxNodeObjects = 2;
                public int itemsPerAdd = 1;
                GameObject itemParent;

                void Start() {
                    Generate();
                }

                void Generate() {
                    quadTree = new QuadTree(100, maxNodedepth, maxNodeObjects, new Vector2(this.transform.position.x, this.transform.position.y));
                    itemParent = new GameObject("ObjectsInQuadTree");
                }

                void AddItem() {
                    AddItem(new Vector3(Random.Range(-50f, 50f), Random.Range(-50f, 50f)), 0));
                }

                void AddItem(Vector3 position) {
                    GameObject go = GameObject.CreatePrimitive(PrimitiveType.Cube);
                    go.transform.parent = itemParent.transform;
                    go.transform.position = position;
                    quadTree.Add(go);
                }

                void Update() {

                    if(Input.GetKeyDown(KeyCode.Space)) {
                        for(int item = 0; item < itemsPerAdd; item++) {
                            AddItem();
                        }
                    }

                    if(Input.GetKeyDown(KeyCode.A)) {
                        AddItem(MouseUtils.GetMouseWorldPositionAtDepth(10));
                    }

                    if(Input.GetMouseButtonDown((int)MouseUtils.Button.Left)) {
                        quadTree.ClearSearch();
                        Vector3 clickPos = MouseUtils.GetMouseWorldPositionAtDepth(10);
                        GameObject nearest = quadTree.FindNearest(clickPos.x, clickPos.y, clickPos.z);
                        if(nearest != null)
                            Debug.DrawLine(clickPos, nearest.transform.position, Color.green, 5);
                    }
                }

                void OnDrawGizmos() {
                    if(quadTree != null) {
                        quadTree.Draw();
                    }
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            So again in our scene. Hitting the A key will add an object to our scene. If we add another we are at the maximum node object count. Adding a third will cause a split operation. So when this node splits, it adds four children, all a quarter of the size. And then it went and added all of it's objects to each of it's childNodes. So now this larger node does not contain any objects, but only contains four children, three of which contain an object.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Further splitting will occur if adding multiple objects to an even smaller node and we'll continue to go for another eight levels down which is the maximum node depth. So if we look at how these objects are added we'll see a game object added to our Quad Tree will test to see if the object is within the bound of the Quad Tree. If it is we're going to call a private method that's going to add the Game Object to our Quad Tree using the centre of the GameObject. The Add method taking an object and it's center is going to check to see if this node has any children. If it does, we're going to decide what child to put the object into. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            This is based on the objCenter and the nodeCenter. Depending if the object is to the left or the right, or above or below the node centre, we're going to change the index of the child. With the objCenter being to the left of the nodeCenter and below the nodeCenter will result in the index being 0 plus 0. Meaning the index is 0. An objCenter to the right of the nodeCenter will be a one plus, if the object is below. And will be plus0, meaning the index is one. We recursively call this Add until we reach a child Node that does not have any children. This is called a root node. A root node is where we want to place all of our objects. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            First, we test to see if adding the object is going to put us over the maximumObjectCount. If it does, we're going to call a split operation and for each object that we have, we're going to re-add it to our Quad Tree. This will add it to the childNdoes that we've just created in the split operation.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Finally we're going to clear our list so that we don't have any object any more. This ensures that only root nodes have objects in them. Finally we're going to add the object again that cause the split in the first place, so that we can ensure we add it to the appropriate child node. If the object does not cause us to go over our maximum count, we're just going to add it to our objects. Let's take a look at this in Unity again. We're going to add multiple items at the same time in a random location here so we can see when adding a large number of objects the Quad Tree splits fairly evenly with some spots having more than others.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            So continuing to add objects causes deeper and deeper splits. So what's so beneficial about using this spatial partioning? Well, when adding a large number of objects like this, like 1000 of them, trying to find the nearest object the the point we click would require us to search through all of the objects in the scene and see which is closest. However, using a QuadTree structure like this, we can split the scene and search fewer objects. For example, the nodes marked in red for those searched for the nearest node. The green line drawn shows us the node closest to where we click. This means we didn't have to calculate the distance to these objects and only the objects found in the red circles. This gives us a significant improvement in searching speed.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Scene Setup</b>
            <p><span class="glyphicon-remove"></span>Create a new empty called Quad Tree Interface with the Quad Tree Interface script attached.
            <br>Set Max Node Depth to 8, Max Node Object to 2, and Items Per Add to 1.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this section we have covered how to create and use a Quad Tree. The Quad Tree is a nice structure for many situations. The 2D nature of the Quad Tree can be a limitation, however it doesn't limit you to a 2D world. Most games have a majority of their game objects in a relatively flat area for example, such as a 3D real time strategy game. The height of the world is significantly less than the length or the width.
            <p><span class="glyphicon-remove"></span>The Quad Tree we created here still accepts a third parameter, it's just ignored by the partitioning portion of the structure. However, it's still used to calculate the distance and find the nearest object. If we needed to also partition the vertical, we'd use an OctTree. Gets a bit more tricky.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="8">
    <h2>Extension Methods</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we're going to cover extension methods. These are a special type of method that essentially allows you to add additional methods to a class without having to modify that class. This is great for situations where you don't want to or can't create a new derived type just to add a method or two. Once the extension methods are written, there's no apparent difference between calling them or the objects built in methods. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's start off with our <b>Extension Methods</b> static class:
            <pre>
            <span class="glyphicon-remove"></span>//Everything must be static, since we're not going to instantiate this anywhere.
            public static class ExtensionMethods {

                //Create extension methods to add methods to classes.
                //This is primarily useful if we don't have access to 
                // override the class or just want a simple addition.
                public static void Reset(this GameObject gameObject) {
                    gameObject.transform.position = Vector3.zero;
                    gameObject.transform.rotation = Quaternion.identity;
                    gameObject.transform.localScale = Vector3.one;
                }

                
                //The signature may look a little strange. When using the `this Type varName` format,
                // the first parameter is automatically provided by calling the object.
                //The compiler is smart enough to know that the type is GameObject, so these will actually
                // show up in the autocomplete as well.
                public static void MoveToMouse(this GameObject gameObject) {
                    Vector3 headingToObject = gameObject.transform.position - Camera.main.transform.position;

                    //Find the projection on the forward vector of the camera.
                    float depth = Vector3.Dot(headingToObject, Camera.main.transform.forward);
                    Vector3 mouseScreenPosition = Input.mousePosition;
                    mouseScreenPosition.z = depth;
                    Vector3 mouseWorldPosition = Camera.main.ScreenToWorldPoint(mouseScreenPosition);
                    gameObject.transform.position = new Vector3(mouseWorldPosition.x, mouseWorldPosition.y, mouseWorldPosition.z);
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Here we have a static class for extension methods. In this class, we can put all of our extension methods because they're going to be static and we can keep them all in one spot. These are going to be loaded up by the compiler. The first extension method we're going to be defining is called Reset. The first parameter of any extension method is going to be the <i>this</i> with the type of the object we want to extend and then the object we're going to extend. The compiler is smart enough to know that this part will be removed and we're going to be calling GameObject.Reset. The reset method is simply going to take the transform position rotation and scale, and set them to the default values. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The second extension method we're creating is called Move To Mouse, and this again is going to act on a game object, and we're just going to reuse code from our mouse input section to mouse the object to the mouse position.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Next we'll need an interface to check our methods out. This is the <b>Extension Method Test Interface</b> script:
            <pre>
            <span class="glyphicon-remove"></span>public class ExtensionMethodTestInterface : MonoBehaviour {

                public GameObject testObject;

                void Start() {
                    testObject = this.gameObject;
                }

                void Update() {
                    if(Input.GetKeyDown(KeyCode.Space)) {
                        testObject.Reset();
                    }
                    if(Input.GetMouseButtonDown((int)MouseUtils.Button.Left)) {
                        testObject.MoveToMouse();
                    }
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In our test interface, we're going to create a test object, and then in the update method, look for a space input press. If the space key is pressed, we are going to call Reset on the test object, or if the left mouse button is pressed, we can call Move To Mouse. The nice thing about this is the game object here. We can see that we have all of our other parameters and methods and we see that our extension method has been added in auto complete.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Scene Setup</b>
            <p><span class="glyphicon-remove"></span>Create a cube called TestObject.
            <br>Attach the Extension Method Test Interface, and the Mouse Drag Objects scripts.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this quick section, we've covered using extension methods and the kind of situations we'd use them for. These methods are great for adding functionality to existing classes. Further they help us improve our efficiency when writing code. Now we don't have to go to a helper library to find the method that takes a game object and resets its values. Instead now we can just call a reset method on the game object itself. This is a coding efficiency improvement and an organizational improvement. The big bonus of it being added to the code completion is even better.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

                    <!-------------------------------------->
                </div>
            </div>
    </main>

    <!-------------------------------------------------------------------------->

    <!-- FOOTER -->
    <footer class="navbar navbar-inverse navbar-fixed-bottom">
        <nav>
            <div class="container">
                <div class="row">
                    <div class="col-md-6 col-sm-6 col-xs-12">
                        <ul>
                            <li>&copy; 2017 <a href="http://www.gabedeyo.com">Gabe Deyo</a></li>
                            <li>|</li>
                            <li><a href="mailto:gabedeyo@gmail.com?subject=Notes">gabedeyo@gmail.com</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>
    </footer>

    <!-- Latest Minified Slim JQuery -->
    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

    <script src="../js/selection.js" charset="utf-8"></script>
</body>

</html>

<!-- Section Template

<div class="jumbotron col-md-12 heliList" id="">
    <h2>XXX</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

-->
