<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Advanced Scripting - Optimizations</title>

    <meta name="viewport" content="width=device-width,initial-scale=1.0, shrink-to-fit=no" />

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="../../../css/page.css">
</head>

<body>

    <!-- Top Navigation -->
    <header>
        <nav class="navbar navbar-inverse">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapsemenu" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a href="../../../index.html" class="navbar-brand">Personal Notes</a>
                </div>

                <div class="collapse navbar-collapse" id="collapsemenu">
                    <ul class="nav navbar-nav">

                        <!-- GAME DEVELOMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Game Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- CONCEPTS -->
                                <li><a href="../../Categories/concepts.html">Concepts <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ENGINE -->
                                <li><a href="../../Categories/engine.html">Engine <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- IMPLEMENTATIONS -->
                                <li><a href="../../Categories/implementations.html">Implementations <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- PROGRAMMING -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Programming <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- LANGUAGES -->
                                <li><a href="../../../code/Categories/languages.html">Languages <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ALGORITHMS -->
                                <li><a href="../../../code/Categories/algorithms.html">Algorithms <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PROBLEMS -->
                                <li><a href="../../../code/Categories/problems.html">Problems <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- RANDOM -->
                                <li><a href="../../../code/Categories/random.html">Random <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- GABE DEVELOPMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Gabe Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- FITNESS PAGE -->
                                <li><a href="../../../gabe/Categories/fitness.html">Fitness <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- STYLE & GROOMING PAGE -->
                                <li><a href="../../../gabe/Categories/style.html">Style <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- FINANCE PAGE -->
                                <li><a href="../../../gabe/Categories/finance.html">Finance <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PHILOSOPHY PAGE -->
                                <li><a href="../../../gabe/Categories/philosophy.html">Philosophy <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                    </ul>
                </div>

            </div>
        </nav>
    </header>

    <!-------------------------------------------------------------------------->

    <!-- MAIN -->
    <main>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h1 id="title">Advanced Scripting - Optimizations</h1>

                    <aside>
                        <button type="button" class="btn btn-default" name="button" id="selectAll">Select All</button>
                        <button type="button" class="btn btn-default" name="button" id="clearAll">Clear All</button>
                    </aside>

                    <div class="jumbotron heliList">
                        <h2>Index</h2>
                        <ul>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#0">Finding Slow Code</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#1">Nearest-Neighbor Search</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#2">Object Pools</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#3">Update() Overuse</a>
                                </p>
                            </li>
                        </ul>
                    </div>

<div class="jumbotron col-md-12 heliList" id="0">
    <h2>Finding Slow Code</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we're going to go over how you can place timers in your code to find where your code is running the slowest. This is the most basic function of a profiler. Profilers run along with your code to track the performance. Some advanced profilers will give you method level resolution and provide timings, CPU load, and various memory statistics, like total allocations and garbage collection. Unity Pro has such a profiler built in, which is far more rebust than the simple one I'm going to show you here. However this simple version should get you started using the Unity free version. We'll also cover how you can use the information you find, and when and where to start looking.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's check out our <b>Profile</b> class:
            <pre>
            <span class="glyphicon-remove"></span>//using UnityEngine, System.Collections, System.Collections.Generic, System.Text, System;

            /* 
            - Summary
                Fixing slow code check list:
                1. Is it required to run at all?
                2. Is it required to run as often as it does?
                3. Is it required to run in as many places as it does?
                4. Can we make it run more efficiently?
            */

            public class Profile {

                static int timerNameCounter = 0;

                static Stack&lt;int> timerIndex = new Stack&lt;int>();
	
                static List&lt;TimeEntry> timeEntries = new List&lt;TimeEntry>();


                class TimeEntry {
                    public string name;
                    public float time;
                    public int startIndex;
                    public int indent;

                    public TimeEntry(string name, int startIndex, int indent) {
                        this.name = name;
                        this.time = Time.realtimeSinceStartup;
                        this.startIndex = startIndex;
                        this.indent = indent;
                    }
                }

                //Starts a new timer.
                public static void StartTimer() {
                    StartTimer("Section " + timerNameCounter++);
                }

                // Starts a new timer with the specified name
                public static void StartTimer(string name) {
                    timeEntries.Add(new TimeEntry(name, -1, timerIndex.Count));
                    timerIndex.Push(timeEntries.Count-1);
                }
                
                // Ends the last timer started
                public static void EndTimer() {
                    int last = timerIndex.Pop();
                    timeEntries.Add(new TimeEntry(timeEntries[last].name, last, timerIndex.Count));
                }

                // Returns the last time result without removing anything
                public static float PeekLastTime() {
                    if(timeEntries.Count > 0) {
                        TimeEntry last = timeEntries[timeEntries.Count - 1];
                        if(last.startIndex >= 0) {
                            return (float)Math.Round((double)(last.time - timeEntries[last.startIndex].time), 4);
                        }
                    }
                    return -1;
                }

                // Clears all results.
                public static void Clear() {
                    timerIndex.Clear();
                    timeEntries.Clear();
                }

                // Outputs the results of the profiling to the debugger
                public static void WriteResults() {

                    foreach(TimeEntry timeEntry in timeEntries) {
                        StringBuilder line = new StringBuilder();
                        line.Append('\t',timeEntry.indent);

                        if(timeEntry.startIndex >= 0) { //This is an end time
                            line.Append("/");
                            line.Append(timeEntry.name);
                            line.Append(" : ");
                            line.Append(timeEntry.time - timeEntries[timeEntry.startIndex].time);
                        } else {
                            line.Append(timeEntry.name);
                        }
                        Debug.Log(line.ToString());
                    }
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The Profile class is going to take care of most of the work for us. It's going to keep the list of time entries, where time entries have a name and a time, as well as a reference to when they were started, and some indent information for displaying them. When we start a new timer, we're going to add an entry to our time entries and push the index of the timer onto our stack. When ending a timer we are going to pop the last timer started off the stack and then add a new time entry referencing the last time we started, so that we can calculate the time it ran later. Peeking at the last time will give us the time run for the last time entry without removing it from the list. Next, we have a Clear method that will clean up our results, and finally have our WriteResults method which is going to go through all of our time entries pair th start with the end and calculate the time for each timer.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We will need an interface called <b>Profile Test Interface</b> in order to test this:
            <pre>
            <span class="glyphicon-remove"></span>public class ProfileTestInterface : MonoBehaviour {

                void Start () {
                    Profile.StartTimer("All of Start");
                    OuterProcess();
                    Profile.EndTimer();
                    Profile.WriteResults();
                }

                private void OuterProcess() {
                    for(int i = 0; i < 3; i++) {
                        Profile.StartTimer("Process");
                        Process();
                        Profile.EndTimer();
                    }
                }

                private void Process() {
                    double t = double.MinValue;
                    for(int i = 0; i < int.MaxValue/100f; i++) {
                        t = Mathf.Sqrt(i);
                    }
                }
                
                private void LargeMethod() {
                    Profile.StartTimer("LargeMethod");
                    ProcessA();
                    ProcessB();
                    ProcessC();
                    ProcessD();
                    ProcessE();
                    ProcessF();
                    Profile.EndTimer();
                }


                void ProcessA ()
                {
                    double t = double.MinValue;
                    for(int i = 0; i < int.MaxValue/300f; i++) {
                        t = Mathf.Sqrt(i);
                    }
                }
                void ProcessB ()
                {
                    double t = double.MinValue;
                    for(int i = 0; i < int.MaxValue/600f; i++) {
                        t = Mathf.Sqrt(i);
                    }
                }
                void ProcessC ()
                {
                    double t = double.MinValue;
                    for(int i = 0; i < int.MaxValue/600f; i++) {
                        t = Mathf.Sqrt(i);
                    }
                }
                void ProcessD ()
                {
                    double t = double.MinValue;
                    for(int i = 0; i < int.MaxValue/300f; i++) {
                        t = Mathf.Sqrt(i);
                    }
                }
                void ProcessE ()
                {
                    double t = double.MinValue;
                    for(int i = 0; i < int.MaxValue/10f; i++) {
                        t = Mathf.Sqrt(i);
                    }
                }
                void ProcessF ()
                {
                    double t = double.MinValue;
                    for(int i = 0; i < int.MaxValue/500f; i++) {
                        t = Mathf.Sqrt(i);
                    }
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            This profile test interface is going to start a timer and its start method, run the method, and then end the timer and write the results. The outer process method is going to have some of its own timers, each wrapped around this process method, where process is just going to do some busy work and give us some timings. In the scene, make sure you check uncollapse so that we can see how things actually happen in the correct order. First we started our AllOfStart timer, then we started the Process timer, and ended the Process timer, which took 0.xx (test) seconds. We can do that two more times, and finally stoped the AllOfStart timer. It took 0.xx (test) seconds in total. This information shows us that essentially the AllOfStart method is simply a sum of each of the Process methods. That means there's nothing else we need to look into here. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Now we want to focus our efforts on this process method. The process method is something we want ot improve. How to improve code, is something that is very specific to the code we're improving, so I won't go into much detail here. So how do we know when we need profiling? Typically, when a game is running slow, it has a low frame rate. This is because the time per frame is very high. In our example, we're not doing much of anything, so we have a very high frame rate, and a very low time per frame. Using this statistic information here, by clicking the Stats button, we can gain valuable information about what our game is doing and why it might be running slow. For example, we can see that zero time is being spent rendering because we have nothing rendered to the scene. And our main thread is taking three to five milliseconds per frame. This information, for example, could be be used to determine if it's a code issue, drawing issue, or something else that's causing our game to run slow. If we see a low main thread time, but a high render time, we might want to look at optimizing our meshes, or reducing draw calls in some ways. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            However a high main thread time and a low render time, would point to a scripting issue. We can narrow down the culprit script, by enabling it or disabling it here in the inspector. We can go a step further and enable or disable an entire object by clicking up here. Once we've identified a script as running slow. Inside the code of the script, we can essentially run a binary search using our profiling. For example, let's take a look at the large method. We're just going to call that one method and see what comes out. We see that the large method is taking 2.xx seconds to run. It's quite a long time. Let's see if we can narrow down the culprit. We might do this by a binary search method, which would simply be splitting our timers in two. We can now see which half of the method is taking longer. You see here that the first half only takes 0.1 seconds. The seconds half is taking 2.xx seconds. Let's continue our binary split into the second method. Now we see that the slowest method is somewhere in the 2a section. So finally we can ask, is it processD, or processE? We can get rid of the other times, just to make things cleaner. Now we can see that processE is the culprit.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            This kind of binary search can help you quickly narrow down, where you code is slow. The next step would be to go into procsessE and find out why it's running so much slower. You see here that it has significantly more iterations than any other method. So the next question we ask is, how do we fix it? Here, you'll want to go through the slow code checklist to try and find how to fix the code. The first questions we ask is, is it required to run at all? For example, if there was another way to retrieve the data could we do that? Or can we run the code once and then cache the results not needing to run it anymore? Next questions would be, is it required to run as often as it does? Could we use coroutines or triggers to activate this code, instead of having it in the update loop? Next, is it required to run in as many places as it is? This example would be if we have multiple instances of a script, we could try and find some way to share the data or share the processing load. For example, path finding in a large scene, we can just path find once and use that path finding information for multiple characters. Finally, can we make it run more efficiently? The answer is almost always yes, but the next questions to ask is it worth it? This will depend entirely on the code we're running. But we might want to look into caching results or changing an algorithm.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Scene Setup</b>
            <p><span class="glyphicon-remove"></span>TODO</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this section we've covered how to implement some basic timing to help track down code that's causing your game to run slowly. We wrap the method calls of interest with profiler calls, to get the results about the time it takes for each of those method calls to run. Finding the code that's running slow code, comes with some knowledge of the code base and experience with coding. Timings will help you narrow things down and confirm fixes to the code.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="1">
    <h2>Nearest-Neighbor Search</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we're going to discuss some of the nearest neighbor searches available to us, and see what kind of performance differences we see between them. Nearest neighbor searches, are commonplace in games, and used for thingks like AI decision making. One of the simplest ways to search for neighbors, is to essentially brute force the problem. This means we search every object in the scene and keep a reference to the nearest so far. This is actually a pretty effective method, it's very easy to implment, and can be used a lot of the time for small to medium number of objects.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Another option is something I've already touched on, spacial partitioning. There are lots of spacial partitioning algorithms, and we've already looked into Quad Trees already. The next dimension of Quad Trees, is Octrees. We'll be looking into those in this section, and we'll look at some different scenarios, for using these approaches and compare their run times.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The first thing we'll need to analyze is the <b>Linear Search Algorithms</b> class:
            <pre>
            <span class="glyphicon-remove"></span>public class LinearSearchAlgorithms {

                public static GameObject LinearSearch(Vector3 position, GameObject[] neighbors) {
                    float minDistance = float.MaxValue;
                    float tmpDistance = float.MaxValue;
                    GameObject nearest = null;
                    float dx;
                    float dy;
                    float dz;
                    Debug.Log("LinearSearch through: " + neighbors.Length + " neighbors");
                    foreach(GameObject go in neighbors) {
                        dx = go.transform.position.x - position.x;
                        dy = go.transform.position.y - position.y;
                        dz = go.transform.position.z - position.z;
                        
                        tmpDistance = Mathf.Sqrt((dx * dx) + (dy * dy) + (dz * dz));
                        if(tmpDistance < minDistance) {
                            minDistance = tmpDistance;
                            nearest = go;
                        }
                    }
                    return nearest;
                }

                //If a^2 > b^2 then, a > b
                //This means we can remove the sqrt() call
                public static GameObject LinearSearchOptimized(Vector3 position, GameObject[] neighbors) {
                    float minDistance = float.MaxValue;
                    float tmpDistance = float.MaxValue;
                    GameObject nearest = null;
                    float dx;
                    float dy;
                    float dz;
                    Debug.Log("LinearSearchOptimized through: " + neighbors.Length + " neighbors");
                    foreach(GameObject go in neighbors) {
                        dx = go.transform.position.x - position.x;
                        dy = go.transform.position.y - position.y;
                        dz = go.transform.position.z - position.z;

                        tmpDistance = ((dx * dx) + (dy * dy) + (dz * dz));
                        if(tmpDistance < minDistance) {
                            minDistance = tmpDistance;
                            nearest = go;
                        }
                    }
                    return nearest;
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Here we have a basic linear search. We're just going to take a group of objects to search, and a position we want to find the nearest object to. For each game object we're going to find the difference between that game object, and the position we're interested in. If that distance is less than the minimum distance we have so far, we're going to update our minimum distance, and set that object as the nearest.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We can make an optimization to this algorithm, because of the mathematical fact, if 'a' squared is greater than 'b' squared then it is also true that 'a' is greater than 'b'. This means when comparing distances, we don't need to take the square root. The square root call is an expensive mathematical operation. This linear search optimized method is going to remove the square root, and simply compare the distance squared. This will still find us the nearest, and I've included it so we can compare its runtime to that of a regular linear search.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Another method for finding the nearest neighbor is to use an <b>Octree</b>:
            <pre>
            <span class="glyphicon-remove"></span>public class Octree {

                static int childCount = 8;
                static int maxObjectCount = 100;
                static int maxDepth;

                //Used for visual debugging/demonstation
                private bool searched = false;

                private Octree nodeParent;
                private Octree[] childNodes;
                
                private List&lt;GameObject> objects = new List&lt;GameObject>();

                private int currentDepth = 0;

                private Vector3 nodeCenter;
                private Bounds nodeBounds = new Bounds();
                
                private float nodeSize = 0f;

                public Octree(float worldSize, int maxNodeDepth, int maxNodeObjects, Vector3 center) :
                            this(worldSize, 0, center, null) {
                    maxDepth = maxNodeDepth;
                    maxObjectCount = maxNodeObjects;
                }

                private Octree(float size, int depth, Vector3 center, Octree parent)
                {
                    this.nodeSize = size;
                    this.currentDepth = depth;
                    this.nodeCenter = center;
                    this.nodeParent = parent;

                    if(this.currentDepth == 0) {
                        this.nodeBounds = new Bounds(center, new Vector3(size*2, size*2, size*2));
                    } else {
                        this.nodeBounds = new Bounds(center, new Vector3(size, size, size));
                    }
                }

                public Octree Add(GameObject go)
                {
                    if (this.nodeBounds.Contains(go.transform.position))
                    {
                        return this.Add(go, go.transform.position);
                    }
                    return null;
                }
                
                private Octree Add(GameObject obj, Vector3 objCenter)
                {
                    if (this.childNodes != null)
                    {
                        // Find the index of the child that contains the center of the object

                        // Top four
                        // ╒═╤═╕
                        // │2│3│
                        // ╞═╪═╡
                        // │0│1│
                        // ╘═╧═╛
                        //
                        // Bottom four
                        // ╒═╤═╕
                        // │6│7│
                        // ╞═╪═╡
                        // │4│5│
                        // ╘═╧═╛

                        int index = (objCenter.x < this.nodeCenter.x ? 0 : 1) //Add one to select between  3,1,7,5.
                                                                            //Add zero to select between 2,0,6,4.
                                + (objCenter.y < this.nodeCenter.y ? 4 : 0) //Add four to select between 2,3,0,1.
                                                                            //Add zero to select between 6,7,4,5.
                                + (objCenter.z < this.nodeCenter.z ? 0 : 2);//Add two to select between  2,3,6,7.
                                                                            //Add zero to select between 0,1,4,5.

                        return this.childNodes[index].Add(obj, objCenter);
                    }
                    //We've reached a root
                    if(this.currentDepth < maxDepth &amp;&amp; this.objects.Count + 1 > maxObjectCount) {
                        //If adding this object puts this node past its limit, and we're not at the 
                        // maximum depth, split this node and redistribute its objects to its children
                        Split(nodeSize);
                        foreach(GameObject nodeObject in objects){
                            Add(nodeObject);
                        }
                        this.objects.Clear();

                        //And don't forget to add the object that caused us to split!
                        return Add (obj);
                    } else {
                        //Otherwise, just add this object to this node pool
                        this.objects.Add(obj);
                    }
                    return this;
                }

                public bool Remove(GameObject obj)
                {
                    if(objects.Contains(obj)) {
                        objects.Remove(obj);
                        return true;
                    }
                    else if(childNodes != null) {
                        foreach(Octree child in childNodes) {
                            if(child.Remove(obj))
                                return true;
                        }
                    }
                    return false;
                }


                private void Split(float parentSize)
                {
                    this.childNodes = new Octree[Octree.childCount];
                    int depth = this.currentDepth + 1;
                    float quarter = parentSize / 4f;
                    
                    this.childNodes[0] = new Octree(parentSize/2, depth,
                                                    this.nodeCenter + new Vector3(-quarter, quarter, -quarter), this);
                    this.childNodes[1] = new Octree(parentSize/2, depth,
                                                    this.nodeCenter + new Vector3(quarter, quarter, -quarter), this);
                    this.childNodes[2] = new Octree(parentSize/2, depth,
                                                    this.nodeCenter + new Vector3(-quarter, quarter, quarter), this);
                    this.childNodes[3] = new Octree(parentSize/2, depth,
                                                    this.nodeCenter + new Vector3(quarter, quarter, quarter), this);

                    this.childNodes[4] = new Octree(parentSize/2, depth,
                                                    this.nodeCenter + new Vector3(-quarter, -quarter, -quarter), this);
                    this.childNodes[5] = new Octree(parentSize/2, depth,
                                                    this.nodeCenter + new Vector3(quarter, -quarter, -quarter), this);
                    this.childNodes[6] = new Octree(parentSize/2, depth,
                                                    this.nodeCenter + new Vector3(-quarter, -quarter, quarter), this);
                    this.childNodes[7] = new Octree(parentSize/2, depth,
                                                    this.nodeCenter + new Vector3(quarter, -quarter, quarter), this);
                }

                public GameObject FindNearest(Vector3 position) {
                    return FindNearest(position.x, position.y, position.z);
                }
                
                public GameObject FindNearest(float x, float y, float z) {
                    double maxDistance = double.MaxValue;
                    return FindNearest(x, y, z, ref maxDistance);
                }

                private GameObject FindNearest(float x, float y, float z, ref double shortestDistance)
                {
                    GameObject closest = null;

                    //Reached a root node, check its objects
                    if (childNodes == null)
                    {
                        searched = true;
                        //We're a root node, check the objects we have
                        foreach (GameObject obj in objects)
                        {
                            double distance = Mathf.Sqrt(
                                Mathf.Pow(x - obj.transform.position.x, 2.0f) +
                                Mathf.Pow(y - obj.transform.position.y, 2.0f) +
                                Mathf.Pow(z - obj.transform.position.z, 2.0f));
                            
                            if ((distance > shortestDistance)) 
                                continue;
                            
                            shortestDistance = distance;
                            closest = obj;
                        }
                        return closest;
                    }

                    //Keep stepping into the children until we reach a root (above)
                    foreach (Octree child in childNodes)
                    {
                        double childDistance = GeneralUtils.DistanceToBoundsEdge(child.nodeBounds, x, y, z);
                        if (childDistance > shortestDistance) 
                            continue;
                        
                        GameObject tmpObject = child.FindNearest(x, y, z, ref shortestDistance);
                        if (tmpObject != null)
                            closest = tmpObject;
                    }
                    return closest;
                }

                private Octree GetNodeContaining(float x, float y, float z) {
                    if (this.childNodes != null)
                    {
                        // Find the index of the child that contains the center of the object
                        int index = (x < this.nodeCenter.x ? 0 : 1) 
                                + (y < this.nodeCenter.y ? 4 : 0)
                                + (z < this.nodeCenter.z ? 0 : 2);
                        
                        return this.childNodes[index].GetNodeContaining(x, y, z);
                    } else {
                        return this;
                    }
                }

                public void ClearSearch() {
                    searched = false;
                    if(childNodes != null) {
                        foreach(Octree child in childNodes) {
                            child.ClearSearch();
                        }
                    }
                }
                
                public void Clear() {
                    objects.Clear();
                    if(childNodes != null) {
                        foreach(Octree child in childNodes) {
                            child.Clear();
                        }
                        childNodes = null;
                    }
                }


                public void Draw() {
                    Gizmos.DrawWireCube(nodeCenter, new Vector3(nodeSize, nodeSize, nodeSize));

                    if(searched) {
                        Gizmos.color = Color.red;
                        Gizmos.DrawWireSphere(nodeCenter, (nodeSize/2));
                        Gizmos.color = Color.white;
                    }

                    if(childNodes != null) {
                        foreach(Octree child in childNodes) {
                            child.Draw();
                        }
                    }
                }
            }
            </pre> 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            This octree code is very similar to the quad tree code we've seen in a previous section. The difference is, it's going to split into eight, instead of four. Four cubes above, and four cubes below. The code is fairly similar to the quadtree code, except for the code added to handle the additional dimension.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's take a look at the interface where we implement these called <b>Nearest Neighbor Interface</b>:
            <pre>
            <span class="glyphicon-remove"></span>public class NearestNeighborInterface : MonoBehaviour {

                List&lt;int> runSuites = new List&lt;int>();
                public int nextSuiteCount = 50;
                public int treeMaxDepth = 5;
                public int treeMaxObjectsPerNode = 20;

                delegate GameObject LinearNearest(Vector3 position, GameObject[] neighbors);

                List&lt;LinearNearest> linearAlgorithms = new List&lt;LinearNearest>();
                
                Dictionary&lt;string, List&lt;string>> resultsData = new Dictionary&lt;string, List&lt;string>>();

                public GUISkin tableSkin;

                GameObject neighborParent = null;

                Table resultsTable;

                Octree testOctree;

                QuadTree testQuadtree;

                void Start () {
                    linearAlgorithms.Add(LinearSearchAlgorithms.LinearSearch);
                    linearAlgorithms.Add(LinearSearchAlgorithms.LinearSearchOptimized);

                    resultsData.Add("Spawning", new List&lt;string>(){"Spawning"});
                    resultsData.Add("Octree", new List&lt;string>(){"Octree"});
                    resultsData.Add("Quadtree", new List&lt;string>(){"Quadtree"});

                    foreach(LinearNearest algorithm in linearAlgorithms) {
                        resultsData.Add(algorithm.Method.Name, new List&lt;string>(){algorithm.Method.Name});
                    }
                }

                void Update () {
                    if(Input.GetKeyDown(KeyCode.Space)) {
                        RunNextSuite();
                    }
                }

                void RunNextSuite() {
                    StartCoroutine(RunSuite(nextSuiteCount));
                }

                IEnumerator RunSuite(int neighborCount) {

                    Debug.Log("Creating trees");
                    if(testOctree != null)
                        testOctree.Clear();
                    testOctree = new Octree(2000, treeMaxDepth, treeMaxObjectsPerNode, Vector3.zero);

                    if(testQuadtree != null)
                        testQuadtree.Clear();
                    testQuadtree = new QuadTree(2000, treeMaxDepth, treeMaxObjectsPerNode, Vector3.zero);


                    Debug.Log("Spawning neighbors");
                    Profile.StartTimer("Spawning");
                    SpawnNeighbors(neighborCount, ref testQuadtree, ref testOctree);
                    Profile.EndTimer();
                    resultsData["Spawning"].Add(Profile.PeekLastTime().ToString());
                    Profile.Clear();
                    yield return new WaitForSeconds(1);

                    GameObject[] objects = GameObject.FindGameObjectsWithTag("Neighbor") as GameObject[];


                    Debug.Log("Running Quadtree");
                    Profile.StartTimer("Quadtree");
                    GameObject foundObject = testQuadtree.FindNearest(this.transform.position);
                    Profile.EndTimer();
                    resultsData["Quadtree"].Add(Profile.PeekLastTime().ToString() + ":"
                                                + foundObject.transform.position.ToString());
                    Profile.Clear();
                    yield return new WaitForSeconds(1);


                    Debug.Log("Running ");
                    Profile.StartTimer("Octree");
                    foundObject = testOctree.FindNearest(this.transform.position);
                    Profile.EndTimer();
                    resultsData["Octree"].Add(Profile.PeekLastTime().ToString() + ":"
                                            + foundObject.transform.position.ToString());
                    Profile.Clear();
                    yield return new WaitForSeconds(1);


                    Debug.Log("Running linear algorithms");
                    foreach(LinearNearest algorithm in linearAlgorithms) {
                        Debug.Log("Running " + algorithm.Method.Name);
                        Profile.StartTimer(algorithm.Method.Name);
                        foundObject = algorithm(this.transform.position, objects);
                        Profile.EndTimer();
                        resultsData[algorithm.Method.Name].Add(Profile.PeekLastTime().ToString() + ":"
                                                            + foundObject.transform.position.ToString());
                        Profile.Clear();
                        yield return new WaitForSeconds(1);
                    }

                    
                    Debug.Log("Destroying neighbors");
                    if(neighborParent != null)
                        GameObject.Destroy(neighborParent);

                    yield return new WaitForSeconds(1);


                    Debug.Log("Displaying results");
                    runSuites.Add(neighborCount);
                    DisplayResults();
                }
                
                void SpawnNeighbors(int count, ref QuadTree quadTreeToPopulate, ref Octree octreeToPopulate) {
                    neighborParent = new GameObject("Neighbors: " + count);
                    
                    for(int neighbor = 0; neighbor < count; neighbor++) {
                        GameObject go = new GameObject("Neighbor");
                        go.tag = "Neighbor";
                        go.transform.position = new Vector3(Random.Range(-1000, 1000),
                                                            Random.Range(-1000, 1000),
                                                            Random.Range(-1000, 1000));
                        go.transform.parent = neighborParent.transform;
                        octreeToPopulate.Add(go);
                        quadTreeToPopulate.Add(go);
                    }
                }
                
                void DisplayResults() {
                    List&lt;string> header = new List&lt;string>(){"Algorithm"};
                    foreach(int count in runSuites) {
                        header.Add("@" + count + " neighbors");
                    }
                    resultsTable = new Table(new Vector2(900, 800), 22, tableSkin, header);
                    
                    foreach(string algorithm in resultsData.Keys) {
                        resultsTable.AddRow(resultsData[algorithm]);
                    }
                }

                void OnGUI() {
                    if(resultsTable != null)
                        resultsTable.Draw(new Vector2(0,0));
                }

                public bool showOctree = true;
                public bool showQuadtree = true;

                void OnDrawGizmos(){
                    if(testOctree != null &amp;&amp; showOctree) {
                        testOctree.Draw();
                    }
                    if(testQuadtree != null &amp;&amp; showQuadtree) {
                        testQuadtree.Draw();
                    }
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            This nearest neighbor interface is going to run through our algorithms, and compare the run times of each. It's going to use a table object which we created in a previous section, as well as our octree and quadtree, and linear search algorithms. When running a test suite, it's going to create a number of objects, which we'll define in Unity, and then run through each algorithm, trying to find the nearest object. Finally it'll remove all the objects from the scene. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In the scene, we're going to have a Searcher Object. this implements the nearest neighbor search. We're going to pass in the number of objects we want to spawn, and we can set the max depth, and max objects per node for both our quad tree and oct tree. Once in play mode, hit the space bar to start a new test suite. We see that the table is created with the various algorithms, as well as the number of neighbors, and the time it took for each algorithm to run.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Additionally the position of the nearest object is returned to ensure that we're all returning the same nearest object. I found that the first result returned, is usualy not as accurate as the others, and you can see that remains true, with significantly faster octree and quadtree times. And subtley faster linear search times. The reason that octree and quadtree searches are so much faster is because of the way they search. If you look at the quadtree, the entire box is filled with objects, but the quadtree only had to search some boxes, on order to find the nearest neighbor. It didn't have to compare the distance from the center to all the objects found in all of the other rectangles. The same goes for the octree. It was able to just search some cubes. We can see that it started in the top corner, and then just searched the cubes around the center, our point of interest. That means we didn't have search any of the other areas. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The difference between linear search, and spatial partitioning becomes more apparent as we add more objects. For example, if we spawn 10,000 objects, it's going to take a bit of time, and we can see our results are very good for our spatial partitioning algorithms, while the linear algorithms start to suffer. And even more, if we look at what the octree and quadtree had to search is even less because their nodes were split into smaller squares.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Scene Setup</b>
            <p><span class="glyphicon-remove"></span>TODO</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we've seen some options we have for nearest neighbor searches, and seeing what kind of performance gains you can get by using them for various situations. The nice thing about spatial partitioning is that you can essentially turn it off, by setting the number of objects per node very high, or setting the maxixmum depth very low. The overhead for spacial partitioning structures is fairly low for situations where objects are stationary. When objects are moving however, they need to be re-added whenever they leave on one node for another. This can increase the overhead of using these systems and can be an additional reason you would attempt to limit the number of nodes or switch to a different algorithm altogether.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="2">
    <h2>Object Pools</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we're going to go over how to implement and when to use object pools. Object pools are used to reduce the number of memory allocations a game has. In Unity, when creating a game object, memory is set aside for that object. When that object is later destroyed, the memory has to be reclaimed by a process called garbage collection. Allocation and garbage collection are somewhat heavy tasks that can take a significant amount of time. Further garbage collection is something that we for the most part don't have direct control over. So we don't know when it's going to happen. This can cause unexpected delays. Object pools avoid this by recycling. Instead of throwing away an object that's been marked not in use, dust it off and reuse it. This does mean that more memory might be in use throughout the course of your program. But it's typically worthwhile since memory usage is more predictable. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's look at our first script which is the <b>Game Object Pool</b> class:
            <pre>
            <span class="glyphicon-remove"></span>public class GameObjectPool {

                //Don't pool more than 100 objects, after this we'll just destroy anything returned to the pool.
                static public int maxPool = 100;

                //Get some GameObjects ready. This is nice to do in advance for a small performance boost.
                static public int preAllocate = 10;

                //Set this to a value greater than 0 if you want to hard limit the number of game objects.
                //This will ensure you don't create too many game objects for resource limited machines
                // however, it might result in unexpected behavior. (But maybe more expected than running out
                // of resources? Up to you.)
                static public int hardlimit = -1;

                //Create an object to make the parent of all the pooled objects
                static GameObject objectParent = new GameObject("LifeGaurd");

                static Dictionary&lt;string, Pool> pools = new Dictionary&lt;string, Pool>();

                //One pool per prefab.
                class Pool {
                    GameObject sourcePrefab;
                    Stack&lt;GameObject> objectPool;

                    public Pool (GameObject sourcePrefab) {
                        this.sourcePrefab = sourcePrefab;
                        objectPool = new Stack&lt;GameObject>(preAllocate);
                        Allocate(preAllocate);
                    }

                    public GameObject Spawn() {
                        if(objectPool.Count > 0) {
                            return RemoveFromPool();
                        } else {
                            GameObject go = GameObject.Instantiate(sourcePrefab) as GameObject;
                            //For this simple example we rely on the name to discover the prefab pool, set it to the parent name
                            go.name = sourcePrefab.name;
                            return go;
                        }
                    }

                    public void Recycle(GameObject go) {
                        if(objectPool.Count < maxPool) {
                            AddToPool(go);
                        } else {
                            GameObject.Destroy(go);
                        }
                    }

                    private void Allocate(int allocateCount) {
                        if ((hardlimit > 0) &amp;&amp; objectPool.Count + allocateCount > maxPool)
                            allocateCount = hardlimit - objectPool.Count;
                        
                        for (int a = 0; a < allocateCount; a++)
                        {
                            GameObject go = GameObject.Instantiate(sourcePrefab) as GameObject;
                            //For this simple example we rely on the name to discover the prefab pool, set it to the parent name
                            go.name = sourcePrefab.name;
                            AddToPool(go);
                        }
                    }

                    private void AddToPool(GameObject go) {
                        go.SetActive(false);
                        go.transform.parent = objectParent.transform;
                        
                        objectPool.Push(go);
                    }
                    
                    private GameObject RemoveFromPool() {
                        GameObject go = objectPool.Pop();
                        go.transform.parent = null;
                        go.transform.position = Vector3.zero;
                        go.transform.localScale = Vector3.one;
                        go.transform.rotation = Quaternion.identity;
                        go.SetActive(true);
                        return go;
                    }
                }

                public static void Initialize(GameObject poolObject) {
                    if(!pools.ContainsKey(poolObject.name)) {
                        pools.Add(poolObject.name, new Pool(poolObject));
                    } 
                }

                static public GameObject Spawn(GameObject poolObject) {
                    if(!pools.ContainsKey(poolObject.name)) {
                        pools.Add(poolObject.name, new Pool(poolObject));
                    } 
                    return pools[poolObject.name].Spawn();
                }

                static public void Recycle(GameObject go) {
                    if(pools.ContainsKey(go.name)) {
                        pools[go.name].Recycle(go);
                    } else {
                        GameObject.Destroy(go);
                    }
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Our game object pool class is going to manage pooling all of our game objects. It's going to have a maximum number of objects to pool, as well as an option to pre allocate some objects. It's also going to have a game object that we're going to use as a parent for organizing pooled objects in our scene. It's going to maintain a list of pools, reference by a prefab name. Each pool contains only one type of prefab, so that when adding or removing from that pool, we know we're going to get the same object out that we put in. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            When spotting a new game object, we're going to check to see if our pool has any game objects in it. If it does, we're going to remove from that pool. Otherwise we're going to instantitate a new game object and return that. Removing from the pool, pops the game object off our pool stack, resets its transfrom values, and sets it to active. when adding a game object to the pool we're going to set the object active to false, then set the parent to the object parent for organization. Lastly, we're going to push the object onto our object pool stack so that it can be popped off when we need a new object. For this demonstration, we're going to use two types of objects. We're going to create bullets that will recycle themselves when they finish, and bullets that will destroy themselves when they are finished. You'll see why i'm doing this in a bit. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's first see the <b>Bullet Destroy</b> script:
            <pre>
            <span class="glyphicon-remove"></span>public class BulletDestroy : MonoBehaviour {

                float travelDistance = 10f;
                float speed = 10f;

                void OnEnable()
                {
                    StartCoroutine(Fire());
                }
                
                void OnDisable()
                {
                    StopAllCoroutines();
                }

                IEnumerator Fire()
                {
                    float total = 0;
                    while(total < travelDistance) {
                        total += (speed * Time.deltaTime);
                        this.transform.Translate(0f, 0f, (speed * Time.deltaTime), Space.Self);
                        yield return 0;
                    }

                    GameObject.Destroy(this.gameObject);
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Now let's see it's counterpart, the <b>Bullet Recycle</b> script:
            <pre>
            <span class="glyphicon-remove"></span>public class BulletRecycle : MonoBehaviour {

                float travelDistance = 10f;
                float speed = 10f;
                
                void OnEnable()
                {
                    StartCoroutine(Fire());
                }
                
                void OnDisable()
                {
                    StopAllCoroutines();
                }
                
                IEnumerator Fire()
                {
                    float total = 0;
                    while(total < travelDistance) {
                        total += (speed * Time.deltaTime);
                        this.transform.Translate(0f, 0f, (speed * Time.deltaTime), Space.Self);
                        yield return 0;
                    }

                    GameObjectPool.Recycle(this.gameObject);
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Before we talk about what we're doing, lets see the <b>Object Pool Test Interface</b> script:
            <pre>
            <span class="glyphicon-remove"></span>//using UnityEngine, System.Collections, System.Collections.Generic, System.Linq;

            public class ObjectPoolTestInterface : MonoBehaviour {

                List&lt;string> resultsData = new List&lt;string>();

                public GUISkin tableSkin;

                Table resultsTable;

                public int addCount = 5;

                GameObject bulletRecyclePrefab;
                GameObject bulletDestroyPrefab;

                void Start () {
                    bulletDestroyPrefab = Resources.Load("BulletDestroy") as GameObject;
                    bulletRecyclePrefab = Resources.Load("BulletRecycle") as GameObject;

                    GameObjectPool.Initialize(bulletRecyclePrefab);
                }

                void PoolRun() {
                    Profile.StartTimer("Pool");
                    for(int i = 0; i < addCount; i++) {
                        GameObjectPool.Spawn(bulletRecyclePrefab);
                    }

                    Profile.EndTimer();
                    resultsData.Add(Profile.PeekLastTime().ToString() + " @ (" + addCount + ")");
                    Profile.Clear();
                }

                void InstantiateRun() {
                    Profile.StartTimer("Instantiate");
                    for(int i = 0; i < addCount; i++) {
                        GameObject.Instantiate(bulletDestroyPrefab);
                    }

                    Profile.EndTimer();
                    resultsData.Add(Profile.PeekLastTime().ToString() + " @ (" + addCount + ")");
                    Profile.Clear();
                }

                void Update () {
                    if(Input.GetKeyDown(KeyCode.Space)) {
                        StartCoroutine(RunTest());
                    }
                }

                IEnumerator RunTest() {
                    InstantiateRun();
                    Debug.Log("Waiting 1 second");
                    yield return new WaitForSeconds(1);
                    PoolRun();
                    yield return new WaitForSeconds(1);
                    DisplayResults();
                }

                void DisplayResults() {
                    List&lt;string> header = new List&lt;string>(){"Instantiate", "Pool"};
                    resultsTable = new Table(new Vector2(900, 800), 22, tableSkin, header);

                    for(int result = 0; result < resultsData.Count; result+=2) {
                        resultsTable.AddRow(resultsData[result], resultsData[result + 1]);
                    }
                }

                void OnGUI() {
                    if(resultsTable != null)
                        resultsTable.Draw(new Vector2(0,0));
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The test interface we're going to use is simply going to create a number of destory bullets and a number of recycle bullets, and then compare the run time for creating each group of objects. When starting a pool run, we're going to start our timer, run through the number of items we're going to add, and spawn each game object using our game object pool. When doing an InstantiateRun, we're going to run through the number of objects and use GameObject.Instantiate. Hitting the space key will start the test run. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In the scene, we will have our pool tester that's going to have a specific number of objects to spawn, and hitting the space key will spawn those objects. We see then that our first run, the instantiate, and pool runs are very similar in times, with instantiate being slightly lower. But now that we have objects in our pool, we can see that the next run is significantly better for the pool run than the instantiate run. Additionally, we can increase the number of objects, and see similar results. Whether they be fairly close in the first run, and significantly better for the pool run in the future runs.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Scene Setup</b>
            <p><span class="glyphicon-remove"></span>TODO</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we've gone over how to use pools and what they're used for. Their reuse of objects, provides significant performance improvements for CPU and RAM usage. We can likely improve the pool system we've created here for better tracking of different types of prefabs instead of using object names. Further we can add support for prefabs that have different start up values. In games where a large number of objects are going to be created over and over again, pools are essential. Pools are also fairly important on system with limited resources, like mobile or web. Reducing the amount of garbage produced by your game reduces the frequency of garbage collection, in addition to reducing the impact it has. Unexpected performance drops are frequently caused by garbage collection. Pools are an essential step towards implementing the three Rs in your development; reduce, recycle and reuse.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="3">
    <h2>Update() Overuse</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we're going to go over some techniques for optimizing on of the largest problems in scripting performance: overuse of the Update Method. The Update method is called on every script, inside every object, every frame. This is the first stop for optimizing the performance of your scripts. The goal is to reduce the amount of code that runs each frame. This makes the frame time shorter, and when the frame time is shorter, the frame rate improves. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We'll first analyze the <b>Optimized Script</b> code:
            <pre>
            <span class="glyphicon-remove"></span>public class OptimizedScript : MonoBehaviour {

                //Cache searches and component lookups
                Enemy targetObject;

                void Start () {
                    //Find methods are fairly expensive, and should be kept to a minimum.
                    //Put this in start instead of each update.
                    targetObject = GameObject.FindObjectOfType&lt;Enemy>();
                }

                void Update () {

                    UpdateSteering();
                    CheckSurroundingTargets();

                    //StartCoroutine(SleepScript(5));
                    //Debug.Log("Awake!");
                    //Do regular update

                }

                void RunSlowUpdate() {
                    StartCoroutine(SlowUpdate());
                }
                
                public IEnumerator SlowUpdate() {
                    while(true) {
                        UpdateSteering();
                        CheckSurroundingTargets();
                        yield return new WaitForSeconds(.3f);
                    }
                }
                
                void FixedUpdate () {
                    //AI update, phyics checks
                }

                //Sleep the script. This will disable the script for the specified sleepTime
                public IEnumerator SleepScript(float sleepTime) {
                    this.enabled = false;
                    yield return new WaitForSeconds(sleepTime);
                    this.enabled = true;
                }

                //If a script doesn't need to be updated when we're not watching it, we can disable it
                void OnBecameInvisible() {
                    //This is enabling on the script level. So for example we could disable an script
                    // that's updating animations or providing other purely visual information
                    //While leaving a script that checks for nearby enemies or a patrol script
                    enabled = false;
                }
                //Then re-enable it when it becomes visible again.
                void OnBecameVisible() {
                    enabled = true;
                }

                void CheckSurroundingTargets() {

                }

                void UpdateSteering() {

                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            With the Optimized Script, we're going to see some optimizations we can implement. Reducing the amount of code in the Update method is the first step. These UpdateSteering and CheckSurroundingTarget methods likely don't need to be run every single frame. We can remove those and extract them into a coroutine by running a slow update in our Start method, which will, for the entire time the game object is alive, start the co-routine for slow update, which will only run every 0.3 seconds. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Additionally, we could move these into our Fixedupdate method, which is going to run at a time specified by Unity. That rate can be found in Edit -> Project Settings -> Time, and our fixed time step will be in there. The fixed time step also applies to our physics step, so be very careful when changing it. If something absolutely can't be removed from the Update method, we can try to disable the script as often as possible. We can see that being utilized with our SleepScript method that will sleep the script for five seconds in between updates. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            There are other ways to disable a script. For example, we can disable based on visibility. The MonoBehaviour class provides two methods, OnBecameInvisible and OnBecameVisible. These methods will be called when the camera can no longer see the object or the object just came into view. You can use this, for example, to disable an animation script or any other script that provieds purely visible information when it can't be seen by the camera. Another large change for managing the amount of code run per frame is to do something called flipping the responsibilities.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
             To demonstrate this, we'll take a look at the <b>Job Manager</b> script:
             <pre>
             <span class="glyphicon-remove"></span>public class JobManager : MonoBehaviour {

                List<string> jobs;

                void Start () {
                    jobs = new List<string>();
                    jobs.Add("pick up");
                    jobs.Add("brew");
                    jobs.Add("dispose");
                }

                public void AddJob(string job) {
                    jobs.Add(job);
                }
                
                public string GetJob() {
                    if(jobs.Count > 0) {
                        string job = jobs[jobs.Count-1];
                        jobs.RemoveAt(jobs.Count-1);
                        return job;
                    }
                    return "";
                }
             }

             //public class JobManager : MonoBehaviour {
            //	
            //	List&lt;string> jobs;
            //
            //	Queue&lt;JobWorker> workers;
            //
            //	float pushInterval = 1f; //1 second interval.
            //
            //	// Use this for initialization
            //	void Start () {
            //		jobs = new List&lt;string>();
            //		jobs.Add("pick up");
            //		jobs.Add("brew");
            //		jobs.Add("dispose");
            //		workers = new Queue&lt;JobWorker>();
            //		StartCoroutine(PushJobs());
            //	}
            //
            //	public void AddWorker(JobWorker worker) {
            //		workers.Enqueue(worker);
            //		worker.enabled = false;
            //	}
            //
            //	public void AddJob(string job) {
            //		jobs.Add(job);
            //	}
            //	
            //	string GetJob() {
            //		if(jobs.Count > 0) {
            //			string job = jobs[jobs.Count-1];
            //			jobs.RemoveAt(jobs.Count-1);
            //			return job;
            //		}
            //		return "";
            //	}
            //
            //	public IEnumerator PushJobs() {
            //		while(true) {
            //			while(PushJob());
            //			Debug.Log("Manager Update");
            //			yield return new WaitForSeconds(pushInterval);
            //		}
            //	}
            //
            //	bool PushJob() {
            //		if(jobs.Count > 0) {
            //			if(workers.Count > 0) {
            //				JobWorker jw = workers.Dequeue();
            //				jw.enabled = true;
            //				jw.DoJob(GetJob());
            //				return true;
            //			}
            //		}
            //		return false;
            //	}
            //}
             </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Next we'll need to see the <b>Job Worker</b> script:
            <pre>
            <span class="glyphicon-remove"></span>public class JobWorker : MonoBehaviour {

                string currentJob;
                float workingTime = 0;
                float standardJobTime = 5;
                bool working = false;

                void Update () {
                Debug.Log("Worker Update");
                    if(working){
                        DoWork();
                    } else {
                        string job = GameObject.FindObjectOfType&lt;JobManager>().GetJob();
                        if(job != "") {
                            currentJob = job;
                            working = true;
                        }
                    }
                }

                void DoWork() {
                    workingTime += Time.deltaTime;
                    if(workingTime >= standardJobTime) {
                        working = false;
                        workingTime = 0;
                        currentJob = "";
                    }
                }
            }

            //public class JobWorker : MonoBehaviour {
            //	
            //	string currentJob;
            //	float workingTime = 0;
            //	float jobUpdateFrequency = .1f;
            //	float standardJobTime = 5;
            //	bool working = false;
            //	JobManager manager;
            //
            //	// Use this for initialization
            //	void Start () {
            //		manager = GameObject.FindObjectOfType&lt;JobManager>();
            //	}
            //	
            //	// Update is called once per frame
            //	void Update () {
            //		Debug.Log("Worker Update");
            //		if(working){
            //			StartCoroutine(DoWork());
            //		} else {
            //			manager.AddWorker(this);
            //		}
            //	}
            //	
            //	IEnumerator DoWork() {
            //		while(working) {
            //			workingTime += Time.deltaTime;
            //			if(workingTime >= standardJobTime) {
            //				working = false;
            //				workingTime = 0;
            //				currentJob = "";
            //			}
            //			yield return new WaitForSeconds(jobUpdateFrequency);
            //		}
            //	}
            //
            //	public void DoJob (string job)
            //	{
            //		currentJob = job;
            //		working = true;
            //	}
            //}
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            This Job Manager is responsible for accepting jobs and then allowing job workers to retrieve jobs. This system might be used in an RTS-type game where we want to queue up jobs for our worker units to do. Every frame, the job workers are going to be either working or looking for work. This means that the more workers we have, the more code is being run every frame because they each have work to do in their Update method. This is similar to the scenario where 100 enemies are checking to see if a player is near enough to attack; instead have the player script notify an enemy when that player is near enough. This means we only have to do one range check instead of 100.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's take a look at the job worker as it was at it's bad point. We can see that the worker update calls are logged there, and they're ever increasing. We have anumber of workers checking for new jobs every frame. Now let's take a look at how we can flip the responsibility. After the optimization, we can see that the improved version of both classes instead flips the responsibility and makes the job manager responsible for pushing jobs out to workers. This means the workers only need to update when they have a job to do, and when they no longer have a job, they simply add themselves to the job manager list as waiting for a job. In the scene, we'll see we only add 194 worker updates before all the jobs are completed, and now we only have one manager updating per second instead of hundreds of job workers updating per second.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Scene Setup</b>
            <p><span class="glyphicon-remove"></span>TODO</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this section, we've seen some techniques and strategies to reduce the amount of code that's executed each frame. This is essentially achieved by running code less often or running code once for the benefit of multiple entities. It's been famously said that premature optimization is the root of all evil. However, it's also important to design with performance in mind. There have been plenty of people that give up on their games because the performance made their game unplayable and it still wans't even done. Compared to a large amount of software, games are very resource intensive. This means that a game developer must spend more time considering performance than most other developers.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

                    <!-------------------------------------->
                </div>
            </div>
    </main>

    <!-------------------------------------------------------------------------->

    <!-- FOOTER -->
    <footer class="navbar navbar-inverse navbar-fixed-bottom">
        <nav>
            <div class="container">
                <div class="row">
                    <div class="col-md-6 col-sm-6 col-xs-12">
                        <ul>
                            <li>&copy; 2017 <a href="http://www.gabedeyo.com">Gabe Deyo</a></li>
                            <li>|</li>
                            <li><a href="mailto:gabedeyo@gmail.com?subject=Notes">gabedeyo@gmail.com</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>
    </footer>

    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
    <script src="../../../js/selection.js" charset="utf-8"></script>
</body>

</html>
