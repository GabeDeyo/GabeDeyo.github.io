<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Advanced Scripting - Debugging</title>

    <meta name="viewport" content="width=device-width,initial-scale=1.0, shrink-to-fit=no" />

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/page.css">
</head>

<body>

    <!-- Top Navigation -->
    <header>
        <nav class="navbar navbar-inverse">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapsemenu" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a href="../index.html" class="navbar-brand">Personal Notes</a>
                </div>

                <div class="collapse navbar-collapse" id="collapsemenu">
                    <ul class="nav navbar-nav">

                        <!-- GAME DEVELOMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Game Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- CONCEPTS -->
                                <li><a href="concepts.html">Concepts <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ENGINE -->
                                <li><a href="engine.html">Engine <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- IMPLEMENTATIONS -->
                                <li><a href="implementations.html">Implementations <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- PROGRAMMING -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Programming <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- ALGORITHMS -->
                                <li><a href="../code/algorithms.html">Algorithms <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PROBLEMS -->
                                <li><a href="../code/problems.html">Problems <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- RANDOM -->
                                <li><a href="../code/random.html">Random <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- GABE DEVELOPMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Gabe Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- FITNESS PAGE -->
                                <li><a href="../gabe/fitness.html">Fitness <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- STYLE & GROOMING PAGE -->
                                <li><a href="../gabe/style.html">Style <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- FINANCE PAGE -->
                                <li><a href="../gabe/finance.html">Finance <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PHILOSOPHY PAGE -->
                                <li><a href="../gabe/philosophy.html">Philosophy <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                    </ul>
                </div>

            </div>
        </nav>
    </header>

    <!-------------------------------------------------------------------------->

    <!-- MAIN -->
    <main>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h1 id="title">Advanced Scripting - Debugging</h1>

                    <aside>
                        <button type="button" class="btn btn-default" name="button" id="selectAll">Select All</button>
                        <button type="button" class="btn btn-default" name="button" id="clearAll">Clear All</button>
                    </aside>

                    <div class="jumbotron heliList">
                        <h2>Index</h2>
                        <ul>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#debugging">Debugging</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#call-stack">The Call Stack</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#immediate-window">The Immediate Window</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#informative-and-visual">Informative and Visual Debugging</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#log-exceptions">Logging Exceptions</a>
                                </p>
                            </li>
                        </ul>
                    </div>

<div class="jumbotron col-md-12 heliList" id="debugging">
    <h2>Debugging</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In general terms, Debugging is the process of finding and removing bugs from the code. The Debugger is a tool that allows us to do this by analyzing the program during run time. It's not only great at catching run time errors but it provides a suite functionality that allows us to view the current state of the program at any given point, allowing us to find logic errors as well. With the Debugger, we can pause the execution of the code at break points, inspect the current state of the variables, step line by line through the code, and even modify values in memory.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The Debugger should be your go-to tool for solving run time errors and analyzing algorithm errors. The difference between these two is simple. Runtime errors cause an exception in the game. If the exception is not handled, this will cause the game to crash. These errors can arise from a number of situations. One of the most common runtime errors is a null pointer exception. This error happens when you try and use an object that has not yet been initialized. Other examples are array out of bounds errors, divide by zero, IO errors like file not found, and so on. Algorithm or logic errors do not cause an exception, and do not cause the program to crash.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Since these errors do not throw exceptions, it can be more challenging to confirm the source of the error, and possibly even hard to see that there is an error at all. Examples of these errors can be objects not responding properly to input, failing to find a path when one exists and so on. Further the errors can be linked and compounded. Logic errors can cause runtime errors, and logic errors in one spot, can cause or hide logic errors in another spot. The approach we use for solving these is different. But both problems can benefit from the use of the Debugger.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The Unity Editor does not have a Debugger built in, but we can use the ID that ships with Unity, MonoDevelop. Since the two applications are separate, it's a little more work to get the Debugger working. Also, while later versions of Unity have improved upon this, having the two applications separate has been known to result in problems getting Debugger to work properly, and consistently. Let's ook at an example by setting a break point in some code, and attaching the Debugger to Unity. We're going to set a break point on the first value inside a Start method.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            You set a break point by clicking in the column on the left side, next to the line numbers. A break point is a flag that tells the Debugger, that when the execution fothe code gets to the break point, it should pause the execution and wait for us to tell it what to do. This is great for situations where you want to see what values are being input into a certain function or if you want to step through the code after the break point. Break points should only be set in the code where a valid execution will occur.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Now that we've set our break point at the top of the Start function, let's attach the Debugger. The steps for attaching the Debugger are to ensure that the Unity editor is open. Then set to play mode. This will bring up the Attach to Process window and we see that our Unity editor is in here and we can attach to that. Now the Debugger is attached. We can switch back to the Unity Editor and hit play. This will trigger the break point that we set, and see the execution of the code has paused. It's  important to note that while the execution is paused, we can't actually use the Unity Editor becuase the execution is paused, it won't accept commands.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            When the execution is paused we can hover over variables to see what their values are. We can stpe over code to continue execution line by line. We can step into functions and then step out of functions and we can right click on values and add a watch.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>Break points are great for a lot of situations. But what about if we only want to break on a line sometimes. Thats where conditional break points come in. To try this, right-click the break point and go to Breakpoint Properties and we see that we're allowed to set a condition here. Break when the condition is true for example. Then we can type an expression here so when that condition is true, it will break.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In this quick look at the Debugger, we've seen the power of said Debugger and break points. These tools are incredibly useful when solving problems in your code and algorithms. The Debugger can also be used as a learning tool. If you're not sure how an algorithm works or unsure how a certain section of code behaves, step through it with the Debugger. The Debugger will show you step by step which line of code will be executed next, and you can analyze the inputs to the control flow systems like if, else, for, while, and see why the execution went the way it did.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="call-stack">
    <h2>The Call Stack</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In this section we'll discuss the CallStack and its importance for debugging. The CallStack is a list of functions and their locations in the program. You can think of a CallStack like a map, leading back to the start of the program. Recall, in the debugging section, we used the debugger to step into a piece of code. Whenever the execution steps into a function call it leaves a marker on the stack. It's called a stack because like the stacked data structure, items are added and removed from the top only. In this way, stepping into or calling a method will push a marker onto the stack, and stepping out of or returning from a method will pop a marker off.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's check it out with a bit of code:
            <pre>
            <span class="glyphicon-remove"></span>public class CallStack : MonoBehavior {
                public GameObject targetObject;
                public float distanceToTarget;

                void Start() {
                    Debug.Log(functionA());
                    Debug.Log(functionC());
                }

                string functionA() {
                    return functionB() + " and A!";
                }

                string functionB() {
                    return functionC() + " and B";
                }

                string functionC() {
                    return functionD + " and C";
                }

                string functionD() {
                    return "This string was made by function D";
                }
            }
            </pre>
            <p><span class="glyphicon-remove"></span>In this example we'll set a breakpoint at the return of functionD(). We can see our call stack down in the lower right. And see that from the start, we read this backwards to be functionC called functionD, functionB called functionC, functionA called functionB, and start called functionA. Obviously start calls funcitonA. It's important to note that every call to this function does not result in the same call stack.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We know that is true when we look at the call to functionC where functionC results in a start to functionC to functionD. This is similar to driving directions to a specific location. While the destination remains the same, the starting point can vary and even cars starting at the same point can take different routes. The call stack is like a list of streets the car used to get to the destination. In this analogy, the execution of the code is the car. This information becomes more and more valuable, the more complex your code becomes.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Say you have a function called calculateX. In this method, we want to calculate X by multiplying a vluae less than one times Y. Imagine that this method is used all throughout your code. In this case we'll just put it all in one method, but you can imagine that these calculated x calls are distributed throughout your entire codebase. Except somewhere, some bit of code is passing a value that is not less than one. We can set a break point here. Conditionally, when value less than 1 is greater than 1, we're going to break.
            <pre>
            <span class="glyphicon-remove"></span>float calculateX(int y, float valueLessThanOne) {
                float x = y * valueLessThanOne; // Set a conditional breakpoint here where valueLessThanOne > 1
                return x;
            }

            void callsAllOverThePlace() {
                Debug.Log(calculateX(4, 0.24f));
                Debug.Log(calculateX(34, 0.24f * 2f));
                Debug.Log(calculateX(22, 0.83f * 1.9f)); //Call stack finds this error
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            After we attach the debugger, we make our calls to callAllOverThePlace. We will see that the break point has indeed triggered and the value is greater than one and using the call stack we can actually double click the methods there to navigate to exactly where the call is. So we would be able to search through the call stack through to the line: Debug.Log(calculate(22, 0.83 * 1.9f)); which is calculating a larger value than allowed. In this case, the call stack has made it very easy to find the offending line of code, simply by setting a bright blank on the method where we found the error.
            <p><span class="glyphicon-remove"></span>The call stack can also be found in the Unity Editor when the Debugger is not attached. Look for errors in the console window.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="immediate-window">
    <h2>The Immediate Window</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            The immediate window allows us to execute a line of code, taking into account the current state of the program. This means we can write snippets of code that use the current values of our variables. This is great for situations where you want to say, what would happen if I tried it this way? Or a quick way to find out what the value inside an array is or the properties of an object are. We need to pause the execution of the code in order to get access to the immediate window. So in order to use, set a break point and attach the debugger.
            <pre>
            <span class="glyphicon-remove"></span>void Start() {
                Debug.Log("break here");
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Refering to the code above, once we play we'll break and see the immediate window, right by the call stack. We can do little snippets of code like two plus two or we can do the Mathf power function. When passing in parameters you need to ensure that you use the float designator for floats (0.0f), otherwise it's going to give you an error. It's not going to automatically convert values for you like it does in the compiler. We can also get the value of our variables, or do calculations.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Stuff that's not going to work is stuff like debugging outputs, because this requires the code to be running, this is only for analyzing and altering the static state of the code. We can also examine arrays, for example. Like an array of floats. We can find a value in the arrays. We can also do things like setting values.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Something else we can do that is very powerful is running our method calls. This will run the call with whatever values you give it. For example we could change the values for a weapon attack and then call CalculateAttack to find out the details you need about those changed values. This would be very useful for figuring out a infinite loop error.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The immediate window is not only useful for testing if a specific set of inputs causes an error. It's also a great way to test various inputs to make sure the output is what you are expecting. The immediate window in Unity is lacking some nice features like code completion, but it can still be a valuable tool.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="informative-and-visual">
    <h2>Informative and Visual Debugging</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Let's look at some tips you can use in Unity for better visual and informative debugging. Visual debugging is useful in situations where we have data that is more easily represented in visual form. For example, drawing a line to indicate the heading of an object is a bit easier to understand than reading the rotation and position value of that object. I'll teach you about overwriting the ToString method, to allow us to more quickly debug code, and make debugging outputs more human readable. First, let's look at some of the visual debugging. All of the visual debugging in Unity is done through Gizmos, and we can see those in the Scene/Game ribbon.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Gizmos are very useful for visual debugging, however they are only in the debugger and it's only when the Gizmos button is checked. They're most useful in situations like movement, rotations, collisions or algorithms like pathfinding, anything where it's easier to see the data visually instead of trying to imagine the numbers. We have various options for drawing Gizmos.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            All the drawing for Gizmos is done in the OnDrawGizmos() method. Let's look at some Gizmos code.
            <pre>
            <span class="glyphicon-remove"></span>public void OnDrawGizmos() {
                //if there are any object in range, draw the range and make it red.
                if(currentlyInRange) {
                    Gizmos.color = Color.red;
                    Gizmos.DrawWireSphere(this.transform.position, activationRadius);
                    Gizmos.color = Color.white; //reset the color after we're done.
                }

                // For each object of interest, draw a line to show we're currently tracking them.
                Gizmos.color = Color.green;
                foreach(GameObject go in targeted) {
                    Gizmos.DrawLine(this.transform.position, go.transform.position);
                }
                Gizmos.color = Color.white; // always reset the color at the end, so we don't change the color of any other gizmo.
            }
            </pre>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="log-exceptions">
    <h2>Logging Exceptions</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Exceptions can happen for a number of reasons and you can't always prepare for all of them. Play testing is important and can help you find a lot of exceptions while your game is still in a controlled environment. However, once your game leaves your development machine, it's not easy to predict all of the situations or unique ways users will try to use your game. When your game gets out into the world, you still want to be able to track down exceptions and create patches to fix or gracefully handle exceptions. Ideally you want to be able to do this even if you can't produce the same problem on your own machine.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            For this we can produce a log file that will tell us exactly what the user was doing when it encountered an exception. For this we're going to use a method called Application.RegisteredLogCallback(). This register log callback method is going to accept a delegate method. The delegate method is going to pass in a method as a parameter. This will be covered further in the events and messaging section. Essentially what we're telling Unity with this RegisterLogCallback, is we're going to pass in our own method and say call this whenever you register a log. Let's take an initial look at some code:
            <pre>
            <span class="glyphicon-remove"></span>public class ExceptionLogging : MonoBehaviour {
                public string saveFile = @"Log.txt";
                private StringWriter logWriter;

                void OnEnable() {
                    Application.RegisterLogCallback(ExceptionWriter);
                }

                void OnDisable() {
                    Application.RegisterLogCallback(null);
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The ExceptionWriter method that we're going to pass in is going to take a log string, stack trace and type. We're going to use a switch on the type, and if that's an exception or an error, we're going to open the log file and write to it. We're going to write the type, log, and stack trace here. We also have an exception generator calss that's going to generate exceptions for us so we can test this out. Let's see what it looks like. So, hitting space will generate an exception for us. And we see that we do have a divide by zero exception, and it gives us the line number, and if we look at our file location, we can see that a log file has been generated, and it matches the log generated by the Unity editor. Lets see the code.
            <pre>
            <span class="glyphicon-remove"></span>public class ExceptionLogging : MonoBehavior {
                //Previous code...

                void ExceptionWriter(string logString, string stackTrace, LogType type) {
                    switch(type) {
                        case LogType.Exception:
                        case LogType.Error:
                            using(StreamWriter writer = new StreamWriter(new FileStream(saveFile, FileMode.Append))) {
                                writer.WriteLine(type);
                                writer.WriteLine(logString);
                                writer.WriteLine(stackTrace);
                            }
                            break;
                        default;
                            break;
                    }
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Here is the ExceptionGenerator code as well:
            <pre>
            <span class="glyphicon-remove"></span>private int zero = 0;

            void Update() {
                if(Input.GetKeyDown(KeyCode.Space)) {
                    float exceptionValue = 10/zero;
                }
                if(Input.GetKeyDown(KeyCode.A)) {
                    throw new MissingComponentException("Missing a component.");
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The logging will be invaluable when tracking down issues in the field. Everyone knows eye witness testimony is unreliable. If a user has an issue have them send you the log. Of course it will help if they can explain what they were doing at the same time. The log file will help show you waht the user was doing leading up to their description of the events that caused the game to function improperly.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

                    <!-------------------------------------->
                </div>
            </div>
    </main>

    <!-------------------------------------------------------------------------->

    <!-- FOOTER -->
    <footer class="navbar navbar-inverse navbar-fixed-bottom">
        <nav>
            <div class="container">
                <div class="row">
                    <div class="col-md-6 col-sm-6 col-xs-12">
                        <ul>
                            <li>&copy; 2017 <a href="http://www.gabedeyo.com">Gabe Deyo</a></li>
                            <li>|</li>
                            <li><a href="mailto:gabedeyo@gmail.com?subject=Notes">gabedeyo@gmail.com</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>
    </footer>

    <!-- Latest Minified Slim JQuery -->
    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

    <script src="../js/selection.js" charset="utf-8"></script>
</body>

</html>

<!-- Section Template

<div class="jumbotron col-md-12 heliList" id="">
    <h2>XXX</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

-->
