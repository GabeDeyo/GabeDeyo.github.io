<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Design Patterns - Bytecode</title>

    <meta name="viewport" content="width=device-width,initial-scale=1.0, shrink-to-fit=no" />

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/page.css">
</head>

<body>

    <!-- Top Navigation -->
    <header>
        <nav class="navbar navbar-inverse">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapsemenu" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a href="../index.html" class="navbar-brand">Personal Notes</a>
                </div>

                <div class="collapse navbar-collapse" id="collapsemenu">
                    <ul class="nav navbar-nav">

                        <!-- GAME DEVELOMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Game Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- CONCEPTS -->
                                <li><a href="concepts.html">Concepts <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ENGINE -->
                                <li><a href="engine.html">Engine <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- IMPLEMENTATIONS -->
                                <li><a href="implementations.html">Implementations <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- PROGRAMMING -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Programming <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- ALGORITHMS -->
                                <li><a href="../code/algorithms.html">Algorithms <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PROBLEMS -->
                                <li><a href="../code/problems.html">Problems <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- RANDOM -->
                                <li><a href="../code/random.html">Random <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- GABE DEVELOPMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Gabe Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- FITNESS PAGE -->
                                <li><a href="../gabe/fitness.html">Fitness <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- STYLE & GROOMING PAGE -->
                                <li><a href="../gabe/style.html">Style <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- FINANCE PAGE -->
                                <li><a href="../gabe/finance.html">Finance <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PHILOSOPHY PAGE -->
                                <li><a href="../gabe/philosophy.html">Philosophy <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                    </ul>
                </div>

            </div>
        </nav>
    </header>

    <!-------------------------------------------------------------------------->

    <!-- MAIN -->
    <main>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h1 id="title">Design Patterns - Bytecode</h1>

                    <aside>
                        <button type="button" class="btn btn-default" name="button" id="selectAll">Select All</button>
                        <button type="button" class="btn btn-default" name="button" id="clearAll">Clear All</button>
                    </aside>

                    <div class="jumbotron heliList">
                        <h2>Index</h2>
                        <ul>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#intent">Intent</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#motivation">Motivation</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#bytecode">Bytecode</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#when-to-use">When to Use It</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#keep-in-mind">Keep In Mind</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#sample-code">Sample Code</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#design-decisions">Design Decisions</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#see-also">See Also</a>
                                </p>
                            </li>
                        </ul>
                    </div>

<div class="jumbotron col-md-12 heliList" id="intent">
    <h2>Intent</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            <i>Give behavior the flexibility of data by encoding it as instructions for a virtual machine.</i>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="motivation">
    <h2>Motivation</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Making games may be fun, but it certainly isn't easy. Modern games require enormous, complex codebases. Console manufacturers and app marketplace gatekeepers have stringent quality requirements, and a single crash bug can prevent your game from shipping.
            <p><span class="glyphicon-remove"></span>At the same time, we're expected to squeeze every drop of performance out of the platfrom. Games push hardware like nothing else, and we have to optimize relentlessly just to keep pace with the competition.</p>
            <p><span class="glyphicon-remove"></span>To handle these high stability and performance requirements, we reach for heavyweight languages like C++ that have both low-level expressiveness to make the most of the hardware and rich type systems to prevent or at least corral bugs.</p>
            <p><span class="glyphicon-remove"></span>We pride ourselves on our skill at this, but it has its cost. Being a proficient programmer takes years of dedicated training, after which you must contend with the sheer scale of your codebase. Build times for large games can vary somewhere between "go get a coffee" and "go roast your own beans, hand-grind them, pull an espresso, foam some milk, and practive you latte art in the froth".</p>
            <p><span class="glyphicon-remove"></span>On top of these challenges, games have one more nasty constraint to consider: <i>fun</i>. Players demand a play experience that's both novel and yet carefully balanced. That requires constant iteration, but if every tweak requires bugging an engineer to muck around in piles of low-level code and then waiting for a glacial recompile, you've mutilated your creative flow.</p>
            <p><span class="glyphicon-remove"></span>At the same </p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Spall Fight!</h3>
            <p><span class="glyphicon-remove"></span>Let's say we're working on a magic-based fighting game. A pair of wizards square off and fling enchantments at each other until a victor is pronounced. We could define these spells in code, but means an engieneer has to be involved every time one is modified. When a designer wants to tweak a few numbers and get a feel for them, they have to recompile the entire game, reboot it, and get back into a fight.</p>
            <p><span class="glyphicon-remove"></span>Like most games these days, we also need to be able to update the game after it ships, both to fix bugs and to add new content. If all of these spells are hard-coded, then updating them means patching the actual game executable.</p>
            <p><span class="glyphicon-remove"></span>Let's take things a bit further and say that we also want to support <i>modding</i>. We want <i>users</i> to be able to create their own spells. If those are in code, that means every modder needs a full compiler toolchain to build the game, and we have to release the sources. Worse, if they have a bug in their spell, it can crash the game on some other player's machine.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Data > code</h3>
            <p><span class="glyphicon-remove"></span>It's pretty clear that our engine's implementation language isn't the right fit. We need spells to be safely sandboxed from the core game. We want them to be easy to modify, easy to reload, and physically separate from the rest of the executable.</p>
            <p><span class="glyphicon-remove"></span>I don't know about you, but to me that sounds a lot like <i>data</i>. If we can define our behavior in separate data files that the game engine loads and "executes" in some way, we can achieve all of our goals.</p>
            <p><span class="glyphicon-remove"></span>We just need to figure out what "execute" means for data. How do you make some bytes ina file express behavior? There are a few ways to do this. I think it will help you get a picture of <i>this</i> pattern's strengths and weaknesses if we compare it to another one: the Interpreter pattern.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>The Interpreter Pattern</h3>
            <p><span class="glyphicon-remove"></span>This pattern starts with a language - think <i>programming</i> language - that you want to execute. Say for example, it supports arithmetic expressions like this:</p>
            <pre><span class="glyphicon-remove"></span>(1 + 2) * (3 - 4)</pre>
            <p><span class="glyphicon-remove"></span>Then, you take each piece of that expression, each rule in the language's grammer, and turn it into an <i>object</i>. The number literals will be objects: [1] [2] [3] [4]</p>
            <p><span class="glyphicon-remove"></span>Basically, the're little wrappers around the raw value. The operators will be objects too, they'll have references to their operands. If you tak into account the parentheses and precedence, that expression magically turn into a little tree of objects. At the top is multiplication, with addition and subtraction as children, and the number literals as children of those where they belong.</p>
            <p><span class="glyphicon-remove"></span>The Interpreter pattern isn't about <i>creating</i> that tree; it's about <i>executing</i> it. The way it works is pretty clever. Each object in the tree is an expression or a subexpression. In true object-oriented fashion, we'll let expressions evaluate themselves.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            First, we define a base interface that all expressions implement:
            <pre>
            <span class="glyphicon-remove"></span>class Expression {
                public virtual ~Expression() {}
                public virtual double evaluate() = 0;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Then, we define a class that implements this interface for each kind of expression in our language's grammar. The simplest one is numbers:
            <pre>
            <span class="glyphicon-remove"></span>Class NumberExpression : public Expression {
                public NumberExpression(double value) : value_(value) {}

                public virtual double evaluate() {
                    return value_;
                }

                private double value_;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            A literal number expression simply evaluates to its value. Addition and multiplication are a bit more complex because they contain subexpressions. Before they can evaluate themselves, they need to recursively evaluate their subexpressions. Like so:
            <pre>
            <span class="glyphicon-remove"></span>class AdditionExpression : public Expression {
                public AdditionExpression(Expression* left, Expression* right) : left_(left), right_(right) {}

                public virtual double evaluated() {
                    //Evaluate the operands
                    double left = left_->evaluate();
                    double right = right_->evaluate();

                    //Add them
                    return left + right;
                }

                private Expression* left_;
                private Expression* right_;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Pretty neat huh. Just a couple of simple classes and now we can represent and evaluate arbitrarily complex arithmetic expressions. We just need to create the right objects and wire them up correctly.
            <p><span class="glyphicon-remove"></span>It's a beautiful, simple pattern, but it has some problems. But imagine the expression tree from before and notice we have a lot of little boxes, and lots of arrows between them. Code is represented as a sprawling fractal tree of tiny objects. That has some unpleasant consequences:</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; Loading it from disk requires instantiating and wiring up tons of these small object.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; Those objects and the pointers between them use a lot of memory. On a 32-bit machine, that little arithmetic expression up there takes up at least 68 bytes, not including padding.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; Traversing the pointers into subexpressions is murder on your data chache. Meanwhile, all of those virtual method calls wreak carnage on your instruction cache.</p>
            <p><span class="glyphicon-remove"></span>Put those together, and what do they spell? S-L-O-W. There's a reason most programming languages in wide use aren't based on the Interpreter pattern. It's just too slow, and it uses up too much memory.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Machine Code, Virtually</h3>
            <p><span class="glyphicon-remove"></span>Consider our game. When we run it, the player's computer doesn't traverse a bunch of C++ grammar tree structures at runtime. Instead, we compile it ahead of time to machine code, and the CPU runs that. What's machine code got going for it?</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; <i>It's dense.</i> It's a solid, contiguous blob of binary data, and no bit goes to waste.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; <i>It's linear.</i> Instructions are packed together and executed one right after another. No jumping around in memory (unless you're doing actual control flow, of course)</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; <i>It's low-level.</i> Each instruction does one relatively minimal thing, and intering behavior comes from <i>composing</i> them.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; <i>It's fast.</i> As a consequence of all of these (well, and the fact that it's implemented directly in hardware), machine code runs like the wind.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            This sounds swell, but we don't want actual machine code for our spells. Letting users provide machine code which our game execute is just begging for security problems. What we need is a compromise between the performance of machine code and the safety of the Interpreter pattern.
            <p><span class="glyphicon-remove"></span>What if instead of loading actual machine code and executing it directly, we define our own <i>virtual</i> machine code? We'd then write a little emulator for it in our game. It would be similar to machine code - dense, linear, relatively low-level - but it would also be handled entirely by our game so we could safely sandbox it.</p>
            <p><span class="glyphicon-remove"></span>We'd call our little emulator a <i>virtual machine</i> (or "VM" for short), and the synthetic binary machine code it runs <i>bytecode</i>. It's got the flexibility and ease of use of defining things in data, but it has better performance than higher-level representations like the Interpreter pattern.</p>
            <p><span class="glyphicon-remove"></span>This sounds daunting, though. My goal for the rest of this chapter is to show you that if you keep you feature list pared down, it's actually pretty approachable. Even if you end up not using this pattern yourself, you'll at least have a better understanding of Lua and many other languages which are implemented using it.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="bytecode">
    <h2>Bytecode</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            An <b>instruction set</b> defines the low-level operations that can be performed. A series of instructions is encoded as a <b>sequence of bytes</b>. A <b>virtual machine</b> executes these instructions one at a time, using a <b>stack for intermediate values</b>. By combining instructions, complex high-level behavior can be defined.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="when-to-use">
    <h2>When to Use It</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            This is the most complex pattern in this book, and it's not something to throw into your game lightly. Use it when you have a lot of behavior you need to define and your game's implementation language isn't a good fit because:
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; It's too low-level, making it tedious or error-prone to program in.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; Iterating on it takes too long due to slow compile times or other tooling issues.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; It has too much trust. If you want to ensure the behavior being defined can't break the game, you need to sandbox it from the rest of the codebase.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Of course, that list describes a bunch of your game. Who doens't want a faster iteration loop and more safety? However, that doesn't come for free. Bytecode is slower than native code, so it isn't a good fit for performance-critical parts of your engine.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="keep-in-mind">
    <h2>Keep In Mind</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            There's something seductive about creating your own language or system-within-a=system. I'll be doing a minimal example here, but in the real world, these things tend to grow like vines.
            <p><span class="glyphicon-remove"></span>Every time I see someone define a little language or a scripting system, they say, "Don't worry, it will be tiny." Then, inevitably, they add more and more little features until it's a full-fledged language. Except, unlike some other languages, it grew in an ad-hoc, organic fashion and has all of the architectural elegance of a shanty town.</p>
            <p><span class="glyphicon-remove"></span>Of course, there's nothing <i>wrong</i> with making a full-fledged language. Just make sure you do so deliberately. Otherwise, be careful to control the scope of what your bytecode can express. Put a short leash on it before it runs away from you.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>You'll need a front-end</h3>
            <p><span class="glyphicon-remove"></span>Low-level bytecode instructions are great for performance, but a binary bytecode format is <i>not</i> what your users are going to author. One reason we're moving behavior out of code is so that we can express it at a <i>higher</i> level. If C++ is too low-level, making your users effectively write in assembly language - even one of your own design - isn't an improvement!</p>
            <p><span class="glyphicon-remove"></span>Much the the Interpreter pattern, it's assumed that you also have some way to <i>generate</i> the bytecode. Usually, users author their behavior in some higher-level format, and a tool translates that to the bytecode that our virtual machine understands. In other words, a compiler.</p>
            <p><span class="glyphicon-remove"></span>I know, that sounds scary. That's why I'm mentioning it here. If you don't have the resources to build and authoring too, then bytecode isn't for you. But we'll see later, it may not be as bad as you thing.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>You'll miss your debugger</h3>
            <p><span class="glyphicon-remove"></span>Programming is hard. We know what we want the machine to do, but we don't always communicate that correctly - we write bugs. To help find and fix those, we've amassed a pile of tools to understand what our code is doing wrong, and how to right it. We have debuggers, static analyzers, decompilers, et. All of those tools are designed to work with some existing language: either machine code or something higher level.</p>
            <p><span class="glyphicon-remove"></span>When you define your own bytecode VM, you leave those tools behind. Sure, you can step through the VM in your debugger, but that tells you what the VM <i>itself</i> is doing, and not what the bytecode it's interpreting is up to. It certainly doesn't help you map that bytecode back to the high-level form it was compiled from.</p>
            <p><span class="glyphicon-remove"></span>If the behavior you're defining is simple, you can scrape by without too much tooling to help you debug it. But as the scale of your content grows, plan to invest real time into features that help users see what their bytecode is doing. Those features might not ship in your game, but they'll be critical to ensure that you actually <i>can</i> ship your game.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="sample-code">
    <h2>Sample Code</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            After the previous couple of sections, you might be surprised how straightforward the implementation is. First, we need to craft an instruction set for our VM. Before we start thinking about bytecode and stuff, let's just think about it like an API.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>A Magical API</h3>
            <p><span class="glyphicon-remove"></span>If we are defining spells in straight C++ code, what kind of API would we need for that code to call into? What are the basic operations in the game engine that spells are defined in terms of?</p>
            <p><span class="glyphicon-remove"></span>Most spells ultimately change on of the stats of a wizard, so we'll start with a couple for that:</p>
            <pre>
            <span class="glyphicon-remove"></span>void setHealth(int wizard, int amount);
            void setWisdom(int wizard, int amount);
            void setAgility(int wizard, int amount);
            </pre>
            <p><span class="glyphicon-remove"></span>The first parameter identifies which wizard is affected, say 0 for the player's and 1 for their opponent. This way, healing spells can affect the player's own wizard, while damaging attacks harm their nemesis. These three little methods cover a surprisingly wide variety of magical effects.</p>
            <p>If the spells just silently tweaked stats, the game logic would be fine, but playing it would bore players to tears. Let's fix that:</p>
            <pre>
            <span class="glyphicon-remove"></span>void playSound(int soundId);
            void spawnParticles(int particleType);
            </pre>
            <p><span class="glyphicon-remove"></span>These don't effect gameplay, but they crank up the intensity of the gameplay <i>experience</i>. We could add more for camera shake, animation, etc., but this is enough to get us started.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>A Magical Instruction Set</h3>
            <p><span class="glyphicon-remove"></span>Now let's see how we'd turn this <i>programmatic</i> API into something that can be controlled from data. Let's start small and then we'll work our way up to the whole shebang. For now, we'll ditch all fo the parameters to these methods. We'll say the set__() methods always affect the player's own wizard and always max out that stat. Likewise, the FX operation always play a single hard-coded sound and particle effect.</p>
            <p><span class="glyphicon-remove"></span>Given that, a spell is just a series of instructions. Each one identifies which operation you want ot perform. We can enumerate them:</p>
            <pre>
            <span class="glyphicon-remove"></span>enum Instruction {
                INST_SET_HEALTH      = 0x00,
                INST_SET_WISDON      = 0x01,
                INST_SET_AGILITY     = 0x02,
                INST_PLAY_SOUND      = 0x03,
                INST_SPAWN_PARTICLES = 0x04
            }
            </pre>
            <p><span class="glyphicon-remove"></span>To encode a spell in data, we store an array of enum values. We've only got a few different primitives, so the range of enum values easily fits into a byte. This means the code for a spell is just a list of bytes - ergo "bytecode".</p>
            <p><span class="glyphicon-remove"></span>[0x00(Health), 0x03(Sound), 0x04(Particles)]</p>
            <p><span class="glyphicon-remove"></span>To execute a single instruction, we see which primitive it is and dispatch to the right API method:</p>
            <pre>
            <span class="glyphicon-remove"></span>switch(instruction) {
                case INST_SET_HEALTH:
                    setHealth(0, 100);
                    break;
                case INST_SET_WISDOM:
                    setWisdom(0, 100);
                    break;
                case INST_SET_AGILITY:
                    setAgility(0, 100);
                    break;
                case INST_PLAY_SOUND:
                    playSound(SOUND_BANG);
                    break;
                case INST_SPAWN_PARTICLES:
                    spawnParticles(PARTICLE_FLAME);
                    break;
            }
            </pre>
            <p><span class="glyphicon-remove"></span>In this way, our interpreter forms the bridge between code world and data world. We can wrap this in a little VM that executes an entire spell like so:</p>
            <pre>
            <span class="glyphicon-remove"></span>class VM {
                public void interpret(char bytecode[], int size) {
                    for(int i = 0; i < size; i++) {
                        char instruction = bytecode[i];
                        switch(instruction) {
                            //Cases for each instruction...
                        }
                    }
                }
            }
            </pre>
            <p><span class="glyphicon-remove"></span>Type that in and you'll have written your first virtual machine. Unfortunately, it's not very flexible. We can't define a spell that touches the player's opponent or lowers a stat, We can only play one sound!</p>
            <p><span class="glyphicon-remove"></span>To get something that starts to have the expressive feel of an actual language, we need to get parameters in here.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>A Stack Machine</h3>
            To execute a complex nested expression, you start with the innermost subexpressions. You calculate those, and the results flow outward as arguments to the expressions that contain them until evenutally, the whole expression has been evaluated.
            <p><span class="glyphicon-remove"></span>The Interpreter pattern models this explicitly as a tree of nested objects, but we want the speed of a flat list of instructions. We still need to ensure results from subexpressions flow to the right surrounding expressions. But, since our data is flattened, we'll have to use the <i>order</i> of the instructions to control that. We'll do it the same way your CPU does - with a stack.</p>
            <pre>
            <span class="glyphicon-remove"></span>class VM {
                public VM() : stackSize_(0) {}

                //Other stuff...

                private static const int MAX_STACK = 128;
                private int stackSize_;
                private int stack_[MAX_STACK];
            }
            </pre>
            <p><span class="glyphicon-remove"></span>The VM maintains an internal stack of values. In our example, the only kinds of values our instructions work with are numbers, so we can use a simple array of ints. Whenever a bit of data needs to work its way from one instructions to another, it get there through the stack.</p>
            <p><span class="glyphicon-remove"></span>Like the name implies, values can be pushed onto or popped off of the stack, so let's add a couple methods for that:</p>
            <pre>
            <span class="glyphicon-remove"></span>class VM {
                private void push(int value) {
                    // Check for stack overflow.
                    assert(stackSize_ < MAX_STACK);
                    stack_[stackSize_++] = value;
                }

                private int pop() {
                    // Make sure the stack isn't empty.
                    assert(stackSize_ > 0);
                    return stack_[--stackSize_];
                }

                // Other stuff...
            }
            </pre>
            <p><span class="glyphicon-remove"></span>When an instruction needs to receive parameters, it pops them off the stack like so:</p>
            <pre>
            <span class="glyphicon-remove"></span>switch(instruction) {
                case INST_SET_HEALTH:
                {
                    int amount = pop();
                    int wizard = pop();
                    setHealth(wizard, amount);
                    break;
                }
                case INST_SET_WISDOM:
                case INST_SET_AGILITY:
                    //Same as above

                case INST_PLAY_SOUND:
                    playSound(pop());
                    break;
                case INST_SPAWN_PARTICLES:
                    spawnParticles(pop());
                    break;
            }
            </pre>
            <p><span class="glyphicon-remove"></span>To get some values <i>onto</i> that stack, we need one more instruction: a literal. It represents a raw integer value. But where does it get its value from? How do we avoid some turtles-all-the-way-down infinite regress here?</p>
            <p><span class="glyphicon-remove"></span>The trick is to take advantage of the fact that our instruction stream is a sequence of bytes - we can stuff the number directly in the byte array. We define another instruction type for a number literal like so:</p>
            <pre>
            <span class="glyphicon-remove"></span>case INST_LITERAL:
            {
                // Read the next byte from the bytecode.
                int value = bytecode[++i];
                push(value);
                break;
            }
            </pre>
            <p><span class="glyphicon-remove"></span>[0x05(literal), 123(value)]</p>
            <p><span class="glyphicon-remove"></span>It reads the next byte in the bytecode stream <i>as a number</i> and pushes it onto the stack.</p>
            <p><span class="glyphicon-remove"></span>Let's string a few of these instructions together and watch the interpreter execute them to get a feel for how the stack works. We start with an empty stack and the interpreter pointing to the first instruction:</p>
            <p><span class="glyphicon-remove"></span> &nbsp; [<b>literal</b>, 0, literal, 10, health] - Stack: []</p>
            <p><span class="glyphicon-remove"></span>First, it executes the first INST_LITERAL. That reads the next byte from the bytecode(0) and pushes it onto the stack:</p>
            <p><span class="glyphicon-remove"></span> &nbsp; [literal, 0, <b>literal</b>, 10, health] - Stack: [0]</p>
            <p><span class="glyphicon-remove"></span>Then, it executes the second INST_LITERAL. That reads the 10 and pushes it:</p>
            <p><span class="glyphicon-remove"></span> &nbsp; [literal, 0, literal, 10, <b>health</b>] - Stack: [10, 0]</p>
            <p><span class="glyphicon-remove"></span>Finally, it executes INST_SET_HEALTH. That pops 10 and stores it in amount, then pops 0 and stores it in wizard. Then, it calls setHealth() with those parameters.</p>
            <p><span class="glyphicon-remove"></span>Ta-da! We've got a spell that sets the player's wizard's health to ten points. Now, we've got enough flexiblity to define spells that set either wizard's stats to whatever amount we want. We can also play different sounds and spawn particles.</p>
            <p><span class="glyphicon-remove"></span>But... this still feels like a <i>data</i> format. We can't, for example, raise a wizard's health by half of their wisdom. Our designers want to be able to express rules for spells, not just values.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Behavior = Composition</h3>
            <p><span class="glyphicon-remove"></span>If we think of our little VM like a programming language, all it supports now is a couple of built-in functions and constant parameters for them. To get bytecode to feel like <i>behavior</i>, what we're missing is <i>composition</i>.</p>
            <p><span class="glyphicon-remove"></span>Our designers need to be able to create expressions that combine different values in interesting ways. For a simple example, they want spells that modify a stat <i>by</i> a certain amount instead of to a certain amount.</p>
            <p><span class="glyphicon-remove"></span>That requires taking into account a stat's current value. We have instructions for <i>writing</i> a stat, but we need to add a couple to <i>read</i> stats:</p>
            <pre>
            <span class="glyphicon-remove"></span>case INST_GET_HEALTH: {
                int wizard = pop();
                push(getHealth(wizard));
                break;
            }

            case INST_GET_WISDOM:
            case INST_GET_AGILITY:
                //You get the idea
            </pre>
            <p><span class="glyphicon-remove"></span>As you can see, these work with the stack in both directions. They pop a parameter to determine which wizard to get the stat for, and then they look up the stat's value and push that back onto the stack.</p>
            <p><span class="glyphicon-remove"></span>This lets us write spells that copy stats around. We could create a spell that set a wizard's agility to their wisdom or a strange incantation that set one wizard's health to mirror his opponent's.</p>
            <p><span class="glyphicon-remove"></span>Better, but still quite limited. Next, we need arithmetic. It's time our baby VM learned how to add 1 + 1. We'll add a few more instructions. By now, you've probably got the hang of it and can guess how they look. I'll just show addition:</p>
            <pre>
            <span class="glyphicon-remove"></span>case INST_ADD:
            {
                int b = pop();
                int a = pop();
                push(a + b);
                break;
            }
            </pre>
            <p><span class="glyphicon-remove"></span>Like our other instructions, it pops a couple of values, does a bit of work, and then pushes the result back. Up until now, every new instruction gave us an incremental improvement in expressiveness, but we just made a big leap. It isn't obvious, but we can now handle all sorts of complicated, deeply nested arithmetic expressions.</p>
            <p><span class="glyphicon-remove"></span>Let's walk through a slightly more complex example. Say we want a spell that increases the player's wizard's health by the average of their agility and wisdom. In code, that's:</p>
            <pre>
            <span class="glyphicon-remove"></span>setHealth(0, getHealth(0) + (getAgility(0) + getWisdom(0)) / 2);
            </pre>
            <p><span class="glyphicon-remove"></span>You might think we'd need instructions to handle the explicit grouping that parentheses give you in the expression here, but the stack supports that implicitly. Here's how you could evaluate this by hand:</p>
            <p><span class="glyphicon-remove"></span> &nbsp; 1. Get the wizard's current health and remember it.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; 2. Get the wizard's agility and remember it.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; 3. Do the same for their wisdom.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; 4. Get those last two, add them, and remember the result.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; 5. Divide that by two and remember the result.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; 6. Recall the wizard's health and add it to that result.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; 7. Take that result and set the wizard's health to that value.</p>
            <p><span class="glyphicon-remove"></span>Do you see all of those "remembers" and "recalls"? Each "remember" corresponds to a push, and the "recalls" are pops. That means we can translate this to bytecode pretty easily. For example, the first line to get the wizard's current health is:</p>
            <pre>
            <span class="glyphicon-remove"></span>LITERAL 0
            GET_HEALTH
            </pre>
            <p><span class="glyphicon-remove"></span>This bit of bytecode pushes the wizard's health on to the stack. If we mechanically translate each line like that, we end up with a chunk of bytecode that evaluates our original expression. To give you a feel for how the instructions compose, I've done this below.</p>
            <p><span class="glyphicon-remove"></span>To show how the stack changes over time, we'll walk through a sample execution where the wizard's current stats are 45 health, 7 agility, and 11 wisdom. Next to each instruction is what the stack looks like after executing it and then a little comment explalining the instructions purpose:</p>
            <pre>
            <span class="glyphicon-remove"></span>LITERAL 0   [0]            // Wizard index
            LITERAL 0   [0, 0]         // Wizard index
            GET_HEALTH  [0, 45]        // getHealth()
            LITERAL 0   [0, 45, 0]     // Wizard index
            GET_AGILITY [0, 45, 7]     // getAgility()
            LITERAL 0   [0, 45, 7, 0]  // Wizard index
            GET_WISDOM  [0, 45, 7, 11] // getWisdom()
            ADD         [0, 45, 18]    // Add agility and wisdom
            LITERAL 2   [0, 45, 18, 2] // Divisor
            DIVIDE      [0, 45, 9]     // Average agility and wisdom
            ADD         [0, 54]        // Add average to current health
            SET_HEALTH  []             // Set health to result
            </pre>
            <p><span class="glyphicon-remove"></span>If you watch the stack at each step, you can see how data flows through it almost like magic. We push 0 for the wizard index at the beginning, and it just hangs around at the bottom of the stack until we finally need it for the last SET_HEALTH at the end.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>A Virtual Machine</h3>
            <p><span class="glyphicon-remove"></span>I could keep going, adding more and more instructions, but this is a good place to stop. As it is, we've got a nice little VM that lets us define fairly open-ended behavior using a simple, compact data format. While "bytecode" and "virtual machines" sound intimidating, you can see they're often as simple as a stack, a loop, and a switch statement.</p>
            <p><span class="glyphicon-remove"></span>Remember our original goal to have behavior be nicely sandboxed? Now that you've seen exactly how the VM is implemented, it's obvious that we've accomplished that. The bytecode can't do anything malicious or reach out into weird parts of the game engine because we've only defined a few instructions that touch the rest of the game.</p>
            <p><span class="glyphicon-remove"></span>We control how much memory it uses by how big of a stack we create, and we're careful to make sure it can't overflow that. We can even control how much <i>time</i> it uses. In our instruction loop, we can track how many we've executed and bail out if it goes over some limit.</p>
            <p><span class="glyphicon-remove"></span>there's just one problem left: actually creating the bytecode. So far, we've taken bits of pseudocode and compiled them to bytecode by hand. Unless you've got a lot of free time, that's not going to work in practice.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Spellcasting Tools</h3>
            <p><span class="glyphicon-remove"></span>One of our initial goals was to have a <i>higher</i>-level way to author behavior, but we've gone and created something lower-level than C++. It has the runtime performance and safety we want, but absolutely none of the designer-friendly usability.</p>
            <p><span class="glyphicon-remove"></span>To fill that gap, we need some tooling. We need a program that lets users define the high-level behavior of a spell and then takes that and generates the appropriate low-level stack machine bytecode.</p>
            <p><span class="glyphicon-remove"></span>That probably sounds way harder than making the VM. Many programmers were dragged through compilers class in college and took away from it nothing but PTSD triggered by the sight of a book with a dragon on the cover or the words "lex" and "yacc".</p>
            <p><span class="glyphicon-remove"></span>In truth, compiling a text-based language isn't that bad, thoug it's a bit too broad of a topic to cram here. However, you don't even have to do that. What I said we need is a <i>tool</i> - it doesn't have to be a compiler whose input format is a <i>text file</i>.</p>
            <p><span class="glyphicon-remove"></span>On the contrary, I encourage you to consider building a graphical interface to let users define their behavior, especially if the people using it won't be highly technical. Writing text that's free of syntax errors is difficult for people who haven't spent years getting used to a compiler yelling at them.</p>
            <p><span class="glyphicon-remove"></span>Instead, you can build an app that lets users "script" by clicking and dragging little boxes, pulling down menu items, or whatever else makes sense for the kind of behavior you want them to create.</p>
            <p><span class="glyphicon-remove"></span>The nice thing about this is that your UI can make it impossible for users to create "invalid" programs. Instead of vomiting error messages on them, you can proactively disable buttons or provide default values to ensure that the thing they've created is valid at all points in time.</p>
            <p><span class="glyphicon-remove"></span>This spares you from designing a grammar and writing a parser for a little language. but, I know, some of you find UI programming equally unpleasant. Well, in that case, there is no good news for you.</p>
            <p><span class="glyphicon-remove"></span>Ultimately, this pattern is about expressing behavior in a user-friendly, high-level way. You have to craft the user experience. To execute the behavior efficiently, you then need to translate that into a lower-level form. It is real work, but if you're up to the challenge, it can pay off.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="design-decisions">
    <h2>Design Decisions</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            <h3>How do instructions access the stack?</h3>
            <p><span class="glyphicon-remove"></span>Bytecode VMs come in two main flavors: stack-based and register-based. In a stack-based BM, instructions always work from the top of the stack, like in our sample code. For example, INST_ADD pops two values, adds them, and pushes the result.</p>
            <p><span class="glyphicon-remove"></span>Register-based VMs still have a stack. The only difference is that instructions can read their inputs from deeper in the stack. Instead of INST_ADD always <i>popping</i> its operands, it has two indexes stored in the bytecode that identify where in the stack to read the operands from.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>With a stack-based VM:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>Instructions are small.</i> Since each instruction implicitly finds its arguments on top of the stack, you don't need to encode any data for that. This mean seach instruction can be pretty small, usually a single byte.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>Code generation is simpler.</i> When you get around to writing the compiler or tool that outputs bytecode, you'll find it simpler to generate stack-based bytecode. Since each instruction implicitly works form the top of the stack, you just need to output instructions in the right order to pass parameters between them.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>You have more instructions</i>. Each instruction only sees the very top of the stack. This means that to generate code for something like a = b + c, you need to separate instructions to move b and c to the top of the stack, perform the operation, then move the result into a.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>With a register-based VM:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>Instructions are larger.</i> Since instructions need arguments for stack offsets, a single instruction needs more bits. For example, an instruction in Lua - probably the most well-known register-based VM - is a full 32-bits. It uses 6 bits for the instruction type, and the rest are arguments.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>You have fewer instructions.</i> Since each instruction can do more work, you don't need as many of them. Some say you get a performance improvement since you don't have to shuffle values around in the stack as much.</p>
            <p><span class="glyphicon-remove"></span>So which should you do? My recommendation is to stick with a stack-based VM. They're simpler to implement and much simpler to generate code for. Register-based VMs got a reputation for being a bit faster after Lua converted to that style, but it depends <i>deeply</i> on your actual instructions and on lots of other details of your VM.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>What instructions do you have?</h3>
            <p><span class="glyphicon-remove"></span>Your instruction set defines the boundaries of what can and cannot be expressed in bytecode, and it also has a big impact on the performance of you VM. Here's a laundry list of the different kinds of instructions you may want:</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>External Primitives.</b> These are the ones that reach out of the VM into the rest of the game engine and do stuff that the user can see. They control what kinds of real behavior can be expressed in bytecode. Without these, your VM can't do anything more than burn CPU cycles.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>Internal Primitives.</b> These manipulate values inside the VM - things like literals, arithmetic, comparison operators, and instructions that juggle the stack around.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>Control Flow.</b> Our example didn't cover these, but hwen you want behavior that's imperative and conditionally exectues instructions or loops and executes instuctions more than once, you need control flow. In the low-level language of bytecode, the're surprisingly simple: jumps.
            <br>In our instruction loop, we had an index to track where we were in the bytecode. All a jump instruction does is modify that variable and change where we're currently executing. In other words, it's a goto. You can build all kinds higher-level control flow using that.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>Abstraction.</b> If your users start defining a <i>lot</i> of stuff in data, eventually they'll want to start reusing bits of bytecode instead of having to copy and paste it. You may wan something like callable procedures.
            <br>In their simplest form, procedures aren't much more complex than a jump. The only difference is that the VM maintains a second <i>return</i> stack. When it executes a "call" instruction, it pushes the current instruction index onto the return stack and then jumps to the called bytecode. When it hits a "return", the VM pops the index from the return stack and jumps back into it.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>How are values represented?</h3>
            <p><span class="glyphicon-remove"></span>Our sample VM only works with one kind of value, integers. That makes answering this easy -  the stack is just a stack of ints. A more full-featured VM will suuport different data types: string, objects, lists, etc. You'll have to decide how those are stored internally.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>A single datatype:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>It's simple.</i> You don't have to worry about tagging, conversions, or type-checking.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>You can't work with different datatypes.</i> This is the obvious downside. Cramming different types into a single representation - think storing numbers as strings - is asking for pain.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>A tagged variant:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; This is the common representation for dynamically typed languages. Every value has two pieces. The first is a type tag - an enum - that identifies what data type is being stored. The rest of the bits are then interpreted appropriately according to that type, like:</p>
            <pre>
            <span class="glyphicon-remove"></span>enum ValueType {
                TYPE_INT,
                TYPE_DOUBLE,
                TYPE_STRING
            };

            struct Value {
                ValueType type;
                union {
                    int    intValue;
                    double doubleValue;
                    char*  stringValue;
                };
            };
            </pre>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>Values know their type.</i> The nice thing about this representation is that you can check thetype of a value at runtime. That's important for dynamic dispatch and for ensuring that you don't try to perform operations on types that don't support it.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>It takes more memory.</i> Every value has to carry around a few extra bits with it to identify its type. In something as low-level as a VM, a few bits here and there add up quickly.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>An untagged union:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; This uses a union like the previous form but it does <i>not</i> have a type tag that goes along with it. You have a little blob of bits that could represent more than one type, and it's up to you to ensure you don't misinterpret them.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; This is how statically typed languages represent things in memory. Since the type system ensures at compile time that you aren't misinterpreting values, you don't need to validate it at runtime.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>It's compact.</i> You can't get any more efficient than storing just the bits you need for the value itself.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>It's fast.</i> Not having type tags implies you're not spending cycles checking them at runtime either. This is one of the reasons statically typed languages tend to be faster than dynamic ones.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>It's unsafe.</i> This is the real cost, of course. A bad chunk of bytecode that causes you to misinterpret a value and treat a number like a pointer or vice versa can violate the security of your game or make it crash.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>An interface:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; The object-oriented solution for a value that maybe be one of several different types is through polymorphism. An interface provides virtual methods for the various type tests and conversions, along the lines of:</p>
            <pre>
            <span class="glyphicon-remove"></span>class Value {
                public virtual ~Value() {}

                public virtual ValueType type() = 0;

                public virtual int asInt() {
                    // Can only call this on ints.
                    assert(false);
                    return 0;
                }

                //Other conversion methods...
            }
            </pre>
            <p><span class="glyphicon-remove"></span>Then you have concrete classes for each specific data type, like:</p>
            <pre>
            <span class="glyphicon-remove"></span>class IntValue : public Value {
                public IntValue(int value) : value_(value) {}

                public virtual ValueType type() { return TYPE_INT; }
                public virtual int asInt() { return value_; }

                private int value_;
            }
            </pre>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>It's open-ended.</i> You can define new value types outside of the core VM as long as they implement the base interface.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>It's object-oriented.</i> If you adhere to OOP principles, this does things the "right" way and uses polymorphic dispatch for type-specific behavior instead of something like switching on a type tag.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>It's verbose.</i> You have to define a separate class with all of the associated ceremonial verbiage for each data type.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>It's inefficient.</i> To get polymorphism, you have to go through a pointer, which means even tiny values like Booleans and numbers get wrapped in objects that are allocated on the heap. Every time you touch a value, you have to do a virtual method call.
            <br>In something like the core of a virtual machine, small performance hits like this quickly add up. In fact, this suffers from many of the problems that caused us to avoid the Interpreter pattern, except now the problem is in our <i>values</i> instead of our <i>code</i>.</p>
            <p><span class="glyphicon-remove"></span>My recommendation is that if you can stick with a single data type, do that. Otherwise, do a tagged union. That's what almost every language interpreter in the world does.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>How is the bytecode generated?</h3>
            <p><span class="glyphicon-remove"></span>The most important question is saved for last. I've walked you through the code to <i>consume</i> and <i>interpret</i> bytecode, but i'ts up to you to build something to <i>produce</i> it. The typical solution here is to write a compiler, but that's not the only option.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>If you define a text-based language:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>You have to define a syntax.</i> Both amateur and professional language designers categorically underestimate how difficult this is to do. Defining a grammar that makes parsers happy is easy. Defining one that makes <i>users</i> happy is hard.
            <br>Syntax design is user interface design, and that process doesn't get easier when you constrain the user interface to a string of characters.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>You have to implementa a parser.</i> Despite their reputation, this part is pretty easy. Either use a parser generator like ANTLR or Bison, or - like I do - hand-roll a little recursive descent one, and you're good to go.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>You have to handle syntax errors.</i> This is one of the most important and most difficult parts of the process. When users make syntax and semantic errors - which they will, constantly - it's your job to guide them back onto the right path. Giving helpful feedback isn't easy when all you know is that your parser is sitting on some unexpected punctuation.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>It will likely turn off non-technical users.</i> We programmer like text files. Combined with powerful command-line tools, we think of them as the LEGO blocks of computing - simple, but easily composable in a million ways.
            <br>Most non-programmers don't think of plaintext like that. To them, text files feel like filling in tax forms for an angry robotic auditor that yells at them if they forget a single semicolon.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>If you define a graphical authoring tool:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>You have to implement a user interface.</i> Buttons, clicks, drags, stuff like that. Some cringe at the idea of this, but I personally love it. If you go down this route, it's importnat to treat designing the user interface as a core part of doing your job well - not just an unpleasant task to be muddled through.
            <br>Every little bit of extra work you do here will make your tool easier and more pleasant to use, and that directly leads to better content in your game. If you look behind many of the games you love, you'll often find the secret was fun authoring tools.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>You have fewer error cases.</i> Because the user is building behavior interactively one step at a time, your application can guide them away form mistakes as soon as they happen.
            <br>With a text-based language, the tool doesn't see <i>any</i> of the user's content until they throw an entire file at it. That makes it harder to prevent and handle errors.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>Portability is harder.</i> The nice thing about text compilers is that text files are universal. A simple compiler just reads in one file and writes one out. Porting that across operating systems is trivial.
            <br>When you're building a UI, you have to choose which framework to use, and many of those are specific to one OS. There are cross-platform UI toolkits too, but those often get ubiquity at the expense of familiarity - they feel equally foreign on all platforms.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="see-also">
    <h2>See Also</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            &bull; This pattern's close sister is the Gang of Four's Interpreter pattern. Both give you a way to express composable behavior in terms of data.
            <p><span class="glyphicon-remove"></span>In fact, you'll often end up using <i>both</i> patterns. The tool you use to generate bytecode will have an internal tree of objects that represents the code. This is exactly what the Interpreter pattern expects.</p>
            <p><span class="glyphicon-remove"></span>In order to compile that to bytecode, you'll have to walk the tree, just like you do to interpret it with the Interpreter pattern. The <i>only</i> difference is that instead of executing a primitive piece of behavior immediately, you output the bytecode instruction to perform that later.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The Lua programming language is the most widely used scripting language in games. It's implemented internally as a very compact register-based bytecode VM.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Kismet is a graphical scripting tool built into UnrealEd, the editor for the Unreal engine.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Wren is a simple little stack-based bytecode interpreter.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

                    <!-------------------------------------->
                </div>
            </div>
    </main>

    <!-------------------------------------------------------------------------->

    <!-- FOOTER -->
    <footer class="navbar navbar-inverse navbar-fixed-bottom">
        <nav>
            <div class="container">
                <div class="row">
                    <div class="col-md-6 col-sm-6 col-xs-12">
                        <ul>
                            <li>&copy; 2017 <a href="http://www.gabedeyo.com">Gabe Deyo</a></li>
                            <li>|</li>
                            <li><a href="mailto:gabedeyo@gmail.com?subject=Notes">gabedeyo@gmail.com</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>
    </footer>

    <!-- Latest Minified Slim JQuery -->
    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

    <script src="../js/selection.js" charset="utf-8"></script>
</body>

</html>

<!-- Section Template

<div class="jumbotron col-md-12 heliList" id="">
    <h2>XXX</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

-->
