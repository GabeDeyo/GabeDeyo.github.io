<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Design Patterns - State</title>

    <meta name="viewport" content="width=device-width,initial-scale=1.0, shrink-to-fit=no" />

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/page.css">
</head>

<body>

    <!-- Top Navigation -->
    <header>
        <nav class="navbar navbar-inverse">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapsemenu" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a href="../index.html" class="navbar-brand">Personal Notes</a>
                </div>

                <div class="collapse navbar-collapse" id="collapsemenu">
                    <ul class="nav navbar-nav">

                        <!-- GAME DEVELOMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Game Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- CONCEPTS -->
                                <li><a href="concepts.html">Concepts <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ENGINE -->
                                <li><a href="engine.html">Engine <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- IMPLEMENTATIONS -->
                                <li><a href="implementations.html">Implementations <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- PROGRAMMING -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Programming <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- ALGORITHMS -->
                                <li><a href="../code/algorithms.html">Algorithms <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PROBLEMS -->
                                <li><a href="../code/problems.html">Problems <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- RANDOM -->
                                <li><a href="../code/random.html">Random <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- GABE DEVELOPMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Gabe Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- FITNESS PAGE -->
                                <li><a href="../gabe/fitness.html">Fitness <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- STYLE & GROOMING PAGE -->
                                <li><a href="../gabe/style.html">Style <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- FINANCE PAGE -->
                                <li><a href="../gabe/finance.html">Finance <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PHILOSOPHY PAGE -->
                                <li><a href="../gabe/philosophy.html">Philosophy <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                    </ul>
                </div>

            </div>
        </nav>
    </header>

    <!-------------------------------------------------------------------------->

    <!-- MAIN -->
    <main>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h1 id="title">Design Patterns - State</h1>

                    <aside>
                        <button type="button" class="btn btn-default" name="button" id="selectAll">Select All</button>
                        <button type="button" class="btn btn-default" name="button" id="clearAll">Clear All</button>
                    </aside>

                    <div class="jumbotron heliList">
                        <h2>Index</h2>
                        <ul>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#introduction">Introduction</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#mistakes">We've All Been There</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#fsm">Finite State Machine to the Rescue</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#enums-and-switches">Enums &amp; Switches</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#state">State</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#state-objects">Where are the State Objects?</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#enter-and-exit">Enter &amp; Exit Actions</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#the-catch">What's the Catch?</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#concurrent-state-machines">Concurrent State Machines</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#hierarchical-state-machines">Hierarchical State Machines</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#pushdown-automata">Pushdown Automata</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#usefulness">So How Useful Are They?</a>
                                </p>
                            </li>
                        </ul>
                    </div>

<div class="jumbotron col-md-12 heliList" id="introduction">
    <h2>Introduction</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            This is a long and important chapter so buckle up. This topic does cover aspects of game development, however, we can't take about that before talking about <i>finite state machines</i> (FSMs). Also while we're there, we may as well cover <i>hierarchical state machines</i> and <i>pushdown automata</i>.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            State machines are well known to AI and compiler hackers, but they aren't as much with other programming circles. But they are very important, and we'll see how we can actually use them.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="mistakes">
    <h2>We've All Been There</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Let look at one of the first problems game developers encounter when first working on a character. We're working on a side-scrolling platformer. Our job is to implement the heroine that is the player's avatar into the game world. That means that she needs to respond to user input. Push the B button and she should jump.
            Simple Enough:
            <pre>
            void Heroine::handleInput(Input input) {<span class="glyphicon-remove"></span>
                if(input == PRESS_B) {
                    yVelocity_ = JUMP_VELOCITY;
                    setGraphics(IMAGE_JUMP);
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            First-timers may miss the mistake here, but veterans know exactly what will happen. There's nothing to prevent "air-jumping" - keeping hitting B and the heroine will keep climbing. The simple fix is to add a isJumping_ bool field to Heroine that tracks when she's jumping:
            <pre>
            void Heroine::handleInput(Input input) {<span class="glyphicon-remove"></span>
                if(input == PRESS_B) {
                    if(!isJumpin_) {
                        isJumping_ = true;
                        // Jump...
                    }
                }
            }
            </pre>
            <p>We would also need code to set isJumping_ to false. Omitted for brevity's sake.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Next, we want the heroine to duck if the player pressed down while she's on the ground and stand when the button is released.
            <pre>
            void Heroine::handleInput(Input input) {<span class="glyphicon-remove"></span>
                if(input == PRESS_B) {
                    //Jump if not jumping
                } else if(input == PRESS_DOWN) {
                    if(!isJumping) {
                        setGraphics(IMAGE_DUCK);
                    }
                } else if(input == RELEASE_DOWN) {
                    setGraphics(IMAGE_STAND);
                }
            }
            </pre>
            <p>Again we have several issues with this code.
            <br>&nbsp; 1. Press down to duck.
            <br>&nbsp; 2. Press B to jump from a ducking position.
            <br>&nbsp; 3. Release down while still in the air.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The heroine will switch to her standing graphic in the middle of the jump. Time for another flag...
            <pre>
            void Heroine::handleInput(Input input) {<span class="glyphicon-remove"></span>
                if(input == PRESS_B) {
                    if(!isJumping_ &amp;&amp; !isDucking_) {
                        // Jump...
                    }
                } else if(input == PRESS_DOWN) {
                    if(!isJumping) {
                        isDucking_ = true;
                        setGraphic(IMAGE_DUCK);
                    }
                } else if(input == RELEASE_DOWN) {
                    if(isDucking_) {
                        isDucking_ = false;
                        setGraphics(IMAGE_STAND);
                    }
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Next, it would be great if the heroine did a dive attack if the player presses down in the middle of a jump:
            <pre>
            void Heroine::handleInput(Input input) {<span class="glyphicon-remove"></span>
                if(input == PRESS_B)
                    if(!isJumping_ &amp;&amp; !isDucking) {
                        // Jump...
                    }
                } else if(input == PRESS_DOWN) {
                    if(!isJumping_) {
                        isDucking_ = true;
                        setGraphics(IMAGE_DUCK);
                    } else {
                        isJumping_ = false;
                        setGraphic(IMAGE_DIVE);
                    }
                } else if(input == RELEASE_DOWN) {
                    if(isDucking_) {
                        // Stand...
                    }
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Everything may seem okay now, but we still have bugs. We check that you can't air jump while jumping, but not while diving. Yet another field...
            <br>Something is clearly wrong with this approach. Every time we touch this handful of code, we break something and need a fix. We need to add a bunch more moves - we haven't even added <i>walking</i> yet - but at this rate, it will collapse into a heap of bugs before we get anything workable.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Good programmers aren't just good at working out code, but instead have an intuition about which kinds of code are error-prone (like above), and steer away from them.
            <br>Complex branching and mutable state - fields that change over time - are two ofthose error-prone kinds of code, and the examples above have both.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="fsm">
    <h2>Finite State Machine to the Rescue</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            After struggling with the code above, you give up and write out by hand a <b>flowchart</b>. You draw a box for each thing the heroine can do: stand, jump, duck, and dive. When she can respond to a button press in one of those states, you draw an arrow from that box, label it with that button, and connect it to the state she changes to.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Well you've just created a <i>Finite State Machine</i>. They come from a branch of computer science called <i>automata theory</i> whose family of data structures also includes the famous Turing machine. FSMs are the most simple member of that family.
            <br>If you're still confused, a good analogy for a FSM si the old text adventure games like Zork. You have a world of rooms that are connected to each other by exits. You explore them by entering commands like "go north". This maps directly to a state machine: Each room is a state. The room you are in is the current state. Each rooms exists are its transitions. The navigation commands are the inputs.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The gist fo FSMS is this:
            <br>&nbsp; <b>You have a fixed <i>set of states</i> that the machine can be in.</b> For example, we have standing, jumping, ducking, and diving.
            <br>&nbsp; <b>The machine can only be in <i>one</i> state at a time.</b> Our heroine can't be jumping and standing simultaneously. In fact, preventing that is one reason we're going to use an FSM.
            <br>&nbsp; <b>A sequence of <i>inputs</i> or <i>events</i> is sent to the machine.</b> In our example, that's the raw button presses and releases.
            <br>&nbsp; <b>Each state has a set of <i>transitions</i>, each associated with an input and pointing to a state.</b> When an input comes in, if it matches a transition for the current state, the machine changes to the state that transition points to.
            <br>For example, pressing down while standing transitions to the ducking state. Pressing down while jumping transitions to diving. If no transition is defined for an input on the current state, the input is ignored.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Inn their pure form, that's the whole banana: states, inputs, and transitions. You can draw it out like a little flowchart. Unfortunately, the compiler doesn't recognize our scribbles, so how do we <i>implement</i> one? The State pattern is one method, but we'll need to start simpler.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="enums-and-switches">
    <h2>Enums &amp; Switches</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            One problem we have is that our Heroine class is that some combinations of thos bool fields aren't valid: isJumping_ and isDucking_ should never both be true, for example. When you have a handful of flags where only one is true at a time, that's a hintthat what you really want is an enum.
            <br>In this case, that enum is exactly the set of states for our FSM, so let's define that:
            <pre>
            enum State {<span class="glyphicon-remove"></span>
                STATE_STANDING,
                STATE_JUMPING,
                STATE_DUCKING,
                STATE_DIVING
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Instead of a bunch of flags, Heroine will have just one state_ field. We also flip the order of our branching. In the previous code, we switched on input, <i>then</i> on state. This kept the code for handling one button press together, but it smeared around the code for one state. We want to keep that together, so we switch on state first.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            That looks like this:
            <pre>
            void Heroine::handleInput(Input input) {<span class="glyphicon-remove"></span>
                switch (state_) {
                    case STATE_STANDING:
                        if(input == PRESS_B) {
                            state_ = STATE_JUMPING;
                            yVelocity_ = JUMP_VELOCITY;
                            setGraphics(IMAGE_JUMP);
                        } else if(input == PRESS_DOWN) {
                            state_ = STATE_DUCKING;
                            setGraphics(IMAGE_DUCK);
                        }
                        break;
                    case STATE_JUMPING:
                        if(input == PRESS_DOWN) {
                            state_ = STATE_DIVING;
                            setGraphics(IMAGE_DIVE);
                        }
                        break;
                    case State_DUCKING:
                        if(input == RELEASE_DOWN) {
                            state_ = STATE_STANDING;
                            setGraphics(IMAGE_STAND);
                        }
                        break;
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            This seems trivial, but it's a real improvement over the previous code. We still have some conditional branching, but we simplified the mutable state to a single field. All of the code for handling a single state is now nicely lumped together. This is the simplest way to implement a state machine and is fine for some uses.
            <br>A bonus to this method is the heroine can no longer be in an invalid state. With the bool flags, some sets of of values were possible but meaningless. With the enum, each value is valid.
            <br>Your problem may outgrow this solution though. Say we want to add a move where our heroine can duck for a while to charge up and unleash a special attack. While she's ducking, we need to track the charge time.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We need to add a chargeTime_ field to Heroine to store how long the attack has charged. Assume we already have an update() that gets called each frame. In there we add:
            <pre>
            void Heroine::update() {<span class="glyphicon-remove"></span>
                if(state_ == STATE_DUCKING) {
                    chargeTime_ ++;
                    if(chargeTime_ > MAX_CHARGE) {
                        superBomb();
                    }
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We need to reset the timer when she starts ducking, so we modify:
            <pre>
            void Heroine::handleInput(Input input) {<span class="glyphicon-remove"></span>
                switch(state_) {
                    case STATE_STANDING:
                        if(input == PRESS_DOWN) {
                            state_ = STATE_DUCKING;
                            chargeTime_ = 0;
                            setGraphics(IMAGE_DUCK);
                        }
                        //Handle other inputs...
                        break;
                        //Other states...
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            All in all, to add this charge attack, we have to modfy two methods and add a chargeTime_ field onto Heroine even though it's only meaningful while in the ducking state. What we'd prefer is to have all of that code and data nicely wrapped up in one place. This is where we can use <b>State</b>.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="state">
    <h2>State</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            For programmers depp into a OOP mindset, every conditional branch is an opportunity to use dynamic dispatch (a virtual method call). I think you can go too far down that rabbit hole. Sometimes an <i>f</i> is all you need.
            <br>But in our example, we've reached a tipping point where something OOP is a better fit. That puts us to the State pattern. First a description:
            <br> &nbps; <i>Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.</i>
            <br>That doesn't tell us much, however. And still our switch does that. The concrete pattern they describe looks like this when applied to our heroine.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>A State Interface</b>
            <br>First, we define an interface for the state. Every bit of behavior that is state-dependent - every place we had a switch before - becomes a virtual method in that interface. for use, that's handleInput() and update():
            <pre>
            class HeroineState {<span class="glyphicon-remove"></span>
                public virtual ~HeroineState() {}
                public virtual handleInput(Heroine&amp; heroine, Input input) {}
                public virtual update(Heroine&amp; heroine) {}
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Classes for Each State</b>
            <br>For each state, we define a class that implements the interface. Its methods define the heroine's behavior when in that state. In other words, take each case from the earlier switch statements and move them into their state's class. Like so:
            <pre>
            class DuckingState ; public HeroineState {<span class="glyphicon-remove"></span>
                public DuckingState() : chargeTime_(0) {}

                public virtual void handleInput(Heroine&amp; heorine, Input input) {
                    if(input == RELEASE_DOWN) {
                        //Change to standing state...
                        heroine.setGraphics(IMAGE_STAND);
                    }
                }

                public virtual void update(Heroine&amp; heroine) {
                    chargeTime_++;
                    if(chargeTime_ > MAX_CHARGE) {
                        heroine.superBomb();
                    }
                }

                private int chargeTime_;
            }
            </pre>
            <p>Note that we also moved chargeTime_ out of Heroine and into the DuckingState class. This is great - that piece of data is only meaningful while in that state, and now our object moel reflects that explicitly.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Delegate to the State</b>
            <br>Next, we give the Heroine a pointer to her current state, lose each big switch, and delegate to the state instead:
            <pre>
            class Heroine {<span class="glyphicon-remove"></span>
                public virtual void handleInput(Input input) {
                    state_->handleInput(*this, input);
                }

                public virtual void update() {
                    state_->update(*this);
                }

                // Other methods

                private HeroineState* state_;
            }
            </pre>
            <p>In order to "change state", we just need to assign state_ to point to a different HeroineState object. That's the State pattern in entirety.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="state-objects">
    <h2>Where are the State Objects?</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            We slightly skipped over something here. To change states, we need to assign state_ to point to the new one, but where does that object come from? With our enum implementation, that was a no-brainer - enum values are primitives like numbers. But now our states are classes, which means we need an actual instance to point to. There are two common answers to this:
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Static States</b>
            <br>If the state object doesn't have other fields, then the only data it stores is a pointer to the internal virtual method table so that its methods can be caled. In that case, there's no reason to ever have more than one instance of it. Every instance would be identical anyway.
            <br>In that case, you can make a single <i>static</i> instance. Even if you have a bunch of FSMs all going at the same time in that same state, they can all point to the same instance since it has nothing machine-specific about it.
            <br>Where you put that static instance is up to you. Find a place that makes sense. for no particular reason, let's put ours inside the base state class:
            <pre>
            class HeroineState {<span class="glyphicon-remove"></span>
                public static StandingState standing;
                public static DuckingState ducking;
                public static JumpingState jumping;
                public static DivingState diving;

                //Other code
            }
            </pre>
            <p>Each of those static fields is the one instance of that state that the game uses. To make the heroine jump, the standing stat would do something like: </p>
            <pre>
            if(input == PRESS_B) {<span class="glyphicon-remove"></span>
                heroine.state_ = &amp;HeroineState::jumping;
                heroine.setGraphic(IMAGE_JUMP);
            }
            </pre>
            <p>If your state has no fields and just one virtual method in it, you can simplify this pattern even more. Replace each state class with a state function - just a plain vanilla top-level function. Then, the state_ field in your main class becomes a simple function pointer. This is the <a href="design-patterns-flyweight.html">Flyweight</a> pattern.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <b>Instantiated States</b>
            <br>Sometimes, though, this doesn't fly. A static state won't work for the ducking state. It has a chargeTime_ field, and that's specific to the heroine that happens to be ducking. This may coincidentally work in our game if there's only one heroine, but if we try to add two-player co-op and have two heroines on scren at the same time, we'll have problems.
            <br>In that case, we have to create a state object when we transition to it. This lets each FSM have its own instance of the state. Of course, if we're allocating a new state, that means we need to free the <i>current</i> one. We have to be careful here, since the code that's triggering the change is in a method in the current state. We don't want to delete <i>this</i> out from under ourselves.
            <br>Instead we'll allow handleInput() in HeroineState to optionally return a new state. When it does, Heroine will delete the old one and swap in the new one, like so:
            <pre>
            void Heroine::handleInput(Input input) {<span class="glyphicon-remove"></span>
                HeroineState* state = state_->handleInput(*this, input);
                if(state != NULL) {
                    delete state_;
                    state_ = state;
                }
            }
            </pre>
            <p><span class="glyphicon-remove"></span>That way, we don't delete the previous state until we've returned from its method. Now, the standing state can transition to ducking by creating a new instance:</p>
            <pre>
            HeroineState* StandingState::handleInput(Heroine&amp; heroine, Input input) {<span class="glyphicon-remove"></span>
                if(input == PRESS_DOWN) {
                    // Other code...
                    return new DuckingState();
                }

                //Stay in this state.
                return NULL;
            }
            </pre>
            <p><span class="glyphicon-remove"></span>When I can, I prefer to use static states since they don't burn memory and CPU cycles allocating objects each state change. For states that are more, stateful... this is the way to go.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="enter-and-exit">
    <h2>Enter &amp; Exit Actions</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            The goal of the State pattern is to encapsulate all of the behavior and data for one state in a single class. We're partway there, but we still have some loose ends.
            <br>When the heroine changes state, we also switch her sprite. Right now, that code is owned by the state she's switching from. When she goes from ducking to standing, the ducking state sets her image:
            <pre>
            <span class="glyphicon-remove"></span>HeroineState* DuckingState::handleInput(Heroine&amp; heroine, Input input) {
                if(input == RELEASE_DOWN) {
                    heorine.setGraphics(IMAGE_STAND);
                    return new StandingState();
                }
                // Other code...
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            What we really want is each state to control its own graphics. We can handle that by giving the state an <i>entry action</i>:
            <pre>
            <span class="glyphicon-remove"></span>class StandingState : public HeroineState {
                public virtual void enter(Heroine&amp; heroine) {
                    heroine.setGraphics(IMAGE_STAND);
                }

                //Other code...
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Back in Heroine, we modify the code for handling state changes to call that on the new state:
            <pre>
            <span class="glyphicon-remove"></span>void Heroine::handleInput(Input input) {
                HeroineState* state = state_->handleInput(*this, input);
                if(state != NULL) {
                    delete state_;
                    state_ = state;

                    //Call the enter action on the new state.
                    state_->enter(*this);
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            This lets us simplify the ducking code to:
            <pre>
            <span class="glyphicon-remove"></span>HeroineState* DuckingState::handleInput(Heroine&amp; heroine, Input input) {
                if(input == RELEASE_DOWN) {
                    return new StandingState();
                }
                //Other code...
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            All it does is switch to standing and the standing state takes care of the graphics. Now our states really are encapsulated. On particularly nice thing about entry actions is that they run when you enter the state regardless of which state you're coming from.
            <br>Most real-world state graphs have multiple transitions into the same state. For example, our heroine will also end up standing after she lads a jump or dive. That means we would end up duplicating some code everywhere that transition occcurs. Entry actions give us a place to consolidate that.
            <br>We can, of course, also extend this to support an exit action. This is just a method we call on the state we're leaving right before we switch to the new state.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="the-catch">
    <h2>What's the Catch?</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            We've spent this whole time on FSMs, but now it's time for a reality check. Everything we've looked at is true and FSMs are a good fit for some problems. But their greatest virtue is also thier greatest flaw.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            State machines help you untangle hairy code by enforcing a very constrained structure on it. All you've got is a fixed set of states, a single current state, and some hardcoded transitions.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            A FSM isn't even Turing complete. Automata theory describes computation using a series of abstract models, each more complex than the previous. A Turing machine is one of the most expressive models.
            <br>"Turing complete" means a system (usually a programming language) is powerful enough to implement a Turing machinein it, which means all Turing complete languages are, in some ways equally expressive. FSMs are not flexible enough to be in that cool kid club.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            If you try using a state machine for something more complex like game AI, you will slam face-first into the limitations of this mode. Thankfully, our forebears have found ways to dodge some barriers. I'll close this chapter out by walking you through a couple of them.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="concurrent-state-machines">
    <h2>Concurrent State Machines</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            So we've decide to give our heroine the ability to carry a gun. When she's packing heat, she can still do everything she could before: run jump, duck, etc. But she also needs to be able to fire her weapon while doing it.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            If we want to stick to the confines of an FSM, we have to double the number of states we have. For each existing state, we'll need another one for doing the same thing while she's armed.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Add a couple more weapons and the number of states explodes combinatorially. Not only is it a huge number of states, it's a huge amount of redundancy: the unarmed and armed states are almost identical except for the little bit of code to handle firing.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The problem is that we've jammed two pieces of state - what she is <i>doing</i> and what she is <i>carrying</i> - into a single machine. To model all possible combinations, we would need a state for each pair. The fix is obvious: have two separate state machines.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We keep our original state machine for what she's doing and leave it alone. Then we define a separate state machine for what she's carrying. Heroine will have two "state" references, one for each, like:
            <pre>
            <span class="glyphicon-remove"></span>class Heroine {
                // Other code...
                private HeroineState* state_;
                private HeroineState* equiptment_;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            When the heroine delegates inputs to the states, she hands it to both of them:
            <pre>
            <span class="glyphicon-remove"></span>void Heroine::handlInput(Input input) {
                state_->handleInput(*this, input);
                equiptment_->handleInput(*this, input);
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Each state machine can then respond to inputs, spawn behavior, and change its state independently of the other machine. When the two sets of states are mostly unrelated, this works well.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In practice, you'll find a few cases where the states do interact. For example, maybe she can't fire while jumping, or maybe she can't do a dive attack if she's armed. To handle that, in the code for one state, you'll probably just do some crude if tests on the other machine's state to coordinate them. It's not the most elegant solution, but it gets the job done.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="hierarchical-state-machines">
    <h2>Hierarchical State Machines</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            After fleshing out our heroine's behavior some more, she'll likely have a bunch of similar states. For example, she may have standing, walking, running, and sliding states. In any of those, pressing B jumps and pressing down ducks.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            With a simple state machine implementaiton, we have to duplicate that code in each of those states. It would be better if we could implement that once and reuse it across all of those states.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            If this was just OOP code instead of a state machine, one way to share code across those states would be using an interface. We could define a class for an "on ground" state that handles jumping and ducking. Standing, walking, running, and sliding would then inherit from that and add their own additional behavior.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            It turns out, this is a common structure called a <i>hierarchical state machine</i>. A state can have a <i>superstate</i> (making itself a substate). When an event comes in, if the substate doesn't handle it, it rolls up the chain of superstates. In other words, it works just like overriding inherited methods.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In fact, if we're using the State pattern to implement our FSM, we can use class inheritance to implement the hierarchy. Define a base class for the superstate:
            <pre>
            <span class="glyphicon-remove"></span>class OnGroundState : public HeroineState {
                public virtual void handleInput(Heroine&amp; heroine, Input input) {
                    if(input == PRESS_B) {
                        // Jump...
                    } else if(input == PRESS_DOWN) {
                        // Duck...
                    }
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Then each substate inherites it:
            <pre>
            <span class="glyphicon-remove"></span>class DuckingState : public OnGroundState {
                public virtual void handleInput(Heroine&amp; heroine,Input input) {
                    if(input == RELEASE_DOWN) {
                        // Stand up...
                    } else {
                        //Didn't handle input, so walk up the hierarchy.
                        OnGroundState::handlInput(heroine, input);
                    }
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            This isn't the only way to implement the hierarchy, of course. If you aren't using the State pattern, this won't work. Instead, you can model the current state's chain of superstates explicitly using a <i>stack</i> of states instead of a single state in the main class.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The current state is the one on the top of the stack, under that is its immediate superstate, and the that state's superstate and so on. When you dish out some state-specific behavior, you start at the top of the stack and walk down until one of the states handles it. (If none do, you ignore it)
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="pushdown-automata">
    <h2>Pushdown Automata</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            There's another common extension to finite state machines that also uses a stack of states. Confusingly, the stack represents something entirely different, and is used to solve a different problem.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The problem is that finite state machines have no concept of history. You know what state you are in, but you have no memory of what state you were in. There's no easy way to go back to a previous state.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Here's an example: Earlier, we let our fearless heroine arm herself to the teeth. When she fires her gun, we need a new state that plays the firing animationand spawns the bullet and any visual effects. So we slap together a FiringState and make all of the states that she can fire from transitions into that when the fire buton is pressed.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The tricky part is what state she transitions to after firing. She can pop off a round while standing, running, jumping, and ducking. When the firing sequence is complete, she should transition back to what she was doing before.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            If we're sticking with a vanilla FSM, we've already forgotten what state she was in. To keep track of it, we'd have to define a slew of nearly identical states - firing while standing, firing while running, etc. - just so that each one can have a hardcoded transition that goes back to the right state when it's done.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            What we'd really like is a way to <i>store</i> the state she was in before firing and then <i>recall</i> it later. Again, automata theory is here to help. The relevant data structure is called a <i>pushdown automaton</i>.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Where a finite state machine has a <i>single</i> pointer to a state, a pushdown automaton has a <i>stack</i> of them. In an FSM, transitioning to a new state <i>replaces</i> the previous one. A pushdown automaton lets you do that, but it also gives you two additional operations:
            <br> &nbsp; 1. You can <i>push</i> a new state onto the stack. The "current" state is always the one on top of the stack, so this transitions to the new state. but it leaves the previous state directly under it on the stack instead of discarding it.
            <br> &nbsp; 2. You can <i>pop</i> the topmost state off the stack. That state is discarded, and the state under it becomes the new current state.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            This is just what we need for firing. We create a single firing state. When the fire button is pressed while in any other state, we push the firing state onto the stack. When the firing animation is done, we <i>pop</i> that state off, and the pushdown automaton automatically transitions right back to the state we were in before.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="usefulness">
    <h2>So How Useful Are They?</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Even with those common extensions to state machines, they are still pretty limited.The trend these days in game AI is more toward exciting things like behavior trees and planning systems. If complex AI isn't what you're interested in, all this chapter has done is whet your appetite. You'll want to read other books to satisfy it.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            This doesn't mean finite state machines, pushdown automata, and other simple systems aren't useful. They're a good modeling tool for certain kinds of problems. Finite state machines are useful when:
            <br> &nbsp; &bull; You have an entity whose behavior changes based on some internal state.
            <br> &nbsp; &bull; That state can be rigidly divided into one of a relatively small number of distinct options.
            <br> &nbsp; &bull; The entity responds to a series of inputs or events over time.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In games, they are most known for being used in AI, but they are also common in implementaitons of user input handling, navigating menu screens, parsing text, network protocols, and other asynchronous behavior.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

                    <!-------------------------------------->
                </div>
            </div>
    </main>

    <!-------------------------------------------------------------------------->

    <!-- FOOTER -->
    <footer class="navbar navbar-inverse navbar-fixed-bottom">
        <nav>
            <div class="container">
                <div class="row">
                    <div class="col-md-6 col-sm-6 col-xs-12">
                        <ul>
                            <li>&copy; 2017 <a href="http://www.gabedeyo.com">Gabe Deyo</a></li>
                            <li>|</li>
                            <li><a href="mailto:gabedeyo@gmail.com?subject=Notes">gabedeyo@gmail.com</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>
    </footer>

    <!-- Latest Minified Slim JQuery -->
    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

    <script src="../js/selection.js" charset="utf-8"></script>
</body>

</html>

<!-- Section Template

<div class="jumbotron col-md-12 heliList" id="">
    <h2>XXX</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            XXX
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

-->
