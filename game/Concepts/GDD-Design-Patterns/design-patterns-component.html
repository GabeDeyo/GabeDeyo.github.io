<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Design Patterns - Component</title>

    <meta name="viewport" content="width=device-width,initial-scale=1.0, shrink-to-fit=no" />

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="../../../css/page.css">
</head>

<body>

    <!-- Top Navigation -->
    <header>
        <nav class="navbar navbar-inverse">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapsemenu" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a href="../../../index.html" class="navbar-brand">Personal Notes</a>
                </div>

                <div class="collapse navbar-collapse" id="collapsemenu">
                    <ul class="nav navbar-nav">

                        <!-- GAME DEVELOMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Game Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- CONCEPTS -->
                                <li><a href="../../Categories/concepts.html">Concepts <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ENGINE -->
                                <li><a href="../../Categories/engine.html">Engine <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- IMPLEMENTATIONS -->
                                <li><a href="../../Categories/implementations.html">Implementations <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- PROGRAMMING -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Programming <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- LANGUAGES -->
                                <li><a href="../../../code/Categories/languages.html">Languages <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ALGORITHMS -->
                                <li><a href="../../../code/Categories/algorithms.html">Algorithms <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PROBLEMS -->
                                <li><a href="../../../code/Categories/problems.html">Problems <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- RANDOM -->
                                <li><a href="../../../code/Categories/random.html">Random <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- GABE DEVELOPMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Gabe Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- FITNESS PAGE -->
                                <li><a href="../../../gabe/Categories/fitness.html">Fitness <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- STYLE & GROOMING PAGE -->
                                <li><a href="../../../gabe/Categories/style.html">Style <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- FINANCE PAGE -->
                                <li><a href="../../../gabe/Categories/finance.html">Finance <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PHILOSOPHY PAGE -->
                                <li><a href="../../../gabe/Categories/philosophy.html">Philosophy <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                    </ul>
                </div>

            </div>
        </nav>
    </header>

    <!-------------------------------------------------------------------------->

    <!-- MAIN -->
    <main>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h1 id="title">Page Template</h1>

                    <aside>
                        <button type="button" class="btn btn-default" name="button" id="selectAll">Select All</button>
                        <button type="button" class="btn btn-default" name="button" id="clearAll">Clear All</button>
                    </aside>

                    <div class="jumbotron heliList">
                        <h2>Index</h2>
                        <ul>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#intent">Intent</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#motivation">Motivation</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#component">Component</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#when-to-use">When to Use It</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#keep-in-mind">Keep In Mind</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#sample-code">Sample Code</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#design-decisions">Design Decisions</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#see-also">See Also</a>
                                </p>
                            </li>
                        </ul>
                    </div>

<div class="jumbotron col-md-12 heliList" id="intent">
    <h2>Intent</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            <i>Allow a single entity to span multiple domains without coupling the domains to each other.</i>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="motivation">
    <h2>Motivation</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Let's say we're building a platformer. The Italian plumber demographic is covered, so ours will star a Danish baker, Bjorn. It stands to reason that we'll have a class representing our friendly pastry chef, and it will contain everything he does in the game.
            <p><span class="glyphicon-remove"></span>Since the player controls him,that means reading controller input and translating that input into motion. And, of corse, he needs to interact with the level, so some physics and collision go in there. Once that's done, he's got to show up on screen, so toss in animation and rendering. He'll probably play some sounds too.</p>
            <p><span class="glyphicon-remove"></span>Hold on a minute; this is getting out of control. Software Architecture 101 tells us that different domains in a program should be kept isolated from each other. If we're making a word processor, the code that handles printing shouldn't be affected by the code that loads and saves documents. A game doesn't have the same domain as a business app, but the rule still applies.</p>
            <p><span class="glyphicon-remove"></span>As much as possible, we don't want AI, physics, rendering, sound and other domains to know about each other, but now we've got all that crammed into one class. We've seen where this road leads to: a 5,000-line dumping ground source file so big that only the bravest ninja coders on your team even dare to go in there.</p>
            <p><span class="glyphicon-remove"></span>Thisis great job security for the few who can tame it, but it's hell for the rest of us. A class that big means even the most seemingly trivial changes can have far-reaching implications. Soo, the class collects <i>bugs</i> faster than it collects <i>features</i>.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>The Gordion Knot</h3>
            <p>Even worse than the simple scale problem is the coupling one. All of the different systems in our game have been tied into a giant knotted ball of code like:</p>
            <pre>
            <span class="glyphicon-remove"></span>if(collidingWithFloor() &amp;&amp; (getRenderState() != INVISIBLE)) {
                playSound(HIT_FLOOR);
            }
            </pre>
            <p><span class="glyphicon-remove"></span>Any programmer trying to make a change in code like that will need to know something about physics, graphics, and sound just to make sure they don't break anything.</p>
            <p><span class="glyphicon-remove"></span>These two problems compound each other; the class touches so many domains that every programmer will have to work on it, but it's so huge that doing so is a nightmare. If it gets bad enough, coders will start putting hacks in other parts of the codebase just to stay out of the hairball that this Bjorn class has become.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Culling the Knot</h3>
            <p><span class="glyphicon-remove"></span>We can solve this like Alexander the Great - with a sword. We'll take our monolithic Bjorn class and slice it into separate parts along domain boundaries. For example, we'll take all of the code for handling user input and move it into a separate InputComponent class. Bjorn will then own an instance of this component. We'll repeat this process for each of the domains that Bjorntouches.</p>
            <p><span class="glyphicon-remove"></span>When we're done, we'll have moved almost everything out of bjorn. All that remains is a thing shell that binds the components together. We've solved our huge class problem by simply divinding it up into multiple smaller classes, but we've accomplished more than just that.</p>
        </p></li>
        <li><p>
            <h3>Loose Ends</h3>
            <p><span class="glyphicon-remove"></span>Our component classes are now decoupled. Even though Bjorn has a PhysicsComponent and a GraphicsComponent, the two don't know about each other. This means the person working on physics can modify their component without needing to know anything about graphics and vice versa.</p>
            <p><span class="glyphicon-remove"></span>In practice, the components will need to have <i>some</i> interaction between themselves. For example, the AI component may need to tell the physics component where BJorn is trying to go. However, we can restrict this to the components that <i>do</i> need to talk instead of just tossing them all in the same playpen together.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Tying Back Together</h3>
            <p><span class="glyphicon-remove"></span>Another feature of this design is that the components are now reusable packages. So far, we've focused on our backer, but let's consider a couple of other kinds of objects in our game world. <i>Decorations</i> are things in the world the player sees but doesn't interact with: bushes, debris and other visual detail. <i>Propbs</i> are like decorations but can be touched: boxes, boulders, and trees. <i>Zones</i> are the opposite of decorations - invisible but interactive. They're useful for things like triggering a cutscene when Bjorn enters an area.</p>
            <p><span class="glyphicon-remove"></span>Now, consider how we'd set up an inheritance hierarchy for those classes if we weren't using components. A first passable idea might be:</p>
            <p><span class="glyphicon-remove"></span>Zone(Collision..)/Decoration(Rendering..) -> GameObject &amp;&amp; Prop(Rendering..) -> Zone(Collision)</p>
            <p><span class="glyphicon-remove"></span>We have a base GameObject class that has common stuff like position and orientation. Zone inherits from that and adds collision detection. Likewise, Decoration inherits from GameObejct and adds rendering. Prop inherits from zone, so it can reuse the collision code. However, Prop can't <i>also</i> inherit from Decoration to reuse the <i>rendering</i> code without running into the Deadly Diamon.</p>
            <p><span class="glyphicon-remove"></span>The "Deadly Diamond" occurs in class hierarchies with multiple inheritance where there are two different paths to the same base class. The pain that causes is a bit out of scope for this task, but understand that they named it "deadly" for a reason.</p>
            <p><span class="glyphicon-remove"></span>We could flip things around so that Prop inherits form Decoration, but then we end up having to duplicate the collision code. Either way, there's no clean way to reuse the collision and rendering code between the classes that need it without resorting to multiple inheritance. The only other option is to push everything up to GameObject, but then Zone is wasting memory on rendering data it doesn't need and Decoration is doing the same with physics.</p>
            <p><span class="glyphicon-remove"></span>Now, let's try it with components. Our subclasses disappear completely. Instead, we have a single GameObject class and two component classes: PhysicsComponent and GraphicsComponent. A decoration is simply a GameObejct with a GraphicsComponent but no Physics component. A zone is the opposite, and a prop has both components. No code duplication, no multiple inheritance, and only three classes instead of four.</p>
            <p><span class="glyphicon-remove"></span>Components are basically plug-and-play for objects. They let us build complex entities with rich behavior by plugging different reusable component objects into sockets on the entity. Think software Voltron.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="component">
    <h2>Component</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            A <b>single entity spans multiple domains.</b> To keep the domains isolated, the code for each is placed in its own <b>component class</b>. The entity is reduced to a simple <b>container of components</b>.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="when-to-use">
    <h2>When to Use It</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Components are most commonly found within the core class that defines the entities in a game, but they may be useful in other places as well. This pattern can be put to good use when any of these are true:
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            &bull; You have a class that touches multiple domains which you want to keep decoupled from each other.
            <p><span class="glyphicon-remove"></span> &bull; A class is getting massive and hard to work with.</p>
            <p><span class="glyphicon-remove"></span> &bull; You want to be able to define a variety of objects that share different capabilities, but using inheritance doesn't let you pick the parts you want to reuse precisely enough.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="keep-in-mind">
    <h2>Keep In Mind</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            The Component pattern adds a good bit of complexity over simply making a class and putting code in it. Each conceptual "object" becomes a cluster of objects that must be initiated, initialized, and correctly wired together. Communicating between the different components becomes more challenging, and controlling how they occupy memory is more complex.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            For a large codebase, this complexity may be worth it for the decoupling and code reuse it enables, but take care to ensure you aren't over-engineering a "solution" to a non-existent problem before applying this pattern.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Another consequence of using components is that you often have to hop through a level of indirection to get anything done. Given the container object, first you have to get the component you want, <i>then</i> you can do what you need. In performance-critical inner loops, this pointer following may lead to poor performance.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            There's a flip side to this coin. The Component pattern can often <i>improve</i> performance and cache coherence. Components make it easier to use the <a href="design-patterns-data-locality.html">Data Locality</a> pattern to organize your data in the order that the CPU wants it.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="sample-code">
    <h2>Sample Code</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            One of the biggest challenges for me in writing these notes is figuring out how to isolate each pattern. Many design patterns exist to contain code that itself isn't part of each pattern. In order to distill the pattern down to its essence, I try to cut as much of that out as possible, but at some point it becomes a bit like explaining how to organize a closet without showing any clothes.
            <p><span class="glyphicon-remove"></span>The Component pattern is a particularly hard one. You can't get a real feel for it without seeing some code for each of the domains that it decouples, so I'll have to sketch this out a bit more in Bjorn's code. The pattern is really only the component <i>classes</i> themselves, but the code in them should help clarify what the classes are for. It's fake code - it calls into other classes that aren't presented here - but it should give you an idea of what we're going for.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>A Monolithic Class</h3>
            <p><span class="glyphicon-remove"></span>To get a clearer picture of how this pattern is applied, we'll start by showing a monolithic Bjorn class that does everything we need but doesn't use this pattern:</p>
            <pre>
            <span class="glyphicon-remove"></span>class Bjorn{
                public Bjorn() : velocity_(0), x_(0), y_(0) {}

                public void update(World&amp; world, Graphics&amp; graphics);

                private static const int WALK_ACCELERATION = 1;

                private int velocity_;
                private int x_, y_;

                private Volume volume_;
                
                private Sprite spriteStand_;
                private Sprite spriteWalkLeft_;
                private Sprite spriteWalkRight_;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Bjorn has an update() method that gets called once per frame by the game:
            <pre>
            <span class="glyphicon-remove"></span>void Bjorn::update(World&amp; world, Graphics&amp; graphics) {
                //Apply user input to hero's velocity.
                switch(Controller::getJoystickDirection()) {
                    case DIR_LEFT:
                        velocity_ -= WALK_ACCELERATION;
                        break;
                    case DIR_RIGHT:
                        velocity_ += WALK_ACCELERATION;
                        break;
                }

                //Modify position by velocity
                x_ += velocity_;
                world.resolveCollision(volume_, x_, y_, velocity_);

                //Draw the appropriate sprite.
                Sprite* sprite = &amp;spriteStand_;
                if(velocity_ < 0){
                    sprite = &amp;spriteWalkLeft_;
                } else if(velocity_ > 0) {
                    sprite = &amp;spriteWalkRight_;
                }

                graphics.draw(*sprite, x_, y_);
            }
            </pre>
            <p><span class="glyphicon-remove"></span>It reads the input to determine how to accelerate the baker. Then it resolves its new position with the physics engine. Finally it draw Bjorn onto the screen.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The sample implementation here is trivially simple. There's no gravity, animation, or any of the dozens of other details that make a character fun to play. Even so, we can see that we've got a single function that several different coders on our team will probably have to spend time in, and it's starting to get a bit messy. Imagine this scaled up to a thousand lines and you can get an idea how painful it can become.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Splitting out a domain</h3>
            <p><span class="glyphicon-remove"></span>Starting with one domain, let's pull a piece out of Bjorn and push it into a separate component class. We'll start with the first domain that gets processed: input. The first thing Bjorn does is read a user input and adjust his velocity based on that input. Let's move that logic out into a separate class:</p>
            <pre>
            <span class="glyphicon-remove"></span>class InputComponent {
                public void update(Bjorn&amp; bjorn) {
                    switch(Controller::getJoystickDirection()){
                        case DIR_LEFT:
                            bjorn.veloctiy -= WALK_ACCELERATION;
                            break;
                        case DIR_RIGHT:
                            bjorn.velocity += WALK_ACCELERATION;
                            break;
                    }
                }

                private static const int WALK_ACCELERATION = 1;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Pretty simple. We've taken the first section of Bjorn's update() method and put it into this class. The changes to Bjorn are also straightforward:
            <pre>
            <span class="glyphicon-remove"></span>class Bjorn {
                public int velocity;
                public int x, y;

                public void update(World&amp; world, Graphics&amp; graphics) {
                    input_.update(*this);

                    //Modify position based by velocity
                    x += velocity;
                    world.resolveCollision(volume_, x, y, velocity);

                    //Draw the appropriate sprite
                    Sprite* sprite = &amp;spriteStand_;
                    if(velocity < 0){
                        sprite = &amp;spriteWalkLeft_;
                    } else if(velocity > 0){
                        sprite = &amp;spriteWalkRight_;
                    }

                    graphics.draw(*sprite, x, y);
                }

                private InputComponent input_;

                private Volume volume_;

                private Sprite spriteStand_;
                private Sprite spriteWalkLeft_;
                private Sprite spriteWalkRight_;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Bjorn now owns an InputComponent object. Where before he was handling user input directly in the update() method, now he delegates to the component:
            <pre><span class="glyphicon-remove"></span>input_.update(*this);</pre>
            <p><span class="glyphicon-remove"></span>We've only started, but already we've gotten rid of some coupling - the main Bjorn class no longer has any reference to Controller. This will come in handy later.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Splitting out the rest</h3>
            <p><span class="glyphicon-remove"></span>Now, let's go ahead and do the same cut-and-paste job on the physics and graphics code. Here's our new PhysicsComponent:</p>
            <pre>
            <span class="glyphicon-remove"></span>class PhysicsComponent {
                public void update(Bjorn&amp; bjorn, World&amp; world) {
                    bjorn.x += bjorn.velocity;
                    world.resolveCollision(volume_, bjorn.x, bjorn.y, bjorn.velocity);
                }

                private Volume volume_;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In addition to moving the physics behavior out of the main Bjorn class, you can see we've also moved out the data too: The Volume object is now owned by the component.
            <p><span class="glyphicon-remove"></span>Last but not least, here's where the rendering code lives now:</p>
            <pre>
            <span class="glyphicon-remove"></span>class GraphicsComponent {
                public void update(Bjorn&amp; bjorn, Graphics&amp; graphics) {
                    Sprite* sprite = &spriteStand_;
                    if(bjorn.velocity < 0) {
                        sprite = &amp;spriteWalkLeft_;
                    } else if(bjorn.velocity > 0) {
                        sprite = &amp;spriteWalkRight_;
                    }

                    graphics.draw(*sprite, bjorn.x, bjorn.y);
                }

                private Sprite spriteStand_;
                private Sprite spriteWalkLeft_;
                private Sprite spriteWalkRight_;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We've yanked almost everything out, so what's left of our humble pastry chef? Not much:
            <pre>
            <span class="glyphicon-remove"></span>class Bjorn {
                public int velocity;
                public int x, y;

                public void update(World&amp; world, Graphics& graphics) {
                    input_.update(*this);
                    physics_.update(*this, world);
                    grpahics_.update(*this, graphics);
                }

                private InputComponent input_;
                private PhysicsComponent physics_;
                private GraphicsComponent graphics_;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The Bjorn class now basically does two things: it hold the set of components that actually define it, and it holds the state that is shared across multiple domains. Position and velocity are still in the core Bjorn class for two reasons. First, they are "pan-domain" state - almost every component will make use of them, so it isn't clear which component <i>should</i> own them if we did not want to push them down. Secondly, and more importantly, it gives us an easy way for the components to communicate without being coupled to each other. Let's see if we can put that to use.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Robo-Bjorn</h3>
            <p><span class="glyphicon-remove"></span>So far, we've pushed our behavior out to separate component classes, but we haven't <i>abstracted</i> the behavior out. Bjorn still knows the exact concrete classes where his behavior is defined. Let's change that.</p>
            <p><span class="glyphicon-remove"></span>We'll take our component for handling user input and hide it behind an interface. We'll turn InputComponent into an abstract class:</p>
            <pre>
            <span class="glyphicon-remove"></span>class InputComponent {
                public virtual ~InputComponent() {}
                public virtual void update(Bjorn&amp; bjorn) = 0;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Then, we'll take our existing user input handling code and push it down into a class that implements that interface:
            <pre>
            <span class="glyphicon-remove"></span>class PlayerInputComponent : public InputComponent {
                public virtual void update(Bjorn&amp; bjorn) {
                    switch(Controller::getJoystickDirection()) {
                        case DIR_LEFT:
                            bjorn.velocity -= WALK_ACCELERATION;
                            break;
                        case DIR_RIGHT:
                            bjorn.velocity += WALK_ACCELERATION;
                            break;
                    }
                }

                private static const int WALK_ACCELERATION = 1;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We'll change Bjorn to hold a pointer to the input component instead of having an inline instance:
            <pre>
            <span class="glyphicon-remove"></span>class Bjorn {
                public int velocity;
                public int x, y;

                public Bjorn(InputComponent* input) : input_(input) {}

                public void update(World&amp; world, Graphics&amp; graphics) {
                    input_->update(*this);
                    physics_.update(*this, world);
                    graphics_.update(*this, graphics);
                }

                private InputComponent* input_;
                private PhysicsComponent physics_;
                private GraphicsComponent graphics_;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Now, when we instantiate Bjorn, we can pass in an input component for it to use, like so:
            <pre>
            Bjorn* bjorn = new Bjorn(new PlayerInputComponent());
            </pre>
            <p><span class="glyphicon-remove"></span>This instance can be any concrete type that implements our abstract InputComponent interface. We pay a price for this - update() is now a virtual method call, which is a little slower. What do we get in return for this cost?</p>
            <p><span class="glyphicon-remove"></span>Most consoles require a game to support "demo mode". If the player sits at the main menu without doing anything, the game starts playing automatically, with the computer standing in for the player. This keeps the game form burning the main menu into your TV and also makes the game look nicer when running on a kiosk in a store.</p>
            <p><span class="glyphicon-remove"></span>Hiding the input component class behind an interface lets us get that working. We already have our concrete PlayerInputController that's normally used when playing the game. Now let's make another one:</p>
            <pre>
            <span class="glyphicon-remove"></span>class DemoInputComponent ; public InputComponent {
                public virtual void update(Bjorn&amp; bjorn) {
                    // AI to automatically control Bjorn...
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            When the game goes into demo mode, instead of constructing Bjorn like we did earlier, we'll wire him up with our new component:
            <pre><span class="glyphicon-remove"></span>Bjorn* bjorn = new Bjorn(new DemoInputComponent());</pre>
            <p><span class="glyphicon-remove"></span>And now, just by swapping out a component, we've got a fully functioning computer-controlled player demo mode. We're able to reuse all of the other code for Bjorn - physics and graphics don't even know the difference.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>No Bjorn at all?</h3>
            <p><span class="glyphicon-remove"></span>If you look at our Bjorn class now, you'll notice there's nothing really "Bjorn" about it - it's just a component bag. In fact, it looks like a pretty good candidate for a base "game object" class that we can use for <i>every</i> object in the game. All we need to do is pass in <i>all</i> the components, and we can build any kind of object by picking and choosing parts like Dr. Frankenstein.</p>
            <p><span class="glyphicon-remove"></span>Let's take our two remaining concrete components - physics and graphics - and hide them from behindinterfaces like we did with input:</p>
            <pre>
            <span class="glyphicon-remove"></span>class PhysicsComponent {
                public virtual ~PhysicsComponent() {}
                public virtual void update(GameObject&amp; obj, World&amp; world) = 0;
            }

            class GraphicsComponent {
                public virtual ~GrahicsComponent() {}
                public virtual void update(GameObject&amp; obj, World&amp; world) = 0;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Then we re-christen Bjorn into a generic GameObject class that uses those interfaces:
            <pre>
            <span class="glyphicon-remove"></span>class GameObject {
                public int velocity;
                public int x, y;

                public GameObject(InputComponent* input, PhysicsComponent* physics, GraphicsComponent* graphics) 
                    : input_(input), physics_(physics), graphics_(graphics) {}

                public void update(World&amp; world, Graphics&amp; graphics) {
                    input_->update(*this);
                    physics_->update(*this, world);
                    graphics_->update(*this, graphics);
                }

                private InputComponent* input_;
                private PhysicsComponent* physics_;
                private GraphicsComponent* graphics_;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Our existing concrete classes will get renamed and implement those interfaces:
            <pre>
            <span class="glyphicon-remove"></span>class BjornPhysicsComponent : public PhysicsComponent {
                public virtual void update(GameObject&amp; obj, World&amp; world) {
                    //Physics code...
                }
            }

            class BjornGraphicsComponent : public GraphicsComponent {
                public virtual void update(GameObject&amp; obj, Graphics&amp; graphics) {
                    //Graphics code...
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            And now we can build an object that has all of Bjorn's original behavior without having to actually create a class for him, just like this:
            <pre>
            <span class="glyphicon-remove"></span>GameObject* createBjorn() {
                return new GameObject(new PlayerInputComponent(), new BjornPhysicsComponent(), new BjornGraphicsComponent());
            }
            </pre>
            <p><span class="glyphicon-remove"></span>By defining other functions that instantiate GameObjects with different components, we can create all of the different kinds of objects our game needs.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="design-decisions">
    <h2>Design Decisions</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            The most important design question you'll need to answer with this patter is, "What set of components do I need?" The answer there is going to depend on the needs and genre of your game. The bigger and more complex your engine is, the more finely you'll likely want to slice your components.
            <p><span class="glyphicon-remove"></span>Beyond that, there are a couple options more specific to consider.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>How does the object get its components?</h3>
            <p><span class="glyphicon-remove"></span>Once we've split up our monolithic object into a few separate component parts, we have to decide who puts the parts back together.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>If the object creates its own components:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>It ensures that the object always has the component it needs.</i> You never have to worry about someone forgetting to wire up the right components to the object and breaking the game. The container object itself takes care of it for you.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>It's harder to reconfigure the object.</i> One of the powerful features of this pattern is that it lets you build new kinds of objects simply by recombining components. If our object always wires itself with the same set of hard-coded components, we aren't taking advantage of that flexibility.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>If outside code provides the components:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>The object becomes more flexible.</i> We can completely change the behavior of the object by giving it different components to work with. Taken to its fullest extent, our object becomes a generic component container that we can reuse over and over again for different purposes.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>The object can be decoupled from the concrete component types.</i> If we're allowing outside code to pass in components, odds are good that we're also letting it pass in <i>derived</i> component types. At that ponit, the object only knows about the component <i>interfaces</i> and not the concrete types themselves. This can make for a nicely encapsulated architecture.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>How do components communicate with each other?</h3>
            <p><span class="glyphicon-remove"></span>Perfectly decoupled components that function in isolated is a nice ideal, but it doesn't really work in practice. The fact that these components are part of the <i>same</i> object implies that they are part of a larger whole and need to coordinate. That means communication.</p>
            <p><span class="glyphicon-remove"></span>So how can the components talk to each other? There are a couple of options, but unlike most design "alternatives" in this section, these aren't exclusive - you will likely support more than one at the same time in your designs.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>By modifying the container object's state:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>It keeps the components decoupled.</i> Whe our InputComponent set Bjorn's velocity and the PhysicsComponent later used it, the two components had no idea that the other even existed. For all they knew, Bjorn's velocity changed through black magic.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>It requires any information that components need to share to get pushed into the container object.</i> Often, there's state that's really only needed by a subset of the components. For example, an animation and a rendering component may need to share information that's graphics-specified. Pushing that information up into the container object where <i>ever</i> component can get to it muddies the object class.
            <br>Worse, if we use the same container object class with different componet configurations, we can end up wasting memory on state that isn't needed by <i>any</i> of the object's components. If we push some rendering-specific data into the container object, any invisible object will be burning memory on it with no benefit.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>It makes communication implicity and dependent on the order that components are processed.</i>  In our sample code, the original monolithic update() method had a very carefully laid out order of operations. The user input modified the velocity, which was then used by the physics code to modify the position, which in turn was used by the rendering code to modify the position which in turn was used by the rendering code to draw Bjorn at the right spot. When we split that code out into components, we were careful to preserve that order of operations.
            <br>If we hadn't, we would have introduced subtle, hard-to-track bugs. For example, if we'd update the graphics component <i>first</i>, we would wrongly render Bjorn at his position on the <i>last</i> frame, not this one. If you imagine several more components and lots more code, then you can get the idea of how hard it is to avoid bugs like this.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>By referring directly to each other:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; The idea here is that components that need to talk will ahve direct references to each other without having to go through the container object at all.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; Let's say we want to let Bjorn jump. The graphics code needs to know if he should be drawn using a jump sprite or not. It can determine this by asking the physics engine if he's currently on the ground. An easy way to do this is by letting the graphics component know about the physics component directly:</p>
            <pre>
            <span class="glyphicon-remove"></span>class BjornGrpahicsComponent {
                public BjornGraphicsComponent(BjornPhysicsComponent* physics) : physics_(physics) {}

                void Update(GameObject&amp; obj, Graphics&amp; graphics) {
                    Sprite* sprite;
                    if(!physics_->isOnGround()) {
                        sprite = &amp;spriteJump_;
                    } else {
                        // Existing graphics code...
                    }
                }

                private BjornPhysicsComponent* physics_;

                private Sprite spriteStand_;
                private Sprite spriteWalkLeft_;
                private Sprite spriteWalkRight_;
                private Sprite spriteJump_;
            }
            </pre>
            <p><span class="glyphicon-remove"></span> &nbsp; When we construct Bjorn's GraphicsComponent, we'll give it a reference to his corresponding PhysicsComponent.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>It's simple and fast.</i> Communication is a direct method call from one object to another. The component can call any method that is supported by the component it has a reference to. It's a free-for-all.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>The two components are tightly coupled.</i> The downside of the free-for-all. We've basically taken a step back towards our monolithic class. It's not quite as bad as the original single class though, since we're at least restricting the coupling to only the component pairs that need to interact.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>By sending messages:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; This is the most complex alternative. We can actually build a little messaging system into our container object and let the components broadcast information to each other.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; Here's one possible implementiation. We'll start by defining a base Component interface that all of our components will implement:</p>
            <pre>
            <span class="glyphicon-remove"></span>class Component {
                public virtual ~Component() {}
                public virtual void receive(int message) = 0;
            }
            </pre>
            <p><span class="glyphicon-remove"></span> &nbsp; It has a single receive() method that component classes implement in order to listen to an incoming message. Here, we're just using an int to identify the message, but a fuller implementation could attach additional data to the message. Then, we'll add a method to our container object for sending messages:</p>
            <pre>
            <span class="glyphicon-remove"></span>class ContainerObject {
                public void send(int message) {
                    for(int i = 0; i < MAX_COMPONENTS; i++) {
                        if(components_[i] != NULL) {
                            components_[i]->receive(message);
                        }
                    }
                }

                private static const int MAX_COMPONENTS = 10;
                Component* components_[MAX_COMPONENTS[;];
            }
            </pre>
            <p><span class="glyphicon-remove"></span> &nbsp; Now, if a component has access to its container, it can send messages to the container, which will rebroadcast the message to all of the contained components. (That includes the original component that sent the message; be careful that you don't get stuck in a feedback loop!) This has a couple consequences:</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>Sibling components are decoupled.</i> By going through the parent container object, like our shared state alternative, we ensure that the components are still decoupled from each other. With this system, the only coupling they have is the message values themselves.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &nbsp; &bull; <i>The container object is simple.</i> Unlike using shared state where the container object itself owns and knows about data used by the components, here, all it does is blindly pass the messages along. That can be useful for letting two components pass very domain-specific information between themselves without having that bleed into the container object.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Unsurprisingly, there's no one best answer here. What you'll likely end up doing is using a bit of all of them. Shared state is useful for the really basic stuff that you can take for granted that every object has - things like position and size.
            <p><span class="glyphicon-remove"></span>Some domains are distinct but still closely related. Think animation and rendering, user input and AI, or physics and collision. If you have separate components for each half of those pairs, you may find it easiest to just let them know directly about their other half.</p>
            <p><span class="glyphicon-remove"></span>Messaging is useful for "less important" communication. Its fire-and-forget nature is a good fit for things like having an audio component play a sound when a physics components sends a message that the object has collided with something.</p>
            <p><span class="glyphicon-remove"></span>As always, I recommend you start simple and then add in additional communication paths if you need them.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="see-also">
    <h2>See Also</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            The Unity framework's core GameObject class is designed entirely around components.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The open source Delta3D engine has a base GameActor class that implements this pattern with the appropriately named ActorComponent base class.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Microsoft's XNA game framework comes with a core Game class. It owns a collection of GameComponent objects. Where our example uses components at the individual game entity level, XNA implements the pattern at the level of the main game object itself, but the purpose is the same.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            This pattern bears resemblance to the <a href="http://c2.com/cgi-bin/wiki?StrategyPattern">Strategy</a> pattern. Both patterns are about taking part of an object's behavior and delegating it to a separate subordinate object. The difference is that with the Strategy pattern, the separate "strategy" object is usually stateless - it encapsulates an alogrithm, but no data. It defines <i>how</i> an object behaves, but not <i>what</i> it is.
            <br>Components are a bit more self-important. They often hold state that describes the object and helps define its actual identity. However, the line may blur. You may have some components that don't need any local state. In that case, you're free to use the same component <i>instance</i> across multiple container objects. At that point, it really is behaving more akin to a strategy.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

                    <!-------------------------------------->
                </div>
            </div>
    </main>

    <!-------------------------------------------------------------------------->

    <!-- FOOTER -->
    <footer class="navbar navbar-inverse navbar-fixed-bottom">
        <nav>
            <div class="container">
                <div class="row">
                    <div class="col-md-6 col-sm-6 col-xs-12">
                        <ul>
                            <li>&copy; 2017 <a href="http://www.gabedeyo.com">Gabe Deyo</a></li>
                            <li>|</li>
                            <li><a href="mailto:gabedeyo@gmail.com?subject=Notes">gabedeyo@gmail.com</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>
    </footer>

    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
    <script src="../../../js/selection.js" charset="utf-8"></script>
</body>

</html>
