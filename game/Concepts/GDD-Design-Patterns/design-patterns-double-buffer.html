<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Design Patterns - Double Buffer</title>

    <meta name="viewport" content="width=device-width,initial-scale=1.0, shrink-to-fit=no" />

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="../../../css/page.css">
</head>

<body>

    <!-- Top Navigation -->
    <header>
        <nav class="navbar navbar-inverse">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapsemenu" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a href="../../../index.html" class="navbar-brand">Personal Notes</a>
                </div>

                <div class="collapse navbar-collapse" id="collapsemenu">
                    <ul class="nav navbar-nav">

                        <!-- GAME DEVELOMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Game Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- CONCEPTS -->
                                <li><a href="../../Categories/concepts.html">Concepts <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ENGINE -->
                                <li><a href="../../Categories/engine.html">Engine <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- IMPLEMENTATIONS -->
                                <li><a href="../../Categories/implementations.html">Implementations <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- PROGRAMMING -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Programming <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- LANGUAGES -->
                                <li><a href="../../../code/Categories/languages.html">Languages <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ALGORITHMS -->
                                <li><a href="../../../code/Categories/algorithms.html">Algorithms <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PROBLEMS -->
                                <li><a href="../../../code/Categories/problems.html">Problems <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- RANDOM -->
                                <li><a href="../../../code/Categories/random.html">Random <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- GABE DEVELOPMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Gabe Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- FITNESS PAGE -->
                                <li><a href="../../../gabe/Categories/fitness.html">Fitness <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- STYLE & GROOMING PAGE -->
                                <li><a href="../../../gabe/Categories/style.html">Style <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- FINANCE PAGE -->
                                <li><a href="../../../gabe/Categories/finance.html">Finance <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PHILOSOPHY PAGE -->
                                <li><a href="../../../gabe/Categories/philosophy.html">Philosophy <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                    </ul>
                </div>

            </div>
        </nav>
    </header>

    <!-------------------------------------------------------------------------->

    <!-- MAIN -->
    <main>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h1 id="title">Design Patterns - Double Buffer</h1>

                    <aside>
                        <button type="button" class="btn btn-default" name="button" id="selectAll">Select All</button>
                        <button type="button" class="btn btn-default" name="button" id="clearAll">Clear All</button>
                    </aside>

                    <div class="jumbotron heliList">
                        <h2>Index</h2>
                        <ul>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#intent">Intent</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#motivation">Motivation</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#double-buffer">Double Buffer</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#when-to-use">When to Use It</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#keep-in-mind">Keep In Mind</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#sample-code">Sample Code</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#design-decisions">Design Decisions</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#see-also">See Also</a>
                                </p>
                            </li>
                        </ul>
                    </div>

<div class="jumbotron col-md-12 heliList" id="intent">
    <h2>Intent</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            <i>Cause a series of sequential operations to appear instantaneous or simultaneous.</i>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="motivation">
    <h2>Motivation</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            In their hearts, computers are sequential beasts. Their pwer comes from being able to break down the largest tasks into tiny steps that can be performed one after another. Often, though our users need to see things occur in a single instantaneous step or see multiple tasks performed simultaneously.
            <p><span class="glyphicon-remove"></span>With threading and multi-core architectures this is becoming less true, but even with several cores, only a few operations are running concurrently.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            A typical example, and one that every game engine must address, is rendering. When the game draws the world the users see, it does so one piece at a time - the mountains in the distance, the rolling hills, the trees, each in its turn. If the user <i>watched</i> the view draw incrementally like that, the illusion of a coherent world would be shattered. The scene must update smoothly and quickly, displaying a series of complete frames, each appearing instantly.
            <p><span class="glyphicon-remove"></span><b>Double Buffer</b> solves this problem, but to understand how, we first need to review how a computer displays graphics.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>How Computer Graphics Work (briefly)</h3>
            <p><span class="glyphicon-remove"></span>A video display like a computer monitor draws one pixel at a time. It sweeps across each row of pixels from left to right and then moves down to the next row. When it reaches the bottom corner, it scans back up to the top left and starts all over again. It does this so fast - around 60 times a second - that our eyes can't see the scanning. To use, it's a single static field of colored pixels - an image.</p>
            <p><span class="glyphicon-remove"></span>You can think of this process like a tiny hose that pipes pixels to the display. Individual colors go into the back of the hose, and it sprays them out across the display, one bit of color to each pixel in its turn. So how does the hose know what colors go where?</p>
            <p><span class="glyphicon-remove"></span>In most computers, the answer is that it pulls them from a <i>framebuffer</i>. A framebuffer is an array of pixels in memory, a chunk of RAM where each couple of bytes represents the color of a single pixel. As the hose sprays across the display, it reads in the color values from this array, one byte at a time.</p>
            <p><span class="glyphicon-remove"></span>Ultimately, in order to get our game to appear on screen, all we do is write to that array. All of the crazy graphics algorithms we have boil down to just that: setting byte values in the frame buffer. But there's a little problem.</p>
            <p><span class="glyphicon-remove"></span>Earlier, I said computers are sequential. If the machine is executing a chunk of our rendering code, we don't expect it to be doing anything else at the same time. That's mostly accurate, but a couple of things do happen in the middle of our program running. One of those is that the video display will be reading from the framebuffer <i>constantly</i> while our game runs. This can cause a problem for us.</p>
            <p><span class="glyphicon-remove"></span>Let's say we want a happy face to appear on screen. Our program starts looping through the framebuffer, coloring pixels. What we don't realize is that the video driver is pulling from the framebuffer right as we're writing into it. As it scans across the pixels we've written, our face starts to appear, but then it outpaces us and moves into pixels we haven't written out yet. The result is <i>tearing</i>, a hideous visual bug where you see half of something drawn on screen.</p>
            <p><span class="glyphicon-remove"></span>This is why we need this pattern. Our program renders the pixels one at a time, but we need the display driver to see them all at once - in one frame the face isn't there, and in the next one it is. Double buffering solves this. I'll explain with an analogy.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Act 1, Scene 1</h3>
            <p><span class="glyphicon-remove"></span>Imagine our users are watching a play produced by us. As scene one end and scene two starts, we need to change the stage setting. If we have the stagehands run on after the scene and start draggging props around, the illusion of a coherent place will be broken. We could dim the lights while we do that (which, of course, is what real theaters do), but the audience still knows something is going on. We have there to be no gap in time between scenes.</p>
            <p><span class="glyphicon-remove"></span>With a bit of real estate, we come up with this clever solution: we build two stages set up so the audience can see both. Each has its own set of lights. We'll call them stage A and stage B. Scene one is shown on stage A. Meanwhile, stage B is dark as the stagehands are setting up scene two. As soon as scene one ends, we cut the lights on stage A and bring them up on stage B. The audience looks to the new stage and scene two begins immediatly.</p>
            <p><span class="glyphicon-remove"></span>At the same time, our stagehands are over on the now darkened stage A, striking scene one and setting up scene 3. As soon as scene two ends, we switch the light back to stage A again. We continue this process for the entire play, using the darkened stage as a work area where we can set up the next scene. Every scene transition, we just toggle the lights between the two stages. Our audience gets a continuous performance with no delay between scenes. They never see a stagehand.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Back to the Graphics</h3>
            <p><span class="glyphicon-remove"></span>That is exactly how double buffering works, and this process underlies the rendering system of just about every game you've ever seen. Instead of a single framebuffer, we have <i>two</i>. One of them represents the current frame, stage A in our analogy. It's the one the video hardward is reading from. The GPU can scan through it as much as it wants whenever it wants.</p>
            <p><span class="glyphicon-remove"></span>Meanwhile, our rendering code is writing to the <i>other</i> framebuffer. This is our darkened stabe B. When our rendering code is done drawing the scene, it switches the lights by <i>swapping</i> the buffers. This tells the video hardware to start reading from the second buffer now instead of the first one. As long as it times that switch at the end of a refresh, we won't get any tearing, and the entire scene will appear at once.</p>
            <p><span class="glyphicon-remove"></span>And now, the old framebuffer is available for use. We start rendering the next frame onto it.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="double-buffer">
    <h2>Double Buffer</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            A <b>buffered class</b> encapsulates a <b>buffer</b>: a piece of state that can be modified. This buffer is edited incrementally, but we want all outside code to see the edit as a single atomic change. To do this, the class keeps <i>two</i> instances of the buffer: a <b>next buffer</b> and a <b>current buffer</b>.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            When information is read <i>from</i> a buffer, it is always from the <i>current</i> buffer. When information is written <i>to</i> a buffer, it occurs on the <i>next buffer</i>. When the changes are complete, a <b>swap</b> operation swaps the next and current buffers instantly so that the new buffer is now publicly visible. The old current buffer is now available to be reused as the new next buffer.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="when-to-use">
    <h2>When to Use It</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            This pattern is one of those ones where you'll know when you need it. If you have a system that lacks double buffering, it will probably look visibly wrong or behave incorrectly. But saying, "you'll know when you need it" doesn't give you much to go on. More specifically, this pattern is appropriate when all of these are true:
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            &nbsp; &bull; We have some state that is being modified incrementally.
            <br> &nbsp; &bull; That same state may be accessed in the middle of modification.
            <br> &nbsp; &bull; We want to prevent the code that's accessing the state from seeing the work in progress.
            <br> &nbsp; &bull; We want to be able to read the state and we don't want to have to wait while it's being written.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="keep-in-mind">
    <h2>Keep In Mind</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Unlike larger architectural patterns, double buffering exists at a lower implementaiton level. Because of this, it has fewer consequences for the rest of the codebase - most of the game won't even be aware of the difference. There are a couple caveats, though.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>The Swap Itself Takes Time</h3>
            <p><span class="glyphicon-remove"></span>Double-buffering requires a <i>swap</i> step once the state is done being modified. That operation must become atomic - no code can access <i>either</i> state while they are being swapped. Often, this is a quick as assigning a pointer, but if it takes longer to swap than it does to modify the state to begin with, then we haven't helped ourselves at all.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>We Have to have Two Buffers</h3>
            <p><span class="glyphicon-remove"></span>The other consequence of this pattern is increased memory usage. As its name implies, the pattern requires you to keep <i>two</i> copies of your state in memory at all times. On memory-constrained devices, this can be a heavy price to pay. If you can't afford two buffers, you may have to look inot other ways to ensure your state isn't being accessed during modification.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="sample-code">
    <h2>Sample Code</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Now that we've got the theory, let's see how it works in practice. We'll write a very bare-bones graphics system that lets us draw pixels on a framebuffer. In most console and PCs, the video driver provides this low-level part of the graphics system, but implementing it by hand here will let us see what's going on.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            First up is the buffer itself:
            <pre>
            <span class="glyphicon-remove"></span>class Framebuffer {
                public Framebuffer() { clear(); }

                public void clear() {
                    for(int i = 0; i < WIDTH * HEIGHT; i++) {
                        pixels_[i] = WHITE;
                    }
                }

                public void draw() {
                    pixels_[(WIDTH * y) + x] = BLACK;
                }

                public const char* getPixels() {
                    return pixels_;
                }

                private static const int WIDTH = 160;
                private static const int HEIGHT = 120;

                private char pixels_[WIDTH * HEIGHT];
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            It has basic operations for clearing the entire buffer to a default color and setting the color of an individual pixel. It also has a function, getPixels(), to expose the raw array of memory holding the pixel data. We won't see this in the example, but the video driver will call a function frequently to stream memory from the buffer onto the screen.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We wrap this raw buffer in a Scene class. It's job here is to render something by making a bunch of draw() calls on its buffer:
            <pre>
            <span class="glyphicon-remove"></span>class Scene {
                public void draw() {
                    buffer_.clear();
                    //Draw a smiley face
                    buffer_.draw(1, 1);
                    buffer_.draw(4, 1);
                    buffer_.draw(1, 3);
                    buffer_.draw(2, 4);
                    buffer_.draw(3, 4);
                    buffer_.draw(4, 3);
                }

                public Framebuffer&amp; getBuffer() { return buffer_; }

                private Framebuffer buffer_;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Every frame, the game tells the scene to draw. The scene clears the buffer and then draws a bunch of pixels, one at a time. It also provides access to the internal buffer through getBuffer() so that the video driver can change to it.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            This seems pretty straightforward, but if we leave it like this, we'll run into problems. The trouble is that the video driver can call getPixels() on the buffer at <i>any</i> point in time, even here:
            <pre>
            <span class="glyphicon-remove"></span>buffer_.draw(1, 1);
            buffer_.draw(4, 1);
            buffer_.draw(1, 3);
            // Video driver reads pixels here!
            buffer_.draw(2, 4);
            buffer_.draw(3, 4);
            buffer_.draw(4, 3);
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            When that happens, the user will see the eyes of the face, but the mouth will disappear for a single frame. In the next frame, it could get interrupted at some other point. The end result is horribly flickering graphics. We'll fix this with double buffering:
            <pre>
            <span class="glyphicon-remove"></span>class Scene {
                public Scene() : current_(&amp;buffers_[0]), next_(&amp;buffers[1]) {}

                public void draw() {
                    next_->clear();
                    next_->draw(1, 1);
                    // ...
                    next_->draw(4, 3);

                    swap();
                }

                public Framebuffer&amp; getbuffer() { return *current_; }

                private void swap() {
                    //Just switch the pointers.
                    Framebuffer* temp = current_;
                    current = next_;
                    next_ = temp;
                }

                private Framebuffer buffers_[2];
                private Framebuffer* current_;
                private Framebuffer* next_;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Now Scene has two buffers, stored in the buffers_ array. We don't directly reference them fromthe array. Instead, there are two members, next_ and current_, that point into the array. When we draw, we draw onto the next buffer, referenced by next_. when the video driver needs to get the pixels, it always accesses the <i>other</i> buffer through current_;
            <p><span class="glyphicon-remove"></span>This way, the video driver never sees the buffer that we're working on. The only remaining piece of the puzzle is the call to swap() when the scene is done drawing the frame. That swaps the two buffers by simply switching the next_ and current_ references. The next time the video driver calls getBuffer(), it will get the new buffer we just finished drawing and put our recently drawn buffer on screen. No more tearing or unsightly glitches.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Not Just for Graphics</h3>
            <p><span class="glyphicon-remove"></span>The core problem that double buffering solves is state being accessed while it's being modified. There are two common cases of this. We've covered the first one with our graphics example - the state is directly accessed from code on another thread or interrupted.</p>
            <p><span class="glyphicon-remove"></span>There is another equally common cause, though: when the code is <i>doing the modification</i> is accessing the same state that it's modifying. This can manifest in a variety of places, especially physics and AI where you have entities interacting with each other. Double-buffering is often helplful here too.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Artificial Unintelligence</h3>
            <p><span class="glyphicon-remove"></span>Let's say we're building the behavioral system for, of all things, a game based on slapstick comedy. The game has a stage containing a bunch of actors that run around and get up to various hijinks and shenanigans. Here's our base actor:</p>
            <pre>
            <span class="glyphicon-remove"></span>class Actor {
                public Actor() : slapped_(false) {}

                public virtual ~Actor() {}
                public virtual void update() = 0;

                public void reset() { slapped_ = false; }
                public void slap() { slapped_ = true; }
                public bool wasSlapped() { return slapped_; }

                private bool slapped_;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Every frame, the game is responsible for calling update() on the actor so that it has a change to do some processing. Critically, from the user's perspective, <i>all actors should appear to update simultaneously.</i>
            <p><span class="glyphicon-remove"></span>Actors can also interact with each other, if by "interacting", we mean, "they can slap each other around". When updating, the actor can call slap() on another actor to slap it and call wasSlapped() to determine if it has been slapped.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The actors need a stage where they can interact, so let's build that:
            <pre>
            <span class="glyphicon-remove"></span>class Stage {
                public void add(Actor* actor, int index) {
                    actors_[index] = actor;
                }

                public void update() {
                    for(int i = 0; i < NUM_ACTORS; i++) {
                        actors_[i]->update();
                        actors_[i]->reset();
                    }
                }

                private static const int NUM_ACTORS = 3;

                private Actor* actors_[NUM_ACTORS];
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Stage lets us add actors, and provides a single update() call that updates each other. To the user, actors appear to move simultaneously, but internally, they are updated one at a time.
            <p><span class="glyphicon-remove"></span>The only other point to note is that each actor's "slapped" state is cleared immediately after updating. This is so that na actor only responds to a given slap once.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            To get things going, let's define a concrete actor subclass. Our comedian here is pretty simple. He faces a single actor. Whenever he gets slapped - by anyone - he responds by slapping the actor he faces.
            <pre>
            <span class="glyphicon-remove"></span>class Comedian : public Actor {
                public void face(Actor* actor) { facing_ = actor; }

                public virtual void update() {
                    if(wasSlapped()) {
                        facing_->slap();
                    }
                }

                private Actor* facing_;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Now, let's throw some comedians on a stage and see what happens. We'll set up three comedians, each facing the next. The last one will face the first, in a big circle.
            <pre>
            <span class="glyphicon-remove"></span>Stage stage;
            Comedian* harry = new Comedian();
            Comedian* curly = new Comedian();
            Comedian* moe = new Comedian();

            harry->face(curly);
            curly->face(moe);
            moe->face(harry);

            stage.add(harry, 0);
            stage.add(curly, 1);
            stage.add(moe, 2);
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The resulting stage is set up in a full circle. Each actor is facing the next. We'll slap Harry to get things going and see what happens when we start processing:
            <pre>
            <span class="glyphicon-remove"></span>harry->slap();
            stage.update();
            </pre>
            <p><span class="glyphicon-remove"></span>Remember that the update() function in Stage updates each actor in turn, so if we step through the code, we'll find that the following occurs:</p>
            <pre>
            <span class="glyphicon-remove"></span>Stage updates actor 0 (Harry)
                Harry was slapped, so he slaps Curly
            Stage updates actor 1 (Curly)
                Curly was slapped, so he slaps Moe
            Stage updates actor 2 (Moe)
                Moe was slapped, so he slaps Curly
            Stage update ends
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In a single frame, our initial slap on Harry was propagated through all of the comedians. Now, to mix things up a bit, let's say we reorder the comedians within the stage's array but leave them facing each other the same way.
            <p><span class="glyphicon-remove"></span>We'll leave the rest of the stage setup alone, but we'll replace the chunk of code where we add the actors to the stage with this:</p>
            <pre>
            <span class="glyphicon-remove"></span>stage.add(harry, 2);
            stage.add(curly, 1);
            stage.add(moe, 0);
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's see what happens when we run the experiment again:
            <pre>
            <span class="glyphicon-remove"></span>Stage updates actor 0 (Moe)
                Moe was not slapped, so he does nothing
            Stage updates actor 1 (Curly)
                Curly was not slapped, so he does nothing
            Stage updates actor 2 (Harry)
                Harry was slapped, so he slaps Moe
            Stage update ends
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Uh, oh. Totally different issue. The problem is straightforward. When we update the actors, we modify their "slapped" states, the exact same state we also <i>read</i> during the update. Because of this, changes to that state early in the update affect later parts of that <i>same</i> update step.
            <p><span class="glyphicon-remove"></span>The ultimate result is that an actor may respond to being slapped in either the <i>same</i> frame or in the <i>next</i> frame based entirely on how the two actors happen to be ordered on the stage. This violates our requirement that actors need to run in parallel - the order that they update within a single frame shouldn't matter.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Buffered Slaps</h3>
            <p><span class="glyphicon-remove"></span>Fortunately, our Double Buffer pattern can help. This time, instead of having two copies of a monolithic "buffer" object, we'll be buffering at a much finer granularity: each actor's "slapped" state:</p>
            <pre>
                <span class="glyphicon-remove"></span>class Actor {
                    public Actor() : currentSlapped_(false) {}

                    public virtual ~Actor() {}
                    public virutal void update() = 0;

                    public void swap() {
                        //Swap the buffer
                        currentSlapped_ = nextSlapped_;

                        //Clear the new "next" buffer.
                        nextSlapped_ = false;
                    }

                    public void slap() { nextSlapped_ = true; }
                    public bool wasSlapped() {return currentSlapped_; }

                    private bool currentSlapped_;
                    private bool nextSlapped_;
                }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Instead of a single slapped_ state, each actor now has two. Just like the previous graphics example, the current state is used for reading, and the next state is used for writing.
            <p><span class="glyphicon-remove"></span>The reset() function has been replaced with swap(). Now, right before clearing the swap state, it copies the next state into the current one, making it the new current state. This also requires a small change in Stage:</p>
            <pre>
            <span class="glyphicon-remove"></span>void Stage::update() {
                for(int i = 0; i < NUM_ACTORS; i++) {
                    actors_[i]->update();
                }

                for(int i = 0; i < NUM_ACTORS; i++ ) {
                    actors_[i]->swap();
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The update() function now updates all of the actors and <i>then</i> swaps all of their states. The end result of this is that an actor will only see a slap in the frame <i>after</i> it was actually slapped. This way, the actors will behave the same no matter their order in the stage's array. As far as the user or any outside code can tell, all of the actors update simultaneously within a frame.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="design-decisions">
    <h2>Design Decisions</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Double Buffer is pretty straightforward, and the examples we've seen so far vcover most of the variations you're likely to encounter. There are two main decisions that come up when implementing this patter.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>How are the buffers swapped?</h3>
            <p><span class="glyphicon-remove"></span>The swap operation is the most critical step of the process since we must lock out all reading and modification of both buffers while it's occurring. To get the best performance, we wantthis to happen as quickly as possible:</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            &bull; <b>Swap pointers or references to the buffer:</b>
            <p><span class="glyphicon-remove"></span>This is how our graphics example works, and it's the most common solution for double-buffering graphics.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; <i>It's fast</i>. Regardless of how big the buffer is, the swap is simply a couple of pointer assignments. It's hard to beat that for speed and simplicity.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; <i>Outside code cannot store persistent pointer to the buffer.</i>This is the main limitation. Since we don't actually move the <i>data</i>, what we're essentially doing is periodically telling the rest of the codebase to look somewhere else for the buffer, like in our original state analogy. This means within the buffer - they may be pointing at the wrong one a moment later.</p>
            <p><span class="glyphicon-remove"></span>This can be particularly troublesome on a system where the video driver expects the framebuffer to always be at a fixed location in memory. In that case, we won't be able to use this option.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; <i>Existing data on the buffer will be from two frames ago, not the last frame.</i> Successive frames are drawn on alternating buffers with no data copied between them, like so:</p>
            <pre>
            <span class="glyphicon-remove"></span>Frame 1 drawn on buffer A
            Frame 2 drawn on buffer B
            Frame 3 drawn of buffer A
            </pre>
            <p><span class="glyphicon-remove"></span> &nbsp; You'll note that when we go to draw the third frame, the data already on the buffer is from frame 1, not the more recent second frame. In most cases, this isn't an issue - we usually clear the whole buffer right before drawing. But if we intent to reuse some of the existing data on the buffer, it's important to take into account that that data will be a frame oler than we might expect.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            &bull; <b>Copy the data between the buffers:</b>
            <p><span class="glyphicon-remove"></span> &nbsp; IF we can't repoint users to the other buffer, the only other option is to actually copy the data from the next frame to the current frame. This is how our slapstick comedians work. In that case, we chose this method because the state - a single Boolean flag - doesn't take any longer to copy than a pointer to the buffer would.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; <i>Data on the next buffer is only a single frame old.</i> This is the nice thing about copying the data as opposed to ping-ponging back and forth between the two buffers. If we need access to previous buffer data, this will give us more up-to-date data to work with.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; <i>Swapping can take more time.</i> This, of course, is the big negative point. Our swap operation now means copying the entire buffer in memory. If the buffer is large, like an entire framebuffer, it can take a significant chunk of time to do this. Since nothing can read or write to <i>either</i> buffer while this is happening, that's a big limitaiton.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>What is the granularity of the buffer?</h3>
            <p><span class="glyphicon-remove"></span>The other question is how the buffer itself is organized - is it a single monolithic chunk of data or distributed among a collection of objects? Our graphics example uses the former, and the actors use the latter.</p>
            <p><span class="glyphicon-remove"></span>Most of the time, the nature of what you're buffering will lead to the answer but there's some flexibility. For example, our actors all coul have stored their messages in a single block that they all reference into by their index.</p>
            <p><span class="glyphicon-remove"></span>&bull; <b>If the buffer is monolithic:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; <i>Swapping is simpler.</i> Since there is only one pair of buffers, a single swap does it. If you can swap by changin pointers, then you can swap the entire buffer, regardless of size, with just a couple of assignments.</p>
            <p><span class="glyphicon-remove"></span>&bull; <b>If many objects have a piece of data:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; <i>Swapping is slower.</i>In order to swap, we need to iterate through the entire collection of objects and tell each one to swap.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; In our comedian example, that was OK since we need to clear the next slap state anyway - every piece of buffered state needs to be touched each frame. If we don't need to otherwise touch the old buffer, there's a simple optimization we can do to get the same performance of a monolithic buffer while distributing the buffer across multiple objects.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; The idea is to get the "current" and "next" pointer concept and apply it to each of our objects by turning them into object-relative <i>offsets</i>. Like so:</p>
            <pre>
            <span class="glyphicon-remove"></span>class Actor {
                public static void init() { current_ = 0; }
                public static void swap() { current_ = next(); }

                public void slap() { slap_[next()] = true; }
                public void wasSlapped() { return slapped_[current_]; }

                private static int current_;
                private static int next() { return 1 - current_; }

                private bool slapped_[2];
            }
            </pre>
            <p><span class="glyphicon-remove"></span>Actors access their current slap state by using current_ to index into the state array. The next state is always the other index in the array, so we can calculate that with next(). Swapping the state simply alternates the current_ index. The clever bit is that swap() is now a <i>static</i> function - it only needs to be called once, and every actor's state will be swapped.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="see-also">
    <h2>See Also</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            You can find the Double Buffer pattern in use in almost every graphics API out there. For example, OpenGL has swapBuffers(), Direct3D has "swap chains", and Microsoft's XNA framework swaps the framebuffers within its endDraw() method.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

                    <!-------------------------------------->
                </div>
            </div>
    </main>

    <!-------------------------------------------------------------------------->

    <!-- FOOTER -->
    <footer class="navbar navbar-inverse navbar-fixed-bottom">
        <nav>
            <div class="container">
                <div class="row">
                    <div class="col-md-6 col-sm-6 col-xs-12">
                        <ul>
                            <li>&copy; 2017 <a href="http://www.gabedeyo.com">Gabe Deyo</a></li>
                            <li>|</li>
                            <li><a href="mailto:gabedeyo@gmail.com?subject=Notes">gabedeyo@gmail.com</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>
    </footer>

    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
    <script src="../../../js/selection.js" charset="utf-8"></script>
</body>

</html>
