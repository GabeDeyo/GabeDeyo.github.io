<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Design Patterns - Subclass Sandbox</title>

    <meta name="viewport" content="width=device-width,initial-scale=1.0, shrink-to-fit=no" />

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="../../../css/page.css">
</head>

<body>

    <!-- Top Navigation -->
    <header>
        <nav class="navbar navbar-inverse">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapsemenu" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a href="../../../index.html" class="navbar-brand">Personal Notes</a>
                </div>

                <div class="collapse navbar-collapse" id="collapsemenu">
                    <ul class="nav navbar-nav">

                        <!-- GAME DEVELOMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Game Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- CONCEPTS -->
                                <li><a href="../../Categories/concepts.html">Concepts <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ENGINE -->
                                <li><a href="../../Categories/engine.html">Engine <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- IMPLEMENTATIONS -->
                                <li><a href="../../Categories/implementations.html">Implementations <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- PROGRAMMING -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Programming <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- LANGUAGES -->
                                <li><a href="../../../code/Categories/languages.html">Languages <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ALGORITHMS -->
                                <li><a href="../../../code/Categories/algorithms.html">Algorithms <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PROBLEMS -->
                                <li><a href="../../../code/Categories/problems.html">Problems <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- RANDOM -->
                                <li><a href="../../../code/Categories/random.html">Random <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- GABE DEVELOPMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Gabe Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- FITNESS PAGE -->
                                <li><a href="../../../gabe/Categories/fitness.html">Fitness <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- STYLE & GROOMING PAGE -->
                                <li><a href="../../../gabe/Categories/style.html">Style <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- FINANCE PAGE -->
                                <li><a href="../../../gabe/Categories/finance.html">Finance <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PHILOSOPHY PAGE -->
                                <li><a href="../../../gabe/Categories/philosophy.html">Philosophy <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                    </ul>
                </div>

            </div>
        </nav>
    </header>

    <!-------------------------------------------------------------------------->

    <!-- MAIN -->
    <main>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h1 id="title">Design Patterns - Subclass Sandbox</h1>

                    <aside>
                        <button type="button" class="btn btn-default" name="button" id="selectAll">Select All</button>
                        <button type="button" class="btn btn-default" name="button" id="clearAll">Clear All</button>
                    </aside>

                    <div class="jumbotron heliList">
                        <h2>Index</h2>
                        <ul>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#intent">Intent</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#motivation">Motivation</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#subclass-sandbox">Subclass Sandbox</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#when-to-use">When to Use It</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#keep-in-mind">Keep In Mind</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#sample-code">Sample Code</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#design-decisions">Design Decisions</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#see-also">See Also</a>
                                </p>
                            </li>
                        </ul>
                    </div>

<div class="jumbotron col-md-12 heliList" id="intent">
    <h2>Intent</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            <i>Define behavior in a subclass using a set of operations provided by its base class.</i>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="motivation">
    <h2>Motivation</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Every kid has dreamed of being a superhero, but unfortunately, cosmic rays are in short supply here on Earth. Games that let you pretend to be a superhero are the closest approximation. Because our game designers have never learned to say, "no", our superhero game aims to feature dozens, if not hundreds, of different superpowers that heros may choose from.
            <p><span class="glyphicon-remove"></span>Our plan is that we'll have a Superpower base class. Then we'll have a derived class that implements each superpower. We'll divvy up the design doc among our team of programmer and get coding. When we're done, we'll have a hundred superpower classes.</p>
            <p><span class="glyphicon-remove"></span>We want to immerse our players in a world teeming with variety. Whatever power they dreamed up when they were a kid, we want in our game. That means these superpower subclasses will be able to do just about everything: play sounds, spawn visual effects, interact with AI, create and destroy other game entities, and mess with physics. There's no corner of the codebase that they won't touch.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Let's say we unleashed our team and get them writing superpower classes. What's going to happen.
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; <i>There will be a ton of redundant code.</i> While the different powers will be wildly varied, we can still expect plenty of overlawp. Maany of them will spawn visual effects and play sounds in the same way. A freeze ray, heat ray, and Dijon mustard ray are all pretty similar when you get down to it. If the people implementing those don't coordinate, there's going to be a lot of duplicate code and effort.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; <i>Every part of the game engine will get coupled to these classes.</i> Without knowing better, people will write code that calls into subsystems that were never meant to be tied directly to the superpower classes. If our renderer is organized into several nice neat layers, only one of which is intented to be used by code outside of the graphics engine, we can bet that we'll end up with superpower code that pokes into every one of them.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; <i>When these outside systems need to change, odds are good some random superpower code will get broken.</i> Once we have different superpower classes coupling themselves to various and sundry parts of the game engine, it's inevitable that changes to those systems will impact the power classes. That's no fun because your graphics, audio, and UI programmers probably don't want to also have to be gameplay programmers too.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; <i>It's hard to define invariants that all superpowers obey.</i> Let's say we want to make sure that all audio player by our powers get properly queued and prioritized. There's no easy way to do that if our hundred classes are all directly calling into the sound engine on their own.</p>
            <p><span class="glyphicon-remove"></span>What we want is to give each of the gameplay programmers who is implementing a superpower a set of primitives they can play with. You want your power to play a sound? Here's your playSound() function. You want particles? Here's spawnParticles(). We'll make sure these operations cover everything you need to do so that you don't need to #include random headers and nose your way into the rest of the codebase.</p>
            <p><span class="glyphicon-remove"></span>We do this by making these operations <i>protected methods</i> of the Superpower <i>base class</i>. Putting them in the base class gives every power subclass direct, easy access to the methods. Making them protected (and likely non-virtual) communicates that they exist specifically to be <i>called</i> by subclasses.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Once we have these toys to play with, we need a place to use them. For that we'll define a <i>sandbox method</i>, an abstract protected method that subclasses must implement. Given those, to implement a new kind of power, you:
            <p><span class="glyphicon-remove"></span> &nbsp; 1. Create a new class that inherits from Superpower.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; 2. Override activate(), the sandbox method.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; 3. Implement the body of that by calling the protected methods that Superpower provides.</p>
            <p><span class="glyphicon-remove"></span>We can fix our redundant code problem now by making those provided operations as high-level as possible. When we see code that's duplicated between lots of the subclasses, we can always roll it up into Superpower as a new operation that they can all use.</p>
            <p><span class="glyphicon-remove"></span>We've addressed our coupling problem by constraining the coupling to one place. Superpower itself will end up coupled to the different game systems, but our hundred derived classes will not. Instead, they are <i>only</i> coupled to their base class. When one of those game systems changes, modifications to Superpower may be necessary, but dozens of subclasses shouldn't have to be touched.</p>
            <p><span class="glyphicon-remove"></span>This pattern leads to an architecture where you have a shallow but wide class hierarchy. Your inheritance chains aren't <i>deep</i>, but there are a <i>lot</i> of classes that hang off Superpower. By having a single class with a lot of direct subclasses, we have apoint of leverage in our codebase. Time and love that we put into Superpower can benefit a wide set of classes in the game.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="subclass-sandbox">
    <h2>Subclass Sandbox</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            A <b>base class</b> defines an abstract <b>sandbox method</b> and several <b>provided operations</b>. Marking them protected makes it clear that they are for use by derived classes. Each derived <b>sandboxed subclass</b> implements the sandbox method using the provided operations.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="when-to-use">
    <h2>When to Use It</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            The Subclass Sandbox pattern is a very simple, common pattern lurking in lots of codebases, even outside games. If you have a non-virtual protected method laying around, you're probably already using something like this.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Subclass Sandbox is a good fit when:
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; You have a base class with a number of derived classes.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; The base class is able to provide all of the operations that a derived class may need to perform.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; There is behavioral overlap in the subclasses and you want to make it easier to share code between them.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; You want to minimize coupling between those derived classes and the rest of the program.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="keep-in-mind">
    <h2>Keep In Mind</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            "Inheritance" is a bad word in many programming circles these days, and one reason is that base classes tend to accrete more and more code. This pattern is particularly susceptible to that.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Since subclasses go through their base class to reach the rest of the game, the base class ends up coupled to every system <i>any</i> derived class needs to talk to. Of course, the subclasses are also intimately tied to their base class. That spiderweb of coupling makes it very hard to change the base class without breaking something - you've got the brittle base class problem.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The flip side of the coin is that since most of your coupling has been pushed up to the base class, the derived classes are now much more cleanly separated from the rest of the world. Ideally, most of your behavior will be in those subclasses. That means much of your codebase is isolated and easier to maintain.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Still, if you find this pattern is turning your base class into a giant bowl of code stew, consider pulling some of the provided operations out into separate classes that the base class can dole out responsibility to. The <a href="design-patterns-component.html">Component</a> pattern can help here.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="sample-code">
    <h2>Sample Code</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Because this is such a simple pattern, there isn't much to the sample code. That doesn't mean it isn't useful - the pattern is abou the <i>intent</i>, not the complexity of its implementation.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We'll start with our Superpower base class:
            <pre>
            <span class="glyphicon-remove"></span>class Superpower {
                public virtual ~Superpower() {}

                protected virtual void activate() = 0;

                protected void move(double x, double y, double z) {
                    // Code here...
                }

                protected void playSound(SoundId sound, double volumne) {
                    // Code here...
                }

                protected void spawnParticles(ParticleType type, int count) {
                    // Code here...
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The activate() method is the sandbox method. Since it is virtual and abstract, subclasses <i>must</i> override it. This makes it clear to someone creating a power subclass where their work has to go.
            <p><span class="glyphicon-remove"></span>The other protected methods, move(), playSound(), and spawnParticles(), are the provided operations. These are what the subclasses will call in their implementation of activate().</p>
            <p><span class="glyphicon-remove"></span>We didn't implement the provided operations in this example, but an actual game would have real code obviously. Those methods are where Superpower gets coupled to other systems in the game - move() may call into physics code, playSound() will talk to the audio engine, etc. Since this is all in the <i>implementation</i> of the base class, it keeps that coupling encapsulated within Superpower itself.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Ok, now let's get our radioactive spiders out and create a power. Here's one:
            <pre>
            <span class="glyphicon-remove"></span>class SkyLaunch : public Superpower {
                protected virtual void activate() {
                    //Spring into the air.
                    playSound(SOUND_SPROING, 1.0f);
                    spawnParticles(PARTICLE_DUST, 10);
                    move(0, 0, 20);
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            This power springs the superhero into the air, playing an appropriate sound and kicking up a little cloud of dust. If all of the superpowers were this simple - just a combination of sound, particles, and motion - then we wouldn't need this pattern at all. Instead, Superpower could have a baked-in implementation of activate() that accesses fields for the sound ID, particle type, and movement. But that only works when every power essentially works the same way with only some difference in data. Let's elaborate on it a bit:
            <pre>
            <span class="glyphicon-remove"></span>class Superpower {
                protected double getHeroX() {
                    // Code here...
                }

                protected double getHeroY() {
                    // Code here...
                }

                protected double getHeroZ() {
                    // Code here...
                }

                //Existing stuff...
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Here, we've added a couple of methods to get the hero's position. Our SkyLaunch subclass can now use those:
            <pre>
            <span class="glyphicon-remove"></span>class SkyLaunch : public Superpower {
                protected virtual void activate() {
                    if(getHeroZ() == 0) {
                        // On the ground, so spring into the air.
                        playSound(SOUND_SPROING, 1.0f);
                        spawnParticles(PARTICLE_DUST, 10);
                        move(0, 0, 20);
                    } else if(getHeroZ() < 10.0f) {
                        // Near the ground, so do a double jump.
                        playSound(SOUND_SWOOP, 1.0f);
                        move(0, 0, getHeroZ() - 20);
                    } else {
                        // Way up in the air, so do a dive attack.
                        playSound(SOUND_DIVE, 0.7f);
                        spawnParticles(PARTICLE_SPARKLES, 1);
                        move(0, 0, -getHeroZ());
                    }
                }
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Since we have access to some state, now our sandbox method can do actual, interesting control flow. Here, it's still just a couple of simple if statements, but you can do anything you want. By having the sandbox method be an actual full-fledged method that contains arbitrary code, the sky's the limit.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="design-decisions">
    <h2>Design Decisions</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            As you can see, Subclass Sandbox is a fairly "soft" pattern. It describes a basic idea, but it doesn't have a lot of detailed mechanics. That means you'll be making some interesting choices each time you apply it. Here are some questions to consider.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>What operations should be provided?</h3>
            <p><span class="glyphicon-remove"></span>This is the biggest question. It deeply affects how this pattern feels and how well it works. At the minimal end of the spectrum, the base class doesn't provide <i>any</i> operations. It just has a sandbox method. To implement it, you'll have to call into systems outside of the base class. If you take that angle, it's probably not even fair to say you're using this pattern.</p>
            <p><span class="glyphicon-remove"></span>On the other end of the spectrum, the base class provides <i>every</i> operation that a subclass may need. Subclasses are <i>only</i> coupled to the base class and don't call into any outside systems whatsoever.</p>
            <p><span class="glyphicon-remove"></span>Between these two points, there's a wide middle ground where some operations are provided by the base class and others are accessed directly from the outside system that defines it. The more operations you provide, the less coupled subclasses are to outside systems, but the <i>more</i> coupled the base class is. It removes coupling fromthe derived classes, but it does so by pushing that up to the base class itself.</p>
            <p><span class="glyphicon-remove"></span>That's a win if you have a bunch of derived classes that were all coupled to some outside system. By moving the coupling up into a provided operation, you've centralized it into one place: the base class. But the more you do this, the bigger and harder to maintain that one class becomes.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            So where should you draw the line? Here are a few rules of thumb:
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; If a provided operation is only used by one or a few subclasses, you don't get a log of bang for your buck. You're adding complexity to the base class, which affects everyone, but only a couple of classes benefit.
            <br>This may be worth it to make the operation consistent with other provided operations, or it may be simpler and cleaner to let those special case subclasses call out to the external systems directly.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; When you call a method in some other corner of the game, it's less intrusive if that method doesn't modify any state. It still creates a coupling, but it's a "safe" coupling because it can't break anything in the game.
            <br>Calls that do modify state, on the other hand, more deeply tie you to those parts of the codebase, and you need to be much more cognizant of that. That makes them good candidates for being rolled up into provided operations in the more visible base class.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; If the implementation of a provided operation only forwards a call to some outside system, then it isn't adding much value. In that case, it may be simpler to call the outside method directly.
            <br>However, even simple forwarding can still be useful - those methods often access state that the base class doesn't want to directly expose to subclasses. For example, let's say Superpower provided this:</p>
            <pre>
            <span class="glyphicon-remove"></span>void playSound(SoundId sound, double volume) {
                soundEngine_.play(sound, volume);
            }
            </pre>
            <p><span class="glyphicon-remove"></span> &nbsp; It's just forwarding the call to some soundEngine_ field in Superpower. The advantage, though, is that it keeps that field encapsulated in Superpower so subclasses can't poke at it.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Should methods be provided directly, or through objects that contain them?</h3>
            <p><span class="glyphicon-remove"></span>The challenge with this pattern is that you can end up with a painfully large number of methods crammed into your base class. You can mitigate that by moving some of those methods over to other classes. The provided operations in the base class then just return one of those objects.</p>
            <p><span class="glyphicon-remove"></span>For example, to let a power play sounds, we could add these directly to Superpower:</p>
            <pre>
            <span class="glyphicon-remove"></span>class Superpower {
                protected void playSound(SoundId sound, double volume) {
                    // Code here...
                }

                protected void stopSound(SoundId sound) {
                    // Code here...
                }

                protected void setVolume(SoundId sound) {
                    // Code here...
                }

                // Sandbox method and other operations...
            }
            </pre>
            <p><span class="glyphicon-remove"></span>But if Superpower is already getting large and unwieldy, we might want to avoid that. Instead, we create a SoundPlayer class that exposes that functionality:</p>
            <pre>
            <span class="glyphicon-remove"></span>class SoundPlayer {
                void playSound(SoundId sound, double volume) {
                    // Code here...
                }

                protected void stopSound(SoundId sound) {
                    // Code here...
                }

                protected void setVolume(SoundId sound) {
                    // Code here...
                }
            }
            </pre>
            <p><span class="glyphicon-remove"></span>Then Superpower provides access to it;</p>
            <pre>
            <span class="glyphicon-remove"></span>class Superpower {
                protected SoundPlayer&amp; getSoundPlayer() {
                    return soundPlayer_;
                }

                // Sandbox method and other operations...

                private SoundPlayer soundPlayer_;
            }
            </pre>
            <p><span class="glyphicon-remove"></span>Shunting provided operations into auxiliary classes like this can do a few things for you:</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; <i>It reduces the number of methods in the base class.</i> In the example here, we went from three methods to just a single getter.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; <i>Code in the helper class is usually easier to maintain.</i> Core base classes like Superpower, despite our best intentions, tend to be tricky to change since so much depends on them. By moving functionality over to a less coupled secondary class, we make that code easier to poke at without breaking things.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; <i>It lowers the coupling between the base class and other systems.</i> When playSound() was a method directly on Superpower, our base class was directly tied to SoundId and whatever audio code the implementation called into. Moving that over to SoundPlayer reduces Superpower's coupling to the single SoundPlayer class, which then encapsulates all of its other dependencies.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>How does the base class get the state that it needs?</h3>
            <p><span class="glyphicon-remove"></span>Your base class will often need some data that it wants to encapsulate and keep hidden from its subclasses. In our first example, the Superpwer class provided a spawnParticles() method. If the implementation of that needs some particle system object, how would it get one?</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>Pass it to the base class constructor:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; The simplest solution is to have the base class take it as a constructor argument:</p>
            <pre>
            <span class="glyphicon-remove"></span>class Superpower {
                public Superpower(ParticleSystem* particles) : particles_(particles) {}

                // Sandbox method and other operations...

                private ParticleSystem* particles_;
            }
            </pre>
            <p><span class="glyphicon-remove"></span> &nbsp; This safely ensures that every superpower does have a particle system by the time it's constructed. But let's look at a derived class:</p>
            <pre>
            <span class="glyphicon-remove"></span>class SkyLaunch : public Superpower {
                public SkyLaunch(ParticleSystem* particles) : Superpower(particles) {}
            }
            </pre>
            <p><span class="glyphicon-remove"></span> &nbsp; Here we see the problem. Every derived class will need to have a constructor that calls the base class one and passes along the argument. That exposes every derived class to a piece of state that we don't want them to know about.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; this is also a maintenance headache. If we later add another piece of state to the base class, every constructor in each of our derived classes will have to be modified to pass it along.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>Do two-stage initialization:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; To avoid passing everything through the constructor, we can split initialization into two steps. The constructor will take no parameters and just create the object. Then, we call a separate method defined directly on the base class to pass in the rest of the data that it needs:</p>
            <pre>
            <span class="glyphicon-remove"></span>Superpower* power = new SkyLaunch();
            power->init(particles);
            </pre>
            <p><span class="glyphicon-remove"></span> &nbsp; Note here that since we aren't passing anything into the constructor for SkyLaunch, it isn't coupled into anything we want to keep private in Superpower. The trouble with this approach, though, is that you have to make sure you always remember to call init(). If you ever forget, you'll have a power that's in some twilight half-created state and won't work.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; You can fix that by encapsulating the entire process into a single function, like so:</p>
            <pre>
            <span class="glyphicon-remove"></span>Superpower* createSkyLaunch(ParticleSystem* particles) {
                Superpower* power = new SkyLaunch();
                power->init(particles);
                return power;
            }
            </pre>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>Make the state static:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; In the previous example, we were initializing each Superpower <i>instance</i> with a particle system. That makes sense when every power needs its own unique state. But let's say that the particle system is a singleton, and every power will be sharing the same state.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; In that case, we can make the state private to the base class and also make it <i>static</i>. The game will still have to make sure that it initializes the state, but it only has to initialize the Superpower <i>class</i> once for the entire game, and not each instance.</p>
            <pre>
            <span class="glyphicon-remove"></span>class Superpower {
                public static void init(ParticleSystem* particles) {
                    particles_ = particles;
                }

                // Sandbox method and other operations...

                private static ParticleSystem* particles_;
            }
            </pre>
            <p><span class="glyphicon-remove"></span> &nbsp; Note here that init() and particles are both static. As long as the game calls Superpower::init() once early on, every power can access the particle system. At the same time, Superpower instances can be created freely by calling the right derived class's constructor.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; Even better, now that particles_ is a <i>static</i> variable, we don't have to stroe it for each instance of Superpower, so we've made the class use less memory.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>Use a service locator:</b></p>
            <p><span class="glyphicon-remove"></span> &nbsp; The previous option requires that outside code specifically remembers to push in the state that the base class needs before it needs it. That places the burden of initialization on the surrounding code. Another option is to let the base class handle it by pulling in the state it needs. One way to do that is by using the <a href="design-patterns-service-locator.html">Service Locator</a> pattern:</p>
            <pre>
            <span class="glyphicon-remove"></span>class Superpower {
                protected void spawnParticles(ParticleType type, int count) {
                    ParticleSystem&amp; particles = Locator::getParticles();
                    particles.spawn(type, count);
                }

                //Sacndobx method and other operations...
            }
            </pre>
            <p><span class="glyphicon-remove"></span> &nbsp; Here, spawnParticles() needs a particle system. Insead of being <i>given</i> one by outside code, it fetches one itself from the service locator.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="see-also">
    <h2>See Also</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            &bull; When you apply the <a href="design-patterns-update-method.html">Update Method</a> pattern, your update method will often also be a sandbox method.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            &bull; This pattern is a role reversal of the Template Method pattern. In both patterns, you implement a method using a set of primitive operations. With Subclass Sandbox, the method is in the derived class and the primitive operations are in the base class. With Template Method, the <i>base</i> class has the method and the primitive operations are implemented by the <i>derived</i> class.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            &bull; You can also consider this a variation on the Facade pattern. That pattern hides a number of different systems behind a single simplified API. With Subclass Sandbox, the base class acts as a facade that hides the entire game engine from the subclasses.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

                    <!-------------------------------------->
                </div>
            </div>
    </main>

    <!-------------------------------------------------------------------------->

    <!-- FOOTER -->
    <footer class="navbar navbar-inverse navbar-fixed-bottom">
        <nav>
            <div class="container">
                <div class="row">
                    <div class="col-md-6 col-sm-6 col-xs-12">
                        <ul>
                            <li>&copy; 2017 <a href="http://www.gabedeyo.com">Gabe Deyo</a></li>
                            <li>|</li>
                            <li><a href="mailto:gabedeyo@gmail.com?subject=Notes">gabedeyo@gmail.com</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>
    </footer>

    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
    <script src="../../../js/selection.js" charset="utf-8"></script>
</body>

</html>
