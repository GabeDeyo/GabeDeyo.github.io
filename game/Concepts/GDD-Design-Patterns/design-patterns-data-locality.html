<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Design Patterns - Data Locality</title>

    <meta name="viewport" content="width=device-width,initial-scale=1.0, shrink-to-fit=no" />

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="../../../css/page.css">
</head>

<body>

    <!-- Top Navigation -->
    <header>
        <nav class="navbar navbar-inverse">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapsemenu" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a href="../../../index.html" class="navbar-brand">Personal Notes</a>
                </div>

                <div class="collapse navbar-collapse" id="collapsemenu">
                    <ul class="nav navbar-nav">

                        <!-- GAME DEVELOMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Game Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- CONCEPTS -->
                                <li><a href="../../Categories/concepts.html">Concepts <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ENGINE -->
                                <li><a href="../../Categories/engine.html">Engine <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- IMPLEMENTATIONS -->
                                <li><a href="../../Categories/implementations.html">Implementations <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- PROGRAMMING -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Programming <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- LANGUAGES -->
                                <li><a href="../../../code/Categories/languages.html">Languages <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ALGORITHMS -->
                                <li><a href="../../../code/Categories/algorithms.html">Algorithms <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PROBLEMS -->
                                <li><a href="../../../code/Categories/problems.html">Problems <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- RANDOM -->
                                <li><a href="../../../code/Categories/random.html">Random <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- GABE DEVELOPMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Gabe Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- FITNESS PAGE -->
                                <li><a href="../../../gabe/Categories/fitness.html">Fitness <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- STYLE & GROOMING PAGE -->
                                <li><a href="../../../gabe/Categories/style.html">Style <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- FINANCE PAGE -->
                                <li><a href="../../../gabe/Categories/finance.html">Finance <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PHILOSOPHY PAGE -->
                                <li><a href="../../../gabe/Categories/philosophy.html">Philosophy <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                    </ul>
                </div>

            </div>
        </nav>
    </header>

    <!-------------------------------------------------------------------------->

    <!-- MAIN -->
    <main>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h1 id="title">Design Patterns - Data Locality</h1>

                    <aside>
                        <button type="button" class="btn btn-default" name="button" id="selectAll">Select All</button>
                        <button type="button" class="btn btn-default" name="button" id="clearAll">Clear All</button>
                    </aside>

                    <div class="jumbotron heliList">
                        <h2>Index</h2>
                        <ul>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#0">Intent</a>
                                </p>
                            </li>
                            <li><p><span class='glyphicon-remove'></span>
                                <a href='#1'>Motivation</a>
                                </p>
                            </li>
                            <li><p><span class='glyphicon-remove'></span>
                                <a href='#2'>Data Locality</a>
                                </p>
                            </li>
                            <li><p><span class='glyphicon-remove'></span>
                                <a href='#3'>When to Use It</a>
                                </p>
                            </li>
                            <li><p><span class='glyphicon-remove'></span>
                                <a href='#4'>Keep in Mind</a>
                                </p>
                            </li>
                            <li><p><span class='glyphicon-remove'></span>
                                <a href='#5'>Sample Code</a>
                                </p>
                            </li>
                        </ul>
                    </div>

<div class="jumbotron col-md-12 heliList" id="0">
    <h2>Intent</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            <i>Accelerate memory access by arranging data to take advantage of CPU caching.</i>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class='jumbotron col-md-12 heliList' id='1'>
    <h2>Motivation</h2>
    <ul>
        <li><p><span class='glyphicon-remove'></span>
            We've been lied to. They keep showing us charts where CPU speed goes up and up every year as if Moore's Lawy isn't just a historical observation but some kind of divine right. Without lifting a finger, we software folks watch our programs magically accelerate just by virtue of new hardware.
            <p><span class='glyphicon-remove'></span>Chips <i>have</i> been getting faster (though even that's plateauing now), but the hardware heads failed to mention something. Sure, we can <i>process</i> data faster than ever, but we can't <i>get</i> that data faster. Processor and RAM speed relative to their respective speeds in 1980. CPUs have grown leaps and bounds, however RAM access is lagging far behind.</p>
            <p><span class='glyphicon-remove'></span>For your super-fast CPU to blow through a ream of calculations, it actually has to get the data out of main memory and into registers. But RAM hasn't been keeping up with increasing CPU speeds. Not even close.</p>
            <p><span class='glyphicon-remove'></span>With today's hardware, it can take <i>hundreds</i> of cycles to fetch a byte of data from RAM. If most instructions need data, and it takes hundreds of cycles to get it, how is it that our CPUs aren't sitting idle 99% of the time waiting for data?</p>
            <p><span class='glyphicon-remove'></span>Actually, they <i>are</i> stuck waiting on memory an astonishingly large fraction of time these days, but it's not as bad as it used to be. It's called "random access memory" because, unlike disc drives, you can theoretically access any piece of it as quick as any other. You don't have to worry about reading things consecutively like you do a disc. Or, at least, you <i>didn't</i>. As we'll see, RAM isn't so random access anymore. To explain all of this, let's take a trip to the Land of Overly Long Analogies...</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>A Data Warehouse</h3>
            <p><span class='glyphicon-remove'></span>Imagine you're an accountant in a tiny little office. Your job is to request a box of papers and then do some accountant-y stuff with them - add up a bunch of numbers or something. you must do this for specific labeled boxes according to some arcane logic that only makes sense to other accountants.</p>
            <p><span class='glyphicon-remove'></span>Thanks to a mixture of hard work, natural aptitude, and stimulants, you can finish an entire box in, say, a minute. There's a little problem though. All of those boxes are stored in a warehouse in a separate building. To get a box, you have to ask the warehouse guy to bring it to you. He goes and gets a forklift and drives around the aisles until he finds the box you want.</p>
            <p><span class='glyphicon-remove'></span>It takes him, seriously, an entire day to do this. Unlike you, he's not getting employee of the month anytime soon. This means that no matter how fast you are, you only get one box a day. The rest of the time, you sit there and question the life decisions that led to this soul-sucking job.</p>
            <p><span class='glyphicon-remove'></span>One day, a group of industrial designers shows up. Their job is to improve the efficiency of operations - things like making assembly lines go faster. After watching you work for a few days, they notice a few things:
            <br> &nbsp; &bull; Pretty often, when you're done with one box, the next box you request is right next to it on the same shelf in the warehouse.
            <br> &nbsp; &bull; Using a forklift to carry a single box of papers is pretty dumb.
            <br> &nbsp; &bull; There's actually a little bit of spare room in the corner of your office.</p>
            <p><span class='glyphicon-remove'></span>They come up with a clever fix. Whenever you request a box from the warehouse guy, he'll grab an entire pallet of them. He gets the box you want and then some more boxes that are next to it. He doesn't know if you want those; he simply takes as many as he can fit on the pallet.</p>
            <p><span class='glyphicon-remove'></span>He loads the whole pallet and brings it to you. Disregarding concerns for workplace safety, he drives the forklift right in and drops the pallet in the corner of your office.</p>
            <p><span class='glyphicon-remove'></span>When you need a new box, now, the first thing you do is see if it's already on the pallet in your office. If it is, great! It only takes you a second to grab it and get back to crunching numbers. If a pallet holds fifty boxes and you got lucky and <i>all</i> of the boxes you need happen to be on it, you can churn through fifty times more work than you could before.</p>
            <p><span class='glyphicon-remove'></span>But if you need a box that's <i>not</i> on the pallet, you're back to square one. Since you can only fit on pallet in your office, your warehouse friend will have to take that one back and bring an entirely new one.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>A Pallet for your CPU</h3>
            <p><span class='glyphicon-remove'></span>Strangely enough, this is similar to how CPUs in modern computers work. In case it isn't obvious, you play the role of the CPU. Your desk is the CPU's registers, and the box of papers is the data you can fit in them. The warehouse is your machine's RAM, and that annoying warehouse guy is the bus that pulls data from main memory into registers.</p>
            <p><span class='glyphicon-remove'></span>If I wer writing this chapter 30 years ago, the anology would stop there. But as chips got faster and RAM, well, <i>didn't</i>, hardware engineers started looking for solutions. What they came up with was <b>CPU caching</b>.</p>
            <p><span class='glyphicon-remove'></span>Modern computers have a little chunk of memory right inside the chip. The CPU can pull data from this much faster than it can from main memory. It's small because it has to fit in the chip and because the faster type of memory it uses (static RAM or "SRAM") is way more expensive.</p>
            <p><span class='glyphicon-remove'></span>Modern hardware has multiple levels of caching, which is wahy they mean when you hear "L1", "L2", "L3", etc. Each level is larger but slower than the previous. For this chapter, we won't worry about the fact that memory is actually a hierarchy, but it's important to know.</p>
            <p><span class='glyphicon-remove'></span>The little chunk of memory is called a <b>cache</b> (in particular, the chunk on the chip is your L1 <i>cache</i>), and in my belabored analogy, its part was played by the pallet of boxes. Whenever your chip needs a byte of data from RAM, it automatically grabs a whole chunk of contiguous memory — usually around 64 to 128 bytes — and puts it in the cache. This dollop of memory is called a <b>cache line</b>. 
            <br>CACHE LINE => [ Adjacent Memory Loaded in Cache | *byte you requested* | AMLiC ] </p>
            <p><span class='glyphicon-remove'></span>If the next byte of data you need happens to be in that chunk, the CPU reads it straight from the cache, which is <i>much</i> faster than hitting RAM. Successfully finding a piece of data in the cache is called a <b>cache hit</b>. If it can't find it in there and has to go to main memory, that's a <b>cache miss</b>.</p>
            <p><span class='glyphicon-remove'></span>I did gloss over (at least) one detail in the analogy. In your office, there was only room for one pallet, or one cache line. A real cache contains a number of cache lines. The details about how those work is out of scope here, but search for "cach associativity" to feed the brain.</p>
            <p><span class='glyphicon-remove'></span>When a cache miss occurs, the CPU <b>stalls</b> - it can't process the next instruction because it needs data. It sits there, bored out of its mind for a few hundred cycles until the fetch completes. Our mission is to avoid that. Imaginge you're trying to optimize some performance-critical piece of game code and it loks like this:</p>
            <pre>
            <span class='glyphicon-remove'></span>for(int i = 0; i < NUM_THINGS; i++) {
                sleepFor500Cycles();
                things[i].doStuff();
            }
            </pre>
            <p><span class='glyphicon-remove'></span>What's the first change you're going to make to that code? Right. Take out that pointless, expensive function call. That call is equivalent to the performance cost of a cache miss. Every time you bounce to main memory, it's like you put a delay in your code.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Wait, data is performance?</h3>
            <p><span class='glyphicon-remove'></span>When I started working on this chapter, I spent some time putting together little game-like programs that would trigger best case and worst case cache usage. I wanted benchmarks that would thrash the cache so I could see first-hand how much bloodshed it causes. When I got some stuff working, I was surprised. I knew it was a big deal, but there's nothing quite like seeing it with your own eyes. I wrote two programs that did the <i>exact same</i> computation. The only difference was how many cache misses they caused. The slow one was <i>fifty times</i> slower than the other.</p>
            <p><span class='glyphicon-remove'></span>This was a real eye-opener to me. I'm used to thinking performance being an aspect of <i>code</i>, not <i>data</i>. A byte isn't slow or fast, it's just some static thing sitting there. But because of caching, <i>the way you organize data directly impacts performance</i>.</p>
            <p><span class='glyphicon-remove'></span>There are a lot of caveats here. In particular, different computers have different cache setups, so my machine may be different from yours, and dedicated game consoles are very different from PC, which are quite different from mobile devices. You mileage will vary.</p>
            <p><span class='glyphicon-remove'></span>The challenge now is to wrap that up into something that fits into a chapter here. Optimization for cache usage is a huge topic. I haven't even touched on <i>instruction caching</i>. Remember, code is in memory too and has to be loaded onto the CPU before it can be executed. someone more versed could write an entire book on it. (<a href="http://www.dataorienteddesign.com/dodmain/">Data-Oriented Design</a>, by Richard Fabian)</p>
            <p><span class='glyphicon-remove'></span>Since you're already reading <i>this</i> book now, though, I have a few basic techniques that will get you started along the path of thinking about how data structures impact your performance.</p>
            <p><span class='glyphicon-remove'></span>Keep in mind, there's a key assumption here: one thread. If you are modifying nearby data on multiple threads, it's faster to have it on <i>different</i> cache lines. If two threads try to tweak data on the same cache line, both cores have to do some costly synchronization of their caches.</p>
            <p><span class='glyphicon-remove'></span>It all boils down to something pretty simple: whenever the chip reads some memory, it gets a whole cache line. The more you can use stuff in that cache line, the faster you go. So the goal then is to <i>organize our data structures so that the things you're processing are next to each other in memory.</i> In other words, if your code is crunching on <i>THING</i>, the <i>ANOTHER</i>, then <i>ALSO</i>, you want them laid out in memory like this: 
            <br>[ THING | ANOTHER | ALSO ]</p>
            <p><span class='glyphicon-remove'></span>Note, these aren't <i>pointers</i> to THING, ANOTHER, and ALSO. This is the actual data for them, in place, lined up one after the other. As soon as the CPU reads in THING, it will start to get ANOTHER and ALSO too (depending on how big they are and how big the cache line is). When you start working on them next, they'll already be cached. Your chip is happy, you're happy.</p>
        </p></li>
    </ul>
    <a href='#title'><span class='glyphicon-menu-up'></span></a>
</div>

<div class='jumbotron col-md-12 heliList' id='2'>
    <h2>Data Locality</h2>
    <ul>
        <li><p><span class='glyphicon-remove'></span>
            Modern CPUs have <b>caches to speed up memory access</b>. These can access memory <b>adjacent to recently accessed memory much quicker</b>. Take advantage of that to improve performance by <b>increasing data locality</b> - keeping data in <b>contiguous memory in the order that you process it</b>.
        </p></li>
    </ul>
    <a href='#title'><span class='glyphicon-menu-up'></span></a>
</div>

<div class='jumbotron col-md-12 heliList' id='3'>
    <h2>When to Use It</h2>
    <ul>
        <li><p><span class='glyphicon-remove'></span>
            Like most optimizations, the first guideline for using the Data Locality pattern is <i>when you have a performance problem.</i> Don't waste time applying this to some infrequently executed corner of your codebase. Optimizing code that doesn't need it just makes your life harder since the result is almost always more complex and less flexible.
            <p><span class='glyphicon-remove'></span>With this pattern specifically, you'll also want to be sure your performance problems <i>are caused by cache misses.</i> If your code is slow for other reasons, this won't help.</p>
            <p><span class='glyphicon-remove'></span>The cheap way to profile is to manually add a bit of instrumentation that checks how much time has elapsed between two points in the code, hopefully using a precise timer. To catch poor cache usage, you'll want something a little more sophisticated. You really want to see how many cache misses are occurring and where.</p>
            <p><span class='glyphicon-remove'></span>Fortunately, there are profilers out there that report this. It's worth spending the time to get one of these working and make sure you understand the (surprisingly complex) numbers it throws at you before you do major surgery on your data structures.</p>
            <p><span class='glyphicon-remove'></span>That being said, cache misses <i>will</i> affect the performance of your game. While you shouldn't spend a ton of time pre-emptively optimizing for cache usage, do think about how cache-friendly your data structures are throughout the design process.</p>
            <p><span class='glyphicon-remove'></span>Unfortunatly, most of the tools aren't cheap. If you're on a console dev team, you probably already have licenses for them. If not, an excellent free option is <a href="http://valgrind.org/docs/manual/cg-manual.html">Cachegrind</a>. It runs your program on top of a simulated CPU and cache hierarchy and then reports all of the cache interactions.</p>
        </p></li>
    </ul>
    <a href='#title'><span class='glyphicon-menu-up'></span></a>
</div>

<div class='jumbotron col-md-12 heliList' id='4'>
    <h2>Keep in Mind</h2>
    <ul>
        <li><p><span class='glyphicon-remove'></span>
            One of the hallmarks of software architecture is <i>abstraction</i>. A large chunk of this book is about patterns to decouple pieces of code from each other so that they can be changed more easily. In object-oriented languages, this almost always means interfaces.
            <p><span class='glyphicon-remove'></span>In C++, using interfaces implies accessing objects through pointers or references. But going through a pointer means hopping across memory, which leads to the cache misses this pattern works to avoid. The other half of interfaces is <i>virtual method calls.</i> Those require the CPU to look up an object's vtable and then find the pointer to the actual method to call there. So, again, you're chsing pointers, which can cause cache misses.</p>
            <p><span class='glyphicon-remove'></span>In order to please this pattern, you will have to sacrifice some of your precious abstractions. The more you design your program around data locality, the more you will have to give up inheritance, interfaces, and the benefits of those tools can provide. There's no silver bullet here, only challenging trade-offs. That's what makes it fun!</p>
        </p></li>
    </ul>
    <a href='#title'><span class='glyphicon-menu-up'></span></a>
</div>

<div class='jumbotron col-md-12 heliList' id='5'>
    <h2>Sample Code</h2>
    <ul>
        <li><p><span class='glyphicon-remove'></span>
            If you really go down the rabbit hole of optimizating for data locality, you'll discover countless ways to slice and dice your data structures into pieces your CPU can most easily digest. To get started, we'll go over an example for each of a few of the most common ways to organize your data. We'll cover them in the context of some specific part of game engine, but (as with other patterns), keep in mind that the general technique can be applied anywhere it fits.
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Contiguous Arrays</h3>
            <p><span class='glyphicon-remove'></span>Let's start with a game loop that processes a bunch of game entities. Those entities are decomposed into different domains - AI, physics, and rendering - using the Component pattern. Here's the <i>GameEntity</i> class:</p>
            <pre>
                class GameEntity {
                public:
                    GameEntity(AIComponent* ai,
                                PhysicsComponent* physics,
                                RenderComponent* render)
                    : ai_(ai), physics_(physics), render_(render)
                    {}

                    AIComponent* ai() { return ai_; }
                    PhysicsComponent* physics() { return physics_; }
                    RenderComponent* render() { return physics_; }

                private:
                    AIComponent* ai_;
                    PhysicsComponent* physics_;
                    RenderComponent* render_;
                };
            </pre>
            <p><span class='glyphicon-remove'></span>Each component has a relatively small amount of state, maybe little more than a few vectors or a matrix, and then a method to update it. The details aren't important here, but imagine something roughly along the lines of:</p>
            <pre>
            <span class='glyphicon-remove'></span>class AIComponent {
            public:
                void update() { /* Work with and modify state... */ }

            private:
                //Goals, mood, etc...
            };

            class PhysicsComponent {
            public:
                void update() { /* Work with and modify state... */ }

            private:
                //Rigidbody, veloctiy, mass, etc...
            };

            class RenderComponent {
            public:
                void render() { /* Work with and modify state... */ }

            private:
                //Mesh, textures, shaders, etc...
            };
            </pre>
            <p><span class='glyphicon-remove'></span>The game maintains a big array of pointers to all of the entities in the world. Each spin of the game loop, we need to run the following:
            <br> &nbsp; 1. Update the AI components for all of the entities.
            <br> &nbsp; 2. Update the physics components for them.
            <br> &nbsp; 3. Render them using their renderer components.</p>
            <p><span class='glyphicon-remove'></span>Lots of game engines implement that like so:</p>
            <pre>
            <span class='glyphicon-remove'></span>while(!gameOver) {
                //Process AI.
                for(int i = 0; i < numEntities; i++) {
                    entities[i]->ai()->update();
                }

                //Update Physics
                for(int i = 0; i < numEntities; i++) {
                    entities[i]->physics()->update();
                }

                //Draw screen
                for(int i = 0; i < numEntities; i++) {
                    entities[i]->render()->render();
                }

                //Other game loop machinery for timing...
            }
            </pre>
            <p><span class='glyphicon-remove'></span>Before you ever heard of a CPU cache, this looked totally innocuous. But by now, you've got an inlking that something isn't right here. This code isn't just thrashing the cache, it's taking it around the back and beating it to a pulp. Watch what it's doing:
            <br> &nbsp; 1. The array of game entities is storing <i>pointers</i> to them, so for each element in the array, we have to traverse that pointer. That's a cache miss.
            <br> &nbsp; 2. Then the game entity has a pointer to the component. Another cache miss.
            <br> &nbsp; 3. Then we update the component.
            <br> &nbsp; 4. Now we go back to step one for <i>every component of every entity in the game.</i></p>
            <p><span class='glyphicon-remove'></span>The scary part is that we have no idea how these objects are laid out in memory. We're completely at the mercy of the memory manager. As entities get allocated and freed over time, the heap is likely to become increasingly randomly organized.</p>
            <p><span class='glyphicon-remove'></span>If our goal was to take a whirlwind tour around the game's address space like some "256MB of RAM in Four Nights!" cheap vacation package, this would be a fantastic deal. But our goal is to run the game quickly, and triapsing all over main memory is <i>not</i> the way to do that. Remember that <i>sleepFor500Cycles()</i> function? Well this code is effectively calling that <i>all the time</i>!</p>
            <p><span class='glyphicon-remove'></span>The term for wasting a bunch of time traversing pointers is <i>"pointer chasing"</i>, which is not nearly as fun as it sounds.</p>
            <p><span class='glyphicon-remove'></span>Let's do something better. Our first observation sithat the only reason we follow a pointer to get to the game entity is so we can immediately follow <i>another</i> pointer to get to a component. <i>GameEntity</i> itself has no interesting state and no useful methods. The <i>components</i> are what the game loop cares about.</p>
            <p><span class='glyphicon-remove'></span>Instead of a giant constellation of game entities and components scattered across the inky darkness of address space, we're going to get back down to Earth. We'll have a big array for each type of component: a flat array of AI components, another for physics, and another for rendering.</p>
            <p><span class='glyphicon-remove'></span>Like this:</p>
            <pre>
            <span class='glyphicon-remove'></span>AIComponent* aiComponents = 
                new AIComponent[MAX_ENTITIES];
            PhysicsComponent* physicsComponents = 
                new PhysicsComponent[MAX_ENTITIES];
            RenderComponent* renderComponents = 
                new RenderComponent[MAX_ENTITIES];
            </pre>
            <p><span class='glyphicon-remove'></span>Let me stress that these are arrays of <i>components</i> and <i>not pointers to components</i>. The data is all there, one byte after another. The game loop can then walk these directly:</p>
            <pre>
            <span class='glyphicon-remove'></span>while(!gameOver) {
                //Process AI
                for(int i = 0; i < numEntities; i++) {
                    aiComponents[i].update();
                }

                //Update Physics
                for(int i = 0; i < numEntities; i++) {
                    physicsComponents[i].update();
                }

                //Draw to screen
                for(int i = 0; i < numEntities; i++) {
                    renderComponents[i].update();
                }

                //Other game lop machinery for timing...
            }
            </pre>
            <p><span class='glyphicon-remove'></span>We've ditched all of that pointer chasing. Instead of skipping around in memory, we're doing a straight crawl through three contiguous arrays. This pumps a solid stream of bytes right into the hungry maw of the CPU. In my testing, this change made the update loop <i>fifty times</i> faster than the previous version.</p>
            <p><span class='glyphicon-remove'></span>Interestingly, we haven't lost much encapsulation here. Sure, the game loop is updating the components directly instead of going through the game entities, but it was doing that before to ensure they were processed in the right order. Even so, each component itself is still nicely encapsulated. It owns its own data and methods. We simply changed the way it's used.</p>
            <p><span class='glyphicon-remove'></span>This doesn't mean we need to get rid of GameEntity either. We can leave it as it is with pointers to its components. They'll just point into those arrays. This is still useful for other parts of the game where you want to pass around a conceptual "game entity" and everything that goes with it. The important part is that the performance-critical game loop sidesteps that and goes straight to the data.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Packed Data</h3>
            <p><span class='glyphicon-remove'></span>Say we're doing a particle system. Following the advice of the previous section, we've got all of our particles in a nice big contiguous array. Let's wrap it in a little manager class too:</p>
            <pre>
            <span class='glyphicon-remove'></span>class Particle {
            public:
                void update() { /* Gravity, etc. */ }
                // Position, velocity, etc...
            };

            class ParticleSyste {
            public:
                ParticleSystem() : numParticles_(0) { }
                void update();
            private:
                static const int MAX_PARTICLES = 100000;

                int numParticles_;
                Particle particles_[MAX_PARTICLES];
            }
            </pre>
        </p></li>
    </ul>
    <a href='#title'><span class='glyphicon-menu-up'></span></a>
</div>

                    <!-------------------------------------->
                </div>
            </div>
    </main>

    <!-------------------------------------------------------------------------->

    <!-- FOOTER -->
    <footer class="navbar navbar-inverse navbar-fixed-bottom">
        <nav>
            <div class="container">
                <div class="row">
                    <div class="col-md-6 col-sm-6 col-xs-12">
                        <ul>
                            <li>&copy; 2017 <a href="http://www.gabedeyo.com">Gabe Deyo</a></li>
                            <li>|</li>
                            <li><a href="mailto:gabedeyo@gmail.com?subject=Notes">gabedeyo@gmail.com</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>
    </footer>

    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
    <script src="../../../js/selection.js" charset="utf-8"></script>
</body>

</html>