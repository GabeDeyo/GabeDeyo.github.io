<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Design Patterns - Service Locator</title>

    <meta name="viewport" content="width=device-width,initial-scale=1.0, shrink-to-fit=no" />

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="../../../css/page.css">
</head>

<body>

    <!-- Top Navigation -->
    <header>
        <nav class="navbar navbar-inverse">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapsemenu" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a href="../../../index.html" class="navbar-brand">Personal Notes</a>
                </div>

                <div class="collapse navbar-collapse" id="collapsemenu">
                    <ul class="nav navbar-nav">

                        <!-- GAME DEVELOMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Game Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- CONCEPTS -->
                                <li><a href="../../Categories/concepts.html">Concepts <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ENGINE -->
                                <li><a href="../../Categories/engine.html">Engine <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- IMPLEMENTATIONS -->
                                <li><a href="../../Categories/implementations.html">Implementations <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- PROGRAMMING -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Programming <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- LANGUAGES -->
                                <li><a href="../../../code/Categories/languages.html">Languages <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ALGORITHMS -->
                                <li><a href="../../../code/Categories/algorithms.html">Algorithms <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PROBLEMS -->
                                <li><a href="../../../code/Categories/problems.html">Problems <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- RANDOM -->
                                <li><a href="../../../code/Categories/random.html">Random <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- GABE DEVELOPMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Gabe Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- FITNESS PAGE -->
                                <li><a href="../../../gabe/Categories/fitness.html">Fitness <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- STYLE & GROOMING PAGE -->
                                <li><a href="../../../gabe/Categories/style.html">Style <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- FINANCE PAGE -->
                                <li><a href="../../../gabe/Categories/finance.html">Finance <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PHILOSOPHY PAGE -->
                                <li><a href="../../../gabe/Categories/philosophy.html">Philosophy <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                    </ul>
                </div>

            </div>
        </nav>
    </header>

    <!-------------------------------------------------------------------------->

    <!-- MAIN -->
    <main>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h1 id="title">Design Patterns - Service Locator</h1>

                    <aside>
                        <button type="button" class="btn btn-default" name="button" id="selectAll">Select All</button>
                        <button type="button" class="btn btn-default" name="button" id="clearAll">Clear All</button>
                    </aside>

                    <div class="jumbotron heliList">
                        <h2>Index</h2>
                        <ul>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#intent">Intent</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#motivation">Motivation</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#service-locator">Service Locator</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#when-to-use">When to Use It</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#keep-in-mind">Keep in Mind</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#sample-code">Sample Code</a>
                                </p>
                            </li>
                            <li><p><span class='glyphicon-remove'></span>
                                <a href='#design-decisions'>Design Decisions</a>
                                </p>
                            </li>
                        </ul>
                    </div>

<div class="jumbotron col-md-12 heliList" id="intent">
    <h2>Intent</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            <i>Provide a global point of access to a service without coupling users to the concrete class that implements it.</i>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="motivation">
    <h2>Motivation</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Some objects or systems in a game tend to get around, visiting almost every corner of the codebase. It's hard to find a part of the game that <i>won't</i> need a memory allocator, logging, or random numbers at some point. Systems like those can be thought of as <i>services</i> that need to be available to the entire game.
            <p><span class="glyphicon-remove"></span>For our example, we'll consider audio. It doesn't have quite the reach of something lower-level like a memory allocator, but it still touches a bunch of game systems. A falling rock hits the ground with a crash (Physics). A sniper NPC fires his rifle and a shot rings out (AI). The user selects a menu item with a beep of confirmation (User Interface).</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Each of these places will need to be able to call into the audio system with something like one of these:
            <pre>
            <span class="glyphicon-remove"></span>//Use a static class?
            AudioSystem::playSound(VERY_LOUND_BANG);

            //Or maybe a singleton?
            AudioSystem::instance()->playSound(VERY_LOUD_BANG);
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Either gets us where we're trying to go, but we stumbled into some sticky coupling along the way. Every place in the game calling into our audio system directly references the concrete AudioSystem class and the mechanism for accessing it - either as a static class or a singleton.
            <p><span class="glyphicon-remove"></span>These call sites, of course have to be coupled to <i>something</i> in order to make a sound play, but letting them poke at the concrete audio implementaiton directly is like giving a hundred strangers directions to your house just so they can drop a ltter on your doorstep. Not only is it a little bit <i>too</i> personal, it's a real pain when you move and you have to tell each person the new directions.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            There's a better solution: a phone book. People that need to get in touch with us can look us up by name and get our current address. When we move, we tell the phone company. They update the book, and everyone gets the new address. In fact, we dont' even need to give out our real address at all. We can list a P.O. box or some other "representation" of ourselves instead. By having callers go through the book to find us, we have a <i>convenient single place where we control how we're found.</i>
            <p><span class="glyphicon-remove"></span>This is the Service Locator pattern in a nutshell - it decouples code that needs a service from both <i>who</i> it is (the concrete implementation type) and <i>where</i> it is (how we get to the instance of it).</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="service-locator">
    <h2>Service Locator</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            A <b>service</b> class defines an abstract interface to a set of operations. A concrete <b>service provider</b> implements this interface. A separate <b>service locator</b> provides access to the service by finding an appropriate provider while hiding both the provider's concrete type and the process used to locate it.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="when-to-use">
    <h2>When to Use It</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Anytime you make something accessible to every part of your program, you're asking for trouble. That's the main problem with the Singleton pattern, and this pattern is no different. My most simple advice for using a service locator is: <i>sparingly</i>.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Instead of using a global mechanism to give some code access to an object it needs, first consider <i>passing the object to it instead.</i> That's dead simple, and it makes the coupling completely obvious. That will cover most of your needs.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <i>But...</i> there are some times when manually passing around an object is gratuitous or actively makes code harder to read. Some systems, like logging or memory management, shouldn't be part of a module's public API. The parameters to your rendering code should have to do with <i>rendering</i>, not stuff like logging.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Likewise, other systems represent facilities that are fundamentally singular in nature. Your game probably only has one audio device or display system that it can talk to. It is an ambitent property of the environment, so plumbing it through ten layers of methods just so one deeply nested call can get to it is adding needless complexity to your code.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In those kinds of cases, this pattern can help. As we'll see, it functions as a more flexible, more configurable cousin of the Singleton pattern. When used well, it can make your codebase more flexible with little runtime cost.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="keep-in-mind">
    <h2>Keep in Mind</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            The core difficulty with a service locator is that it takes a dependency - a bit of coupling between two pieces of code - and defers wiring it up until runtime. This gives you flexibility, but the price you pay is that it's harder to understand what your dependencies are by reading the code.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>The service actually has to be located</h3>
            <p><span class="glyphicon-remove"></span>With a singleton or a static class, there's no chance for the instance we need to <i>not</i> be available. Calling code can take for granted that it's there. but since this pattern has to <i>locate</i> the service, we may need to handle cases where that fails. Fotunately, we'll cover a strategy later to address this and guarantee that we'll always get <i>some</i> service when you need it.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>The service doens't know who is locating it</h3>
            <p><span class="glyphicon-remove"></span>Since the lcator is globally accessible, any code in the game could be requesting a service and thn poking at it. This means that the service must be able to work correctly in any circumstance. For example, a class that expects to be used only during the simulation portion of the game loop and not during rendering may not work as a service - it would'nt be able to ensure that it's being used at the right time. So, if a class expects to be used only in a certain context, it's safest to avoid exposing it to the entire world with this pattern.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="sample-code">
    <h2>Sample Code</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Getting back to our audio system problem, let's address it by exposing the system to the rest of the codebase through a service locator.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>The Service</h3>
            <p><span class="glyphicon-remove"></span>We'll start off with the audio API. This is the interface that our service will be exposing:</p>
            <pre>
            <span class="glyphicon-remove"></span>class Audio {
                public virtual ~Audio() {}
                public virtual void playSound(int soundID) = 0;
                public virtual void stopSound(int soundID) = 0;
                public virtual void stopAllSounds() = 0;
            }
            </pre>
            <p><span class="glyphicon-remove"></span>A real audio engine would be more complex than this, of course, but this shows the basic idea. What's important is that it's an abstract interface class with no implementation bound to it.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>The Service Provider</h3>
            <p><span class="glyphicon-remove"></span>By itself, our audio interface isn't very useful. We need a concrete implementation. This book isn't about how to write audio code for a game console, so you'll have to imagine there's some actual code in the bodies of these functions, but you get the idea:</p>
            <pre>
            <span class="glyphicon-remove"></span>class ConsoleAudio : public Audio {
                public virutal void playSound(int soundID) {
                    //Play sound using console audio api...
                }

                public virtual void stopSound(int soundID) {
                    //Stop sound using console audio api...
                }

                public virutal void stopAllSounds() {
                    //Stop all sounds using console audio api...
                }
            }
            </pre>
            <p><span class="glyphicon-remove"></span>Now we have an interface and an implementation. The remaining piece is the service locator - the class that ties the two together.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>A Simple Locator</h3>
            <p><span class="glyphicon-remove"></span>The implementation here is about the simplest kind of service locator you can define:</p>
            <pre>
            <span class="glyphicon-remove"></span>class Locator {
                public static Audio* getAudio() { return service_; }

                public static void provide(Audio* service) {
                    service_ = service;
                }

                private static Audio* service_;
            }
            </pre>
            <p><span class="glyphicon-remove"></span>The tenchnique this uses is called <i>dependency injections</i> and awkward bit of jargon for a very simple idea. Say you have one class that depends on another. In our case, our Locator class needs an instance of the Audio service. Normally, the locator would be responsible for constructing that instance itself. Dependency injection instead says that outside code is responsible for <i>injecting</i> that dependency into the object that needs it.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The static getAudio() function does the locating. We can call it from anywhere in the codebase, and it will give us back an instance of our Audio service to use:
            <pre>
            <span class="glyphicon-remove"></span>Audio *audio = Locator::getAudio();
            audio->playSound(VERY_LOUD_BANG);
            </pre>
            <p><span class='glyphicon-remove'></span>The way it "locates" is very simple - it relies on some outside code to register a service provider before anything tries to use the service. When the game is starting up, it calls some code like this:</p>
            <pre>
            <span class='glyphicon-remove'></span>ConsoleAudio *audio = new ConsoleAudio();
            Locator::provide(audio);
            </pre>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            They key part to notice here is that the code that calls playSound() isn't aware of the concrete <i>ConsoleAudio</i> class; it only knows the abstract Audio interface. Equally important, not even the <i>locator</i> class is coupled to the concrete service provider. The <i>only</i> place in the code that knows about the actual concrete class is the initialization code that provides the service.
            <p><span class='glyphicon-remove'></span>There's one more level of decoupling here: the <i>Audio</i> interface isn't aware of the fact that it's being accessed in most places through a service locator. As far as it knows, it's just a regular abstract base class. This is useful because it means we can apply this pattern to <i>existing</i> classes that weren't necessarily designed around it. This is in contrast with the Singleton, which affects the design of the "service" class itself.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>A Null Service</h3>
            <p><span class='glyphicon-remove'></span>Our implementation so far is certainly simple, and it's pretty flexible too. But it has one big shortcoming: if we try to use the service before a provider has been registered, it returns NULL. If the calling code doesn't check that, we're going to crash the game.</p>
            <p><span class='glyphicon-remove'></span>You'll sometimes here this called <i>"temporal coupling"</i> - two separate pieces of code that must be called in the right order for the program to work correclty. All stateful software has some degree of this, but as with other kinds of coupling, reducing temporal coupling makes the codebase easier to manage.</p>
            <p><span class='glyphicon-remove'></span>Fortunately, there's another design pattern called <i>"Null Object"</i> that we can use to address this. The basic idea is that in places where we would return NULL when we fail to find or create an object, we instead return a special object that implements the same interface as the desired object. Its implementation basically does nothing, but it allows code that receives the object to safely continue on as if it had received a "real" one.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            To use this, we'll define another "null" service provider:
            <pre>
            <span class='glyphicon-remove'></span>class NullAudio : public Audio {
            public:
                virtual void playSound(int soundID) { /* Do nothing */ }
                virtual void stopSound(int soundID) { /* Do nothing */ }
                virtual void stopAllSounds() { /* Do nothing */ }
            };
            </pre>
            <p><span class='glyphicon-remove'></span>As you can see, it implements the service interface, but doesn't actually do anything. Now, we change our locator to this:</p>
            <pre>
            <span class='glyphicon-remove'></span>class Locator {
            public:
                static void initialize() {service_ = &amp;nullService_; }

                static Audio&amp; getAudio() {return *service_; }

                static void provide(Audio* service) {
                    if(service == NULL) {
                        //Revert to null service.
                        service_ = &amp;nullService_;
                    } else {
                        service_ = serivce;
                    }
                }

            private:
                static Audio* service_;
                static NullAudio nullService_;
            }
            </pre>
            <p><span class='glyphicon-remove'></span>You may notice we're returning the service by referencing instead of by pointer now. Since references in C++ are (in theory) never NULL, returning a reference is a hint to users of the code that they can expect to always get a valid object back.</p>
            <p><span class='glyphicon-remove'></span>The other thing to notice is that we're checking for NULL in the provide() function instead of checking for the accessor. That requires us to call initialize() early on to make sure that the locator initially correctly defaults to the null provider. In return, it moves the branch out of getAudio(), which will save us a couple of cycles every time the service is accessed.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            Calling code will never know that a "real" service wasn't found, nor does it have to worry about handling NULL. It's guaranteed to always get back a valid object.
            <br>This is also useful for <i>intentionally</i> failing to find services. If we want to disable a system temporarily, we now have an easy way to do so: simply don't register a provider for the service, and the locator will default to a null pointer.
            <p><span class='glyphicon-remove'></span>Something extra to note: Turning off audio is handy during development. It frees up some memory and CPU cycles. More importantly, when you break into a debugger just as a loud sound starts playing, it saves you from having your eardrums shredded.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Logging Decorator</h3>
            <p><span class='glyphicon-remove'></span>Now that our system is pretty robust, let's discuss another refinement this patter lets us do - decorated services. We'll need to see an example.</p>
            <p><span class='glyphicon-remove'></span>During development, a little logging when interesting events occur can help you figure out what's going on under the hood of your game engine. If you're working on AI, you'd like to know when the entity changes AI states. If you're the sound programmer, you may want a record of every sound as it plays so you can check that they trigger in the right order.</p>
            <p><span class='glyphicon-remove'></span>The typical solution is to litter the code with calls to some <i>log()</i> function. Unfortunately, that replaces one problem with another - now we have <i>too much</i> logging. The AI coder doesn't care when sounds are playing, and the sound person doesn't care about AI state transitions, but now they both have to wade through each other's messages.</p>
            <p><span class='glyphicon-remove'></span>Ideally, we would be able to selectively enable logging for just the stuff we care about, and in the final game build, there's be no logging at all. If the different systems we want to conditionally log are exposed as services, then we can solve this using the Decorator pattern.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            Let's define another audio service provider implementation like this:
            <pre>
            <span class='glyphicon-remove'></span>class LoggedAudio : public Audio {
            public:
                LoggedAudio(Audio &amp;wrapped) : wrapped_(wrapped) {}

                virtual void playSound(int soundID) {
                    log("play sound");
                    wrapped_.playSound(soundID);
                }

                virtual void stopSoud(int soundID) {
                    log("stop sound");
                    wrapped_.stopSound(soundID);
                }

                virtual void stopAllSounds() {
                    log("stop all sounds");
                    wrapped_.stopAllSounds();
                }

            private:
                void log(const char* message) {
                    //Code to log message...
                }

                Audio &amp;wrapped_;
            };
            </pre>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            As you can see, it wraps another audio provider and exposes the same interface. It forwards the actual behavior to the inner provider, but it also lgs each sound call. If a programmer wants to enable audio logging, they call this:
            <pre>
            <span class='glyphicon-remove'></span>void enableAudioLoggin() {
                //Decorate the existing service.
                Audio *service = new LoggedAudio(Locator::getAudio());

                //Swap it in.
                Locator::provide(service);
            }
            </pre>
            <p><span class='glyphicon-remove'></span>Now, any calls to the audio service will be logged before continuing as before. And, of course, this plays nicely with our null service, so you can both <i>disable</i> audio and yet still log the sounds that it <i>would</i> play if sound were enabled.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class='jumbotron col-md-12 heliList' id='design-decisions'>
    <h2>Design Decisions</h2>
    <ul>
        <li><p><span class='glyphicon-remove'></span>
            We've covered a typical implementation, but there are a couple of ways that it can vary based on differing answers to a few core questions:
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>How is the Service Located?</h3>
            <p><span class='glyphicon-remove'></span>&bull; <b>Outside code registers it:</b>
            <br>This is the mechanism our sample code uses to locate the service, and it's the most common design in games:
            <br> &nbsp; &bull; <i>It's fast and simple.</i> The <i>getAudio()</i> function simply returns a pointer. It will often get inlined by the compiler, so we get a nice abstracion layer at almost no performance cost.
            <br> &nbsp; &bull; <i>We control how the provider is constructed.</i> Consider a service for accessing the game's controllers. We have two concrete providers: one for regular games and one for playing online. The online provider passes controller input over the network so that, to the rest of the game, remote players appear to be using local controllers.
            <br> &nbsp; To make this work, the online concrete provider needs to know the IP address of the other remote player. If the locator itself was constructing the object, how would it know what to pass in? The <i>Locator</i> class doesn't know anything about online at all, much less some other user's IP address.
            <br> &nbsp; Externally registered providers dodge the problem. Instead of the locator constructing the class, the games' networking code instantiates the online-specific service provider, passing in the IP address it needs. Then it give that to the locator, who knows only about the service's abstract interface.
            <br> &nbsp; &bull; <i>We can change the service while the game is running.</i> We may not use this in the final game, but it's a neat trick during development. While testing, we can swap out, for example, the audio service with the null service we talked about earlier to temporarily disable sound while the game is still running.
            <br> &nbsp; &bull; <i>The locator depends on outside code.</i> This is the downside. Any code accessing the service presumes that some code somewhere has already registered it. If that initialization doesn't happen, we'll either crash or have a service mysteriously not working.</p>
            <p><span class='glyphicon-remove'></span>&bull; <b>Blind to it at compile time:</b>
            <br>The idea here is that the "location" process actually occurs at compile time using preprocessor macros. Like so:</p>
            <pre>
            <span class='glyphicon-remove'></span>class Locator {
            public:
                static Audio&amp; getAudio() { return service_; }

            private:
                #if DEBUG
                    static DebugAudio service_;
                #else
                    static ReleaseAudio service_;
                #endif
            }
            </pre>
            <p><span class='glyphicon-remove'></span>Locating the service like this implies a few things:
            <br> &nbsp; &bull; <i>It's fast.</i> Since all fo the real work is done at compile time, there's nothing left to do at runtime. The compiler will likely inline the <i>getAudio()</i> call, giving us a solution that's as fast as we could hope for.
            <br> &nbsp; &bull; <i>You can guarantee the service is available.</i> Since the locator owns the service now and selects it at compile time, we can be assured that if the game compiles, we won't have to worry about the service being unavailable.
            <br> &nbsp; &bull; <i>You can't change the service easily.</i> This is the major downside. Since the binding happens at build time, anytime you want to change the service, you've got to recompile and restart the game.</p>
            <p><span class='glyphicon-remove'></span>&bull; <b>Configure it at runtime:</b>
            <br>Over in the khaki-clad land of enterprise business software, if you say "service locator", this is what they'll have in mind. When the service is requested, the locator does some magic at runtime to hunt down the actual implementation requested.
            <br><i>Reflection</i> is a capability of some programming languages to interact with the type system at runtime. For example, we could find a class with a given name, find its constructor, and then invoke it to create an instance.
            <br>Typically, this means loading a configuration file that identifies the provider and then using reflection to instantiate that class at runtime. This does a few things for us:
            <br> &nbsp; &bull; <i>We can swap out the service without recompiling.</i> This is a little more flexible than a compile-time-bound service, but not quite as flexible as a registered one where you can actually change the service while the game is running.
            <br> &nbsp; &bull; <i>Non-programmer can change the service.</i> This is nice for when the designers want to be able to turn certain game features on and off but aren't comfortable mucking though source code. (Or, more likely, the <i>coders</i> aren't comfortable with them mucking through it.)
            <br> &nbsp; &bull; <i>The same codebase can support multiple configurations simultaneously.</i> Since the location process has been moved out of the codebase entirely, we can use the same code to support multiple service configurations simultaneously.
            <br>&nbsp; This is one of the reasons this model is appealing over in enterprise web-land; you can deploy a single app that works on different server setups just by changing some configs. Historically, this was less useful in games since console hardware is pretty well-standardized, but as more games target a heaping hodgepodge of mobile devices, this is becoming more relevant.
            <br> &nbsp; &bull; <i>It's complex.</i> Unlike the previous solutions, this one is pretty heavyweight. You have to create some configuration system, possibly write code to load and parse a file, and generally <i>do some stuff</i> to locate the service. Time spent writing this code is time not spent on other game features.
            <br> &nbsp; &bull; <i>Locating the service takes time.</i> And now the smiles really turn to frowns. Going with runtime configuration means you're burning some CPU cycles locating the service. Caching can minimize this, but that still implies that the first time you use the service, the game's got to go off and spend some time hunting it down. Game developers <i>hate</i> burning CPU cycles on something that doesn't improve the player's game experience.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>What Happens if the Service Can't be Located?</h3>
            <p><span class='glyphicon-remove'></span> &bull; <b>Let the user handle it:</b>
            <br>The simplest solution is to pass the buck. If the locator can't find the service, it just returns NULL. This implies:
            <br> &nbsp; &bull; <i>It lets users determine how to handle failure.</i></p>
        </p></li>
    </ul>
    <a href='#title'><span class='glyphicon-menu-up'></span></a>
</div>

                    <!-------------------------------------->
                </div>
            </div>
    </main>

    <!-------------------------------------------------------------------------->

    <!-- FOOTER -->
    <footer class="navbar navbar-inverse navbar-fixed-bottom">
        <nav>
            <div class="container">
                <div class="row">
                    <div class="col-md-6 col-sm-6 col-xs-12">
                        <ul>
                            <li>&copy; 2017 <a href="http://www.gabedeyo.com">Gabe Deyo</a></li>
                            <li>|</li>
                            <li><a href="mailto:gabedeyo@gmail.com?subject=Notes">gabedeyo@gmail.com</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>
    </footer>

    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
    <script src="../../../js/selection.js" charset="utf-8"></script>
</body>

</html>
