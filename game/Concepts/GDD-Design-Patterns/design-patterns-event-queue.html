<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Design Patterns - Event Queue</title>

    <meta name="viewport" content="width=device-width,initial-scale=1.0, shrink-to-fit=no" />

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="../../../css/page.css">
</head>

<body>

    <!-- Top Navigation -->
    <header>
        <nav class="navbar navbar-inverse">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapsemenu" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a href="../../../index.html" class="navbar-brand">Personal Notes</a>
                </div>

                <div class="collapse navbar-collapse" id="collapsemenu">
                    <ul class="nav navbar-nav">

                        <!-- GAME DEVELOMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Game Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- CONCEPTS -->
                                <li><a href="../../Categories/concepts.html">Concepts <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ENGINE -->
                                <li><a href="../../Categories/engine.html">Engine <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- IMPLEMENTATIONS -->
                                <li><a href="../../Categories/implementations.html">Implementations <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- PROGRAMMING -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Programming <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- LANGUAGES -->
                                <li><a href="../../../code/Categories/languages.html">Languages <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ALGORITHMS -->
                                <li><a href="../../../code/Categories/algorithms.html">Algorithms <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PROBLEMS -->
                                <li><a href="../../../code/Categories/problems.html">Problems <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- RANDOM -->
                                <li><a href="../../../code/Categories/random.html">Random <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- GABE DEVELOPMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Gabe Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- FITNESS PAGE -->
                                <li><a href="../../../gabe/Categories/fitness.html">Fitness <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- STYLE & GROOMING PAGE -->
                                <li><a href="../../../gabe/Categories/style.html">Style <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- FINANCE PAGE -->
                                <li><a href="../../../gabe/Categories/finance.html">Finance <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PHILOSOPHY PAGE -->
                                <li><a href="../../../gabe/Categories/philosophy.html">Philosophy <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                    </ul>
                </div>

            </div>
        </nav>
    </header>

    <!-------------------------------------------------------------------------->

    <!-- MAIN -->
    <main>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h1 id="title">Design Patterns - Event Queue</h1>

                    <aside>
                        <button type="button" class="btn btn-default" name="button" id="selectAll">Select All</button>
                        <button type="button" class="btn btn-default" name="button" id="clearAll">Clear All</button>
                    </aside>

                    <div class="jumbotron heliList">
                        <h2>Index</h2>
                        <ul>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#intent">Intent</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#motivation">Motivation</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#event-queue">Event Queue</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#when-to-use">When to Use It</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#keep-in-mind">Keep In Mind</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#sample-code">Sample Code</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#design-decisions">Design Decisions</a>
                                </p>
                            </li>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#see-also">See Also</a>
                                </p>
                            </li>
                        </ul>
                    </div>

<div class="jumbotron col-md-12 heliList" id="intent">
    <h2>Intent</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            <i>Decouple when a message or event is sent from when it is processed.</i>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="motivation">
    <h2>Motivation</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Unless you've been under a rock for the past few years, you've probably already heard of an "event queue". If not, maybe "message queue", or "event loop", or "message pump" rings a bell. To refresh your memory, let's walk through a couple of common manifestations of the pattern.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>GUI Event Loops</h3>
            <p>If you've ever done any user interface programming, then you're well acquanted with <i>events</i>. Every time the user interacts with your program - clicks a button, pulls down a menu, or presses a key - the operating system generates an event. It throws this object at your app, and your job is to grab it and hook it up to some interesting behavior.</p>
            <p><span class="glyphicon-remove"></span>In order to receive these missives, somewhere deep in the bowels of your code is an event loop. It looks roughly like this:</p>
            <pre>
            <span class="glyphicon-remove"></span>while(running){
                Event event = getNextEvent();
                // Handle event...
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The call to getNextEvent() pulls a bit of unprocessed user input inot your app. You route it to an event handler and, like magic, your application comes to life. The interesting part is that the application <i>pulls</i> in the eevent when <i>it</i> wants it. The operating system doesn't just immediately jump to some code in your pap when the user pokes a peripheral.
            <p><span class="glyphicon-remove"></span>That means when user input comes in, it needs to go somewhere so that the operating system doesn't lose it between when the device driver reported the input and when your app gets around to calling getNextEvent(). That "somewhere" is a <i>queue</i>. When user input comes in, the OS adds it to a queue of unprocessed events. When you call getNextEvent(), that pulls the oldest event off the queue and hands it to your application.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Central Event Bus</h3>
            <p><span class="glyphicon-remove"></span>Most games aren't event-driven like this, but it is common for a game to have its own event queue as the backbone of its nervous system. You'll often hear "central", "global", or "main" used to describe it. It's used for high level communication between game systems that want to stay decoupled.</p>
            <p><span class="glyphicon-remove"></span>Say your game has a tutorial system to display help boxes after specific in-game events. For example, the first time the player vanquishes a foul beast, you want to show a little balloon that says, "Press X to grab the loot!"</p>
            <p><span class="glyphicon-remove"></span>Your gameplay and combat code are likely complex enough as it is. The last thing you want to do is stuff a bunch of checks for triggering tutorials in there. Instead, you could have a central event queue. Any game system can send to it, so the combat code can add an "enemy died" event every time you slay a foe.</p>
            <p><span class="glyphicon-remove"></span>Likewise, any game system can <i>receive</i> events from the queue. The tutorial engine registers itself with the queue and indicates it wants to receive "enemy dies" events. This way, knowledge of an enemy dying makes its way from the combat system over to the tutorial engine without the two being directly aware of each other.</p>
            <p><span class="glyphicon-remove"></span>I thought about using this as the example for the rest of the chapter, but I'm not generally a fan of big global systems. Event queues don't have to be for communicating across the entire game engine. They can be just as useful within a single class or domain.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Say What?</h3>
            <p><span class="glyphicon-remove"></span>So, instead, let's add sound to our game. Humans are mainly visual animals, but hearing is deeply connected to our emotions and our sense of physical space. The right simulated echo can make a black screen feel like an enormous cavern, and a well-timed violin adagio can make your heartstrings hum in sympathetic resonance.</p>
            <p><span class="glyphicon-remove"></span>To ger our game wound for sound, we'll start with the simplest possible approach and see how it goes. We'll add a little "audio engine" that has an API for playing a sound given an identifier and a volume:</p>
            <pre>
            <span class="glyphicon-remove"></span>class Audio {
                public static void playSound(SoundId id, int volume);
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            It's responsible for loading the appropriate sound resource, finding an available channel to play it on, and starting it up. This chapter isnt' about some platform's real audio API, so I'll conjure one up that we can presume is implemented elsewhere. Using it, we write our method like so:
            <pre>
            <span class="glyphicon-remove"></span>void Audio::playSound(SoundId id, int volume) {
                ResourceId resource = loadSound(id);
                int channel = findOpenChannel();
                if(channel == -1) return;
                startSound(resource, channel, volume);
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We check that in, create a few sound files, and start sprinkling playSound() calls through our codebase like some magical audio fairy. For example, in our UI code, we play a little bloop when the selected menu item changes:
            <pre>
            <span class="glyphicon-remove"></span>class Menu {
                public void onSelect(int index) {
                    Audio::playSound(SOUND_BLOOP, VOL_MAX);
                    //Other stuff...
                }
            }
            </pre>
            <p><span class="glyphicon-remove"></span>After doing this, we notice that sometimes when you switch menu items, the whole screen freezes for a few frames. We've hit our first issue.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Problem 1</h3>
            <p><span class="glyphicon-remove"></span><b>The APi blocks the caller until the audio engine has completely processed the request.</b> Our playSound() method is synchronous - it doesn't return back to the caller until bloops are coming out of the speakers. If a sound file has to be loaded from disc first, that may take a while. In the meantime, the rest of the game is frozen.</p>
            <p><span class="glyphicon-remove"></span>Ignoring that for now, we move on. In the AI code, we add a call to let out a wail of anguish when an enemy takes damage form the player. Nothing warms a gamer's heart like inflicting simulated pain on a virtual living being.</p>
            <p><span class="glyphicon-remove"></span>It works, but sometimes when the hero does a mighty attack, it hits two enemies in the exact same frame. That causes the game to play the wail sound twice simultaneously. If you know anything about audio, you know mixing multiple sounds together sums their waveforms. When those are the <i>same</i> waveform, it's the same as <i>one</i> sound played <i>twice as loud</i>. Jarringly loud.</p>
            <p><span class="glyphicon-remove"></span>We have a related problem in boxx fights when piles of minions are running around causing mayhem. The hardware can only play so many sounds at one time. When we go over that limit, sound gets ignored or cut off.</p>
            <p><span class="glyphicon-remove"></span>To handle these issues, we need to look at the entire set of sound calls to aggregate and prioritize them. Unfortunately, our audio API handles each playSound() call independently. It sees requests through a pinhole, one at a time.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Problem 2</h3>
            <p><span class="glyphicon-remove"></span><b>Requests cannot be processed in aggregate.</b> These problems seem like mere annoyances compared to the next issue that falls in our lap. by now, we've strewn playSound() calls throughout the codebase in lots of different game systems. But our game engine is running on modern multi-core hardware. To take advantage of those cores, we distribute those systems on different threads - rendering on one, AI on another, etc.</p>
            <p><span class="glyphicon-remove"></span>Since API is synchronous, it runs on the <i>caller's</i> thread. When we call it from different game systems, we're hitting our API concurrently from multiple threads. Look at that sample code. See any thread synchronization? Me neither.</p>
            <p><span class="glyphicon-remove"></span>This is particularly egregious because we intend to have a <i>separate</i> thread for audio. It's just sitting there totally idle while these other threads are busy stepping all over each other and breaking things.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Problem 3</h3>
            <p><span class="glyphicon-remove"></span><b>Requests are processed on the wrong thread.</b> The common theme to these problems is that the audio engine interprets a call to playSound() to mean, "Drop everything and play the sound right now!" <i>Immediacy</i> is the problem. Other game systems call play at <i>their</i> convenience, but not necessarily when it's conventient for the audio engine to handle that request. To fix that, we'll decouple <i>receiving</i> a request from <i>processing</i> it.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="event-queue">
    <h2>Event Queue</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            A <b>queue</b> stores a series of <b>notifications or requests</b> in first-in, first-out order. Sending a notification <b>enqueues the request and returns.</b> The request processor then <b>processes items from the queue</b> at a later time. Requests can be <b>handled directly</b> or <b>routed to interested parties.</b> This <b>decouples the sender from the receiver</b> both <b>statically</b> and <b>in time.</b>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="when-to-use">
    <h2>When to Use It</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            If you only want to decouple <i>who</i> receives a message from its sender, patterns like Observer and command will take care of this with less complexity. You only need a queue when you want to decouple something <i>in time.</i>
            <p><span class="glyphicon-remove"></span>I think of it in terms of pushing and pulling. You have some code A that wants another chunk B to do some work. The natural way for A to initiate that is by <i>pushing</i> the request to B.</p>
            <p><span class="glyphicon-remove"></span>Meanwhile, the natural way for B to process that request is by <i>pulling</i> it in at a convenient time in its run cycle. When you have a push model on one end and a pull model on the other, you need a buffer between them. That's what a queue provides that simpler decoupling patterns don't.</p>
            <p><span class="glyphicon-remove"></span>Queues give control to the code that pulls from it - the receiver can delay processing, aggregate requests, or discard them entirely. But queues do this by taking control <i>away</i> from the sender. All the sender can do is throw a request on the queue and hope for the best. This makes queues a poor fit when the sender needs a response.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="keep-in-mind">
    <h2>Keep In Mind</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Unlike some more modest patterns in this book, event queues are complex and tend to have a wide-reaching effect on the architecture of our games. That means you'll want to think hard about how - or if - you use one.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>A Central Event Queue is a Global Variable</h3>
            <p><span class="glyphicon-remove"></span>One common use of this pattern is for a sort of Grand Central Station that all parts of the game can route messages through. It's a powerful piece of infrastructure, but <i>powerful</i> doesn't always mean <i>good</i>.</p>
            <p><span class="glyphicon-remove"></span>It took a while, but most of us learned the hard way that global variables are bad. When you have a piece of state that any part of the program can poke at, all sorts of subtle interdependencies creep in. This pattern wraps that state in a nice little protocol, but it's still a global, with all of the danger that entails.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>The State of the World can Change Under You</h3>
            <p><span class="glyphicon-remove"></span>Say some AI code posts an "entity died" event to a queue when a virtual minion shuffles off its mortal coil. That event hangs out in the queue for who knows how many frames until it eventually works its way to the front and gets processed.</p>
            <p><span class="glyphicon-remove"></span>Meanwhile, the experience system wants to track the heroin's body count and reward her for her grisly efficiency. It receives each "entity dies" event and determines the kind of entity slain and the difficulty of the kill so it can dish out an appropriate reward.</p>
            <p><span class="glyphicon-remove"></span>That requires various pieces of state in the world. We need the entity that died so we can see how tough it was. We may want to inspect its surroundings to see what other obstacles or minions were nearby. but if the event isn't received until later, that stuff may be gone. The entity may have been dealloacted, and other nearby foes may have wandered off.</p>
            <p><span class="glyphicon-remove"></span>When you receive an event, you have to be careful not to assume the <i>current</i> state of the world reflects how the world was <i>when the event was raised.</i> This means queued events tend to be more data heavy than events in synchronous systems. With the latter, the notification can say "something happened" and the receiver can look around for the details. With a queue, those ephemeral details must be captured when the event is sent so they can be used later.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>You can get Stuck in Feedback Loops</h3>
            <p><span class="glyphicon-remove"></span>All event and message systems have to worry about cycles:</p>
            <p><span class="glyphicon-remove"></span> &nbsp; 1. <b>A</b> sends an event</p>
            <p><span class="glyphicon-remove"></span> &nbsp; 2. <b>B</b> receives it and responds by sending an event.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; 3. That event happens to be one that <b>A</b> cares about, so it receives it. In response, it sends an event...</p>
            <p><span class="glyphicon-remove"></span> &nbsp; 4. Go to 2.</p>
            <p><span class="glyphicon-remove"></span>When your messaging system is <i>synchronous</i>, you find cycles quickly - they overflow the stack and crash your game. With a queue, the asynchrony unwinds the stack, so the game may keep running even though spurious events are sloshing back and forth in there. A common rule to avoid this is to avoid <i>sending</i> events from within code that's <i>handling</i> one.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="sample-code">
    <h2>Sample Code</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            We've already seen some code. It's no perfect, but it has the right basic functionality - the public API we want and the right low-level audio calls. All that's left for us to do now is  fix its problem.
            <p><span class="glyphicon-remove"></span>The first is that our API <i>blocks</i>. When a piece of code plays a sound, it can't do anything else until playSound() finishes loading the resources and actually starts making the speaker wiggle.</p>
            <p><span class="glyphicon-remove"></span>We want to defer that work until later so that playSound() can return quickly. To do that, we need to <i>reify</i> the request to play a sound. We need a little structure that stores the detail of a pending request so we can keep it around until later:</p>
            <pre>
            <span class="glyphicon-remove"></span>struct PlayMessage {
                SoundId id;
                int volume;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Next, we need to give Audio some storage space to keep track of these pending play messages. Now, your algorithms professor might tell you to use some exciting data structure here like a Fibonacci heap or a skip list, or , hell, at least a <i>linked list</i>. But in practice, the best way to store a bunch of homogeneous things is almost always a plain old array:
            <br> &nbsp; &bull; No dynamic allocation.
            <br> &nbsp; &bull; No memory overhead for bookkeeping information or pointers.
            <br> &nbsp; &bull; Cache-friendly contiguous memory usage.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            So let's do that:
            <pre>
            <span class="glyphicon-remove"></span>class Audio {
                public static void init() {
                    numPending_ = 0;
                }

                //Other stuff...

                private static const int MAX_PENDING = 16;
                private static PlayMessage pending_[MAX_PENDING];
                private static int numPending_;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We can tune the array size to cover our worst case. To play a sound, we simply slot a new message in there at the end:
            <pre>
            <span class="glyphicon-remove"></span>void Audio::playSound(SoundId id, int volume) {
                assert(numPending_ < MAX_PENDING);

                pending_[numPending_].id = id;
                pending_[numPending_].volume = volume;
                numPending_++;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            This lets playSound() return almost instantly, but we do still have to play the sound, of course. that code needs to go somewhere, and that somewhere is an update() method:
            <pre>
            <span class="glyphicon-remove"></span>class Audio {
                public static void update() {
                    for(int i = 0; i < numPending_; i++) {
                        ResourceId resource = loadSound(pending_[i].id);
                        int channel = findOpenChannel();
                        if(channel == -1) return;
                        startSound(resource, channel, pending_[i].volume);
                    }

                    numPending_ = 0;
                }

                //Other stuff...
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Now, we need to call that from somewhere convenient. What "convenient" means depends on your game. It may mean calling it from the main game loop or from a dedicated audio thread.
            <p><span class="glyphicon-remove"></span>This workds fine, but it does presume we can process <i>every</i> sound request in a single call to update(). If you're doing something like processing a request asynchronously after its sound resource is loaded, that won't work. For update() to work on one request at a time, it needs to be able to pull requests out of the buffer while leaving the rest. In other words, we need an actual queue.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>A Ring Buffer</h3>
            <p><span class="glyphicon-remove"></span>There are a bunch of ways to implement queues, but my favorite is called a <i>ring buffer</i>. It preserves everything that's great about arrays while letting us incrementally remove items from the front of the queue.</p>
            <p><span class="glyphicon-remove"></span>Now, I know what you're thinking. If we remove items from the beginning of the array, don't we have to shift all of the remaining items over? Isn't that slow?</p>
            <p><span class="glyphicon-remove"></span>This is why they made us learn linked lists - you can remove nodes from them without having to shift things around. Well, it turns out you can implement a queue without shifting in an array too. I'll walk you through it, but first let's get precise on some terms:</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; The <b>head</b> of the queue is where requests are <i>read</i> from. The head is the oldest pending request.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; &bull; The <b>tail</b> is the other end. It's the slot in the array where the next enqueued request will be <i>written</i>. Note that it's just <i>past</i> the end of the queue. You think of it as a half-open range, if that helps.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Since playSound() appends new requests atht the end of the array, the head starts at element zero and the tail grows to the right. Let's code that up. First, we'll tweak our fields a bit to make these two markers explicity in the class:
            <pre>
            <span class="glyphicon-remove"></span>class Audio {
                public static void init() {
                    head_ = 0;
                    tail_ = 0;
                }

                private static int head_;
                private static int tail_;
                //Array
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In the implementation of playSound(), numPending_ has been replaced with tail_, but otherwise it's the same:
            <pre>
            <span class="glyphicon-remove"></span>void Audio::playSound(SoundId id, int volume) {
                assert(tail_ < MAX_PENDING);

                // Add to the end of the list
                pending_[tail_].id = id;
                pending_[tail_].volume = volume;
                tail_++;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The more interesting change is in update():
            <pre>
            <span class="glyphicon-remove"></span>void Audio::update() {
                //If there are no pending requests, do nothing.
                if(head_ == tail_) return;

                ResourceId resource = loadSound(pending_[head_].id);
                int channel = findOpenChannel();
                if(channel == -1) return;
                startSound(resource, channel, pending_[head_].volume);
                head_++;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We process the request at the head and then discard it by advancing the head pointer to the right. We detect an empty queue by seeing if there's any distance between the head and tail.
            <p><span class="glyphicon-remove"></span>Now we've got a queue - we can add to the end and remove from the front. There's an obvious problem, though. As we run requests through the queue, the head and tail keep crawling to the right. Evenutally, tail_ hits the end of the array, and party time is over. This is where it gets clever.</p>
            <p><span class="glyphicon-remove"></span>Notice that while the tail is creeping forward, the <i>head</i> is too. That means we've got array elements at the <i>beginning</i> of the array that aren't being used anymore. So what we do is wrap the tail back around the beginning of the array when it runs off the end. That's why it's called a <i>ring</i> buffer - it acts like a circular array of cells.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Implementing this is remarkably easy. When we enqueue an item, we just need to make sure the tail wraps around to the beginning of the array when it reaches the end:
            <pre>
            <span class="glyphicon-remove"></span>void Audio::playSound(SoundId, int volume) {
                assert((tail_ + 1) % MAX_PENDING != head_);

                //Add to the end of the list
                pending_[tail_].id = id;
                pending_[tial_].volume = volume;
                tail_ = (tail_ + 1) % MAX_PENDING;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Replacing tail_++ with an increment modulo the array size wraps the tail back around. The other change is the assertion. We need to ensure the queue doesn't overflow. As long as there are fewer than MAX_PENDING requests in the queue, there will be a little gap of unused cells between the head and the tail. If the queue fills up, those will be gone and, like some weird backwards Ouroboros, the tail will collide with the head and start overwriting it. The assertion ensures this doesn't happen.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            In update(), we wrap the head around too:
            <pre>
            <span class="glyphicon-remove"></span>void Audio::update() {
                //If there are no pending requests, do nothing.
                if(head_ == tail_) return;

                ResourceId resource = loadSound(pending_[head_].id);
                int channel = findOpenChannel();
                if(channel == -1) return;
                startSound(resources, channel, pending_[head_].volume);

                head_ = (head_ + 1) % MAX_PENDING;
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Aggregating Requests</h3>
            <p><span class="glyphicon-remove"></span>Now that we've got a queue in place, we can move onto the other problems. The first is that multiple requests to play the same sound end up too loud. Since we know which requests are waiting to be processed now, all we need to do is merge a request if it matches an already pending one:</p>
            <pre>
            <span class="glyphicon-remove"></span>void Audio::playSound(SoundId id, int volume) {
                //Walk through pending requests
                for(int i = head_; i != tail_; i = (i + 1) % MAX_PENDING) {
                    if(pending_[i].id == id) {
                        //Use the larger of the two volumes.
                        pending_[i].volume = max(volume, pending_[i].volume);

                        //Don't need to enqueue.
                        return;
                    }
                }
                //Previous Code...
            }
            </pre>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            When we get two requests to play the same sound, we collapse them to a single request for whichever is loudest. This "aggregation" is pretty rudimentary, but we could use the same idea to do more interesting batching.
            <p><span class="glyphicon-remove"></span>Note that we're merging when the request is <i>enqueued</i>, not when it's <i>processed</i>. That's easier on our queue since we don't waste slots on redundant requests that will end up being collapsed later. It's also simpler to implement.</p>
            <p><span class="glyphicon-remove"></span>It does, however, put the processing burden on the caller. A call to playSound() will walk the entire queue before it returns, which could be slow if the queue is large. It may make more sense to aggregate in update() instead.</p>
            <p><span class="glyphicon-remove"></span>There's something important to keep in mind here. The window of "simultaneous" requests that we can aggregate is only as big as the queue. If we process requests more quickly and the queue size stays small, then we'll have fewer opportunities to batch things together. Likewise, if processing lags behind and the queue gets full, we'll find more things to collapse.</p>
            <p><span class="glyphicon-remove"></span>This pattern insulates the requester from knowing when the request gets processed, but when you treat the entire queue as a live data structure to be played with, then lag between making a request and processing it can visibly affect behavior. Make sure you're okay with that before doing this.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Spanning Threads</h3>
            <p><span class="glyphicon-remove"></span>Finally, the most pernicious problem. With our synchronous audio API, whatever thread called playSound() was the thread that processed the request. That's often not what we want.</p>
            <p><span class="glyphicon-remove"></span>On today's multi-core hardware, you need more than one thread if you want to get the most out of your chip. There are infinite ways to distribute code across threads, but a common strategy is to move each domain of the game onto its own thread - audio, rendering, AI, etc.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            We're in good shape to do that now that we have three critical pieces:
            <br>&nbsp; &bull; The code for requesting a sound is decoupled from the code that plays it.
            <br>&nbsp; &bull; We have a queue for marshalling between the two.
            <br>&nbsp; &bull; The queue is encapsulated from the rest of the game.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            All that's left is to make the methods that modfiy the queue - playSound() and update() - thread-safe. Normally, I'd whip up some concrete code to do that, but since this is a book about architecture, I don't want to get mired in the details of any specific API or locking mechanism.
            <p><span class="glyphicon-remove"></span>At a high level, all we need to do is ensure that the queue isn't modified concurrently. Since playSound() does a very small amount of work - basically just assigning a few fields - it can lock without blocking processing for long. In update(), we wait on something like a condition variable so that we don't burn CPU cycles until there's a request to process.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="design-decisions">
    <h2>Design Decisions</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Many games use event queues as a key part of their communication structure, and you can spend a ton of time designing all sorts of complex routing and filtering for messages. But before you go off and build something like the Los Angeles telephone switchboard, I encourage you to start simple. Here's a few start questions to consider.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>What goes in the queue?</h3>
            <p><span class="glyphicon-remove"></span>I've used "event" and "message" interchangeably so far because it mostly does'nt matter. You get the same decoupling and aggregation abilities regardless of what you're stuffing int the queue, but there are some conceptual differences.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>If you queue events:</b>
            <br> &nbsp; An "event" or "notification" describes something that <i>already</i> happened, like "monster died". You queue it so that other objects can <i>respond</i> to the even, sort of like an asynchronous Observer pattern.
            <br> &nbsp; &nbsp; &bull; <i>You are likely to allow multiple listeners.</i> Since the queue contains things that already happened, the sender probably doesn't care who receives it. From its perspective, the event is in the past and already forgotten.
            <br> &nbsp; &nbsp; &bull; <i>The scope of the queue tends to be broader.</i> Event queues are often used to <i>broadcast</i> events to any and all interested parties. To allow maximum flexibility for which parties can be interested, these queues tend to be more globally visible.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>If you queue messages:</b>
            <br> &nbsp; A "message" or "request" describes an action that we <i>want</i> to happen <i>in the future</i>, like "play sound". You can think of this as an asynchronous API to a service.
            <br> &nbsp; &nbsp; &bull; <i>You are more likely to have a single listener.</i> In the example, the queued messages are requests specifically for the <i>audio API</i> to play a sound. If other random parts of the game engine started stealing messages off the queue, it wouldn't do much good.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Who can read from the queue?</h3>
            <p><span class="glyphicon-remove"></span>In our example, the queue is encapsulated and only the Audio class can read from it. In a user interface's event system, you can register listeners to your heart's content. You sometimes hear the terms "single-cast" and "broadcast" to distinguish these, and both styles are useful.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>A single-cast queue:</b>
            <br> &nbsp; This is the natural fit when a queue is part of a class's API. Like in our audio example, from the caller's perspective, they just see a playSound() method they can call.
            <br> &nbsp; &nbsp; &bull; <i>The queue becomes an implementation detail fo the reader.</i> All the sender knows is that it sent a message.
            <br> &nbsp; &nbsp; &bull; <i>The queue is more encapsulated.</i> All other things being equal, more encapsulation is usually better.
            <br> &nbsp; &nbsp; &bull; <i>You don't have to worry about contention between listeners.</i> With multiple listeners, you have to decide if they all get every item (broadcast) or if <i>each</i> item in the queue is parceled out to <i>one</i> listener.
            <br>In either case, the listener may end up doing redundant work or interfering with each other, and you have to think carefully about the behavior you want. With a single listener, that complexity disappears.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>A broadcast queue:</b>
            <br> &nbsp; This is how most "event" systems work. If you have ten listeners when an event comes in, all ten of them see the event.
            <br> &nbsp; &nbsp; &bull; <i>Events can get dropped on the floor.</i> A corollary to the previous point is that if you have <i>zero</i> listeners, all zero of them see the event. In most broadcast systems, if there are no listeners at the point in time that an event is processed, the event gets discarded.
            <br> &nbsp; &nbsp; &bull; <i>You may need to filter events.</i> Broadcast queues are often widely visible to much of the program, and you can end up with a bunch of listeners. Multiply lots of events times lots of listeners, and you end up with a ton of event handlers to invoke.
            <br>&nbsp; To cut that down to size, most broadcast event systems let a listener winnow down the set events they receive. For example, they may say they only want to receive mouse events or events within a certain region of the UI.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>A work queue:</b>
            <br> &nbsp; Like a broadcast queue, here you have multiple listeners too. The difference is that each item in the queue only goes to <i>one</i> of them. This is a common pattern for parceling out jobs to a pool of concurrently running threads.
            <br> &nbsp; &nbsp; &bull; <i>You have to schedule.</i> Since an item only goes to one listener, the queue needs logic to figure out the best one to choose. This may be as simple as round robin or random choice, or it coule be some more complex prioritizing system.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>Who can write to the queue?</h3>
            <p><span class="glyphicon-remove"></span>This is the flip side of the previous design choice. This pattern works with all of the possible read/write configurations: one-to-one, one-to-many, many-to-one, or many-to-many.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>With one writer:</b>
            <br> &nbsp; This style is most similar to the syncronous Observer pattern. You have one privileged object that generates events that other can then receive.
            <br> &nbsp; &nbsp; &bull; <i>You implicity know where the event is coming from.</i> Since there's only one object that can add to the queue, any listener can safely assume that's the sender.
            <br> &nbsp; &nbsp; &bull; <i>You usually allow multiple readers.</i> You can have a one-sender-one-receiver queue, but that starts to feel less like the communication system this pattern is about and more like a vanilla queue data structure.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>With multiple writers:</b>
            <br> &nbsp; This is how our audio engine example works. Since playSound() is a public method, any part of the codebase can add a request to the queue. "Global" or "central" event busses work like this too.
            <br> &nbsp; &nbsp; &bull; <i>You have to be more careful of cycles.</i> Since anything can potentially put something onto the queue, it's easier to accidentally enqueue something in the middle of handling an event. If you aren't careful, that may trigger a feedback loop.
            <br> &nbsp; &nbsp; &bull; <i>You'lll likely want some reference to the sender in the event itself.</i> When a listener gets an event, it doesn't know who sent it, since it could be anyone. If that's something they need to know, you'll want to pack that into the event object so that the listener can use it.</p>
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            <h3>What is the lifetime of the objects in the queue?</h3>
            <p><span class="glyphicon-remove"></span>With a syncronous notification, execution doesn't return to the sender until all of the receivers have finished processing the message. That means the message itself can safely live in a local variable on the stack. With a queue, the message outlives the call that enqueues it.</p>
            <p><span class="glyphicon-remove"></span>If you're using a garbage collected language, you don't need to worry about this too much. Stuff the message in the queue, and it will stick around in memory as long as it's needed. In C or C++, it's up to you to ensure the object lives long enough.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>Pass ownership:</b>
            <br> &nbsp; This is the traditional way to do things when managing memory manually. When a message gets queued, the queue claims it and the sender no longer owns it. When it gets processed, the receiver takes ownership and is responsible for deallocating it.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>Share ownership:</b>
            <br> &nbsp; These days, now that even C++ programmers are more comfortable with garbage collection, shared ownership is more acceptable. With this, the message sticks around as long as anything has a reference to it and is automatically freed when forgotten.</p>
            <p><span class="glyphicon-remove"></span> &nbsp; <b>The queue owns it:</b>
            <br> &nbsp; Another option is to have messages <i>always</i> live on the queue. Instead of allocating the message itself, the sener requests a "fresh" one from the queue. The queue returns a reference to a message already in memory inside the queue, and the sender fills it in. When the message gets processed, the receiver refers to the same message in the queue.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class="jumbotron col-md-12 heliList" id="see-also">
    <h2>See Also</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            It's already been mentioned a few times here, but in many ways, this pattern is the asynchronous cousin to the well known <a href="design-patterns-observer.html">Observer</a> pattern.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            Like many patterns, event queues go by a number of aliases. One established term is "message queue". It's usually referring to a higher-level manifestation. Where our event queues are <i>within</i> an application, message queues are usually used for communicating <i>between</i> them.
            <br>Another term is "publish/subscribe", sometimes abbreviated to "pubsub". Like "message queue", it usually refers to larger distributed systems unlike the humble coding pattern we're focused on.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            A finite state machine requires a stream of inputs. If you want it to respond to those asynchronously, it makes sense to queue them.
            <br>When you have a bunch of state machines sending messages to each other, each with a little queue of pending inputs (called a <i>mailbox</i>), then you've re-invented the actor model of computation.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            The Go programming language's built-in- "channel" type is essentially an event or message queue.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

                    <!-------------------------------------->
                </div>
            </div>
    </main>


    <!-------------------------------------------------------------------------->

    <!-- FOOTER -->
    <footer class="navbar navbar-inverse navbar-fixed-bottom">
        <nav>
            <div class="container">
                <div class="row">
                    <div class="col-md-6 col-sm-6 col-xs-12">
                        <ul>
                            <li>&copy; 2017 <a href="http://www.gabedeyo.com">Gabe Deyo</a></li>
                            <li>|</li>
                            <li><a href="mailto:gabedeyo@gmail.com?subject=Notes">gabedeyo@gmail.com</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>
    </footer>

    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
    <script src="../../../js/selection.js" charset="utf-8"></script>
</body>

</html>
