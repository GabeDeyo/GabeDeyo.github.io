<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>C++ - Functions</title>

    <meta name="viewport" content="width=device-width,initial-scale=1.0, shrink-to-fit=no" />

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="../../../css/page.css">
</head>

<body>

    <!-- Top Navigation -->
    <header>
        <nav class="navbar navbar-inverse">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapsemenu" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a href="../../../index.html" class="navbar-brand">Personal Notes</a>
                </div>

                <div class="collapse navbar-collapse" id="collapsemenu">
                    <ul class="nav navbar-nav">

                        <!-- GAME DEVELOMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Game Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- CONCEPTS -->
                                <li><a href="../../../game/Categories/concepts.html">Concepts <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ENGINE -->
                                <li><a href="../../../game/Categories/engine.html">Engine <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- IMPLEMENTATIONS -->
                                <li><a href="../../../game/Categories/implementations.html">Implementations <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>
                        
                        <!-- PROGRAMMING -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Programming <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- LANGUAGES -->
                                <li><a href="../../Categories/languages.html">Languages <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ALGORITHMS -->
                                <li><a href="../../Categories/algorithms.html">Algorithms <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PROBLEMS -->
                                <li><a href="../../Categories/problems.html">Problems <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- RANDOM -->
                                <li><a href="../../Categories/random.html">Random <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- GABE DEVELOPMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Gabe Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- FITNESS PAGE -->
                                <li><a href="../../../gabe/Categories/fitness.html">Fitness <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- STYLE & GROOMING PAGE -->
                                <li><a href="../../../gabe/Categories/style.html">Style <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- FINANCE PAGE -->
                                <li><a href="../../../gabe/Categories/finance.html">Finance <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PHILOSOPHY PAGE -->
                                <li><a href="../../../gabe/Categories/philosophy.html">Philosophy <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                    </ul>
                </div>

            </div>
        </nav>
    </header>

    <!-------------------------------------------------------------------------->

    <!-- MAIN -->
    <main>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h1 id="title">C++ - Functions</h1>

                    <aside>
                        <button type="button" class="btn btn-default" name="button" id="selectAll">Select All</button>
                        <button type="button" class="btn btn-default" name="button" id="clearAll">Clear All</button>
                    </aside>

                    <div class="jumbotron heliList">
                        <h2>Index</h2>
                        <ul>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#0">Overview</a>
                                </p>
                            </li>
                            <li><p><span class='glyphicon-remove'></span>
                                <a href='#1'>Defining a Function</a>
                                </p>
                            </li>
                            <li><p><span class='glyphicon-remove'></span>
                                <a href='#2'>Passing Values</a>
                                </p>
                            </li>
                            <li><p><span class='glyphicon-remove'></span>
                                <a href='#3'>Automatic and Static Variables</a>
                                </p>
                            </li>
                            <li><p><span class='glyphicon-remove'></span>
                                <a href='#4'>Returning Variables</a>
                                </p>
                            </li>
                            <li><p><span class='glyphicon-remove'></span>
                                <a href='#5'>Function Pointers</a>
                                </p>
                            </li>
                            <li><p><span class='glyphicon-remove'></span>
                                <a href='#6'>Overloading Functions</a>
                                </p>
                            </li>
                            <li><p><span class='glyphicon-remove'></span>
                                <a href='#7'>Operator Overloading</a>
                                </p>
                            </li>
                            <li><p><span class='glyphicon-remove'></span>
                                <a href='#8'>Defining a Variable Number of Arguments</a>
                                </p>
                            </li>
                            <li><p><span class='glyphicon-remove'></span>
                                <a href='#9'>Recursion</a>
                                </p>
                            </li>
                        </ul>
                    </div>

<div class="jumbotron col-md-12 heliList" id="0">
    <h2>Overview</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            &bull; All code in a C++ program happens in functions starting with the main function.
            <br>&bull; Functions are analogous to procedures, or subroutines in other programming languages.
            <br>&bull; Functions allow you to generalize and marginalize your code by creating containers for logical subsets of code and by allowing code reuse.
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            &bull; Function arguments are passed in to functions <b>by value</b>, so when you call a function and pass it a variable, a copy of the variable is passed to the function. 
            <br>&bull; If the function then changes the value, the caller's copy <b>remains unchanged</b>. 
        </p></li>
        <li><p><span class="glyphicon-remove"></span>
            &bull; The alternative to Call-by-Value is <b>Call-by-Reference</b>.
            <br>&bull; These must be called explicitly: <pre><span class='glyphicon-remove'></span>foo(&var);</pre>
            <br>&bull; This will pass a pointer to the passed in variable instead of a value of that variable.
            <br>&bull; Then using a <i>pointer with that variable</i> in the function will allow you to access and manipulate the variable.
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            &bull; <b>Function Signature</b> is a combination of function name, return type, and types of function arguments.
            <br>&bull; Function Signature is used by the rest of the code to <i>identify the function</i>.
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class='jumbotron col-md-12 heliList' id='1'>
    <h2>Defining a Function</h2>
    <ul>
        <li><p><span class='glyphicon-remove'></span>
            &bull; A function is declared with a <b>return type</b> first, followed by the <b>function name</b>, with <b>parenthesis</b> containing the function <b>parameters</b>.
            <br>&bull; After the parenthesis is curly brackets containing the body of the function.
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            &bull; Main is never called directly, it's called by the system at entry.
            <br>&bull; Every other function must be called in order to be used.
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            &bull; A function must be declared before it's called. This is why the function must be called before the main function.
            <br>&bull; In C++ everything must be declared before it's used.
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            &bull; A common workaround is to declare your function above the main, but keep the function below. This is <b>forward declaration.</b>
            <br>&bull; Example:
            <pre>
            <span class='glyphicon-remove'></span>void func();

            int main() {
                printf("this is main()");
                func();
                return 0;
            }

            void func() {
                printf("this is func()");
            }
            </pre>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            &bull; Doing the forward declaration in the cpp file is <b>NOT</b> the common way of facing that problems however.
            <br>&bull; The correct common way to do this is with a <b>Header File</b> which contains the forward declaration separately.
            <br>&bull; Example:
            <pre>
            <span class='glyphicon-remove'></span>//Main
            #include "func.h"

            int main() {
                printf("main");
                func();
                return 0;
            }

            void func() {
                printf("func");
            }
            </pre>
            <pre>
            <span class='glyphicon-remove'></span>//func.h
            #ifndef FUNC_H_
            #define FUNC_H_

            void func();

            #endif
            </pre>
        </p></li>
    </ul>
    <a href='#title'><span class='glyphicon-menu-up'></span></a>
</div>

<div class='jumbotron col-md-12 heliList' id='2'>
    <h2>Passing Values</h2>
    <ul>
        <li><p><span class='glyphicon-remove'></span>
            &bull; Parameters are passed into a function by declaring them inside the parentheses of a function definition and passing them in the parentheses of a function call.
            &bull; A function call must match the function signature or it will error out.
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            &bull; By default, functions in C++ pass variables <i>by value</i>, which only give the calling function a copy of the variable. (Pass-by-Value)
            <br>&bull; By passing in an address to a variable, said variable can be changed in the calling function.
            <pre>
            <span class='glyphicon-remove'></span>int iterateUp(int &amp;num) {
                return num++;
            }
            </pre>
            <br>&bull; You can prevent any dangerous issues with passed in references by making it <b>const</b>. This makes the value in that referenced address <i>read-only</i>.
            <pre><span class='glyphicon-remove'></span>int iterateUp(const int &amp;num) { }</pre>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            &bull; One main reason references were created for C++ was to allow Call-by-Reference for functions so that you can pass large object.
            <br>&bull; It's important to undertstand that values are passed to and from a function on a small data structure called a <i>stack</i>.
            <br>&bull; The stack is a small space and it requires processing power to manage it, because it's a data structure.
            <br>&bull; So passing large values to a function requires copying large amounts of data onto the stack, which often times doesn't have enough room and computationally expensive.
            <br>&bull; It's going to be time consuming, but it can also cause the stack to overflow, which can crash your program and create a security vulnerability.
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            &bull; When you're passing something larger than a simple scalar value like an integer or a long or a double, you're going to want to use a reference.
            <br>&bull; You're almost always going to want to make that a constant reference.
        </p></li>
    </ul>
    <a href='#title'><span class='glyphicon-menu-up'></span></a>
</div>

<div class='jumbotron col-md-12 heliList' id='3'>
    <h2>Automatic and Static Variables</h2>
    <ul>
        <li><p><span class='glyphicon-remove'></span>
            &bull; Storage (variables declared) inside a function block <i>default to automatic storage</i>.
            <br>&bull; Other storage options are available however.
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            &bull; Automatic storage is stored on the stack, which is created fresh for each invocation of the function.
            <br>&bull; Therefore, the value of the variable is not carried over from invocation to invocation. 
            <br>&bull; Each time a function is invoked, a new copy of it's variables is allocated on the stack, and it's initialized.
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            &bull; By declaring a variable as static, it will be set to static storage.
            <br>&bull; Static storage is not stored on the stack, so it's persistent for the life of the entire process.
            <br>&bull; Therefore, a value will be carried from one invocation to another.
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            &bull; Because automatic storage is stored on the stack, it is not suitable for larger objects. 
            <br>&bull; It's always a good idea to avoid using automatic storage for anything larger than a few scalar variables.
        </p></li>
    </ul>
    <a href='#title'><span class='glyphicon-menu-up'></span></a>
</div>

<div class='jumbotron col-md-12 heliList' id='4'>
    <h2>Returning Variables</h2>
    <ul>
        <li><p><span class='glyphicon-remove'></span>
            &bull; Just like passing values to a function, return values are <i>copied to</i> and <i>returned on</i> the <b>stack</b>.
            <br>&bull; This means you cannot return anything very large, or at least would have to by reference.
            <pre>
            <span class='glyphicon-remove'></span>const string &amp; func() {
                static string s = "This is a static string";
                return s;
            }

            int main() {
                printf("returned value is %s\n", func().c_str());
                return0;
            }
            </pre>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            &bull; Notice in the func() method that the string was declared as static. That's because local storage inside a function defaults to automatic, and only lasts as long as the function is operating, and stores it on the stack.
            <br>&bull; In order to return a reference, it has to be a reference to something in <b>static storage space</b>.
            <br>&bull; Also, the other reason is that automatic storage space is stored on the stack, so we wouldn't want to store a large string in there.
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            &bull; Also notice the function is declared as constant because, then we could actually change the string in the caller, and then next time the function would be called, the string would be different.
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            &bull; In Summary: You return things from a function using the return statement.
            <br>&bull; You declare the type of the return value in the function definition.
            <br>&bull; By default, things that you return are returned on the stack in automatic storage space.
            <br>&bull; If you need to return something larger, you want to use <i>static storage space</i> and a <i>reference</i>.
        </p></li>
    </ul>
    <a href='#title'><span class='glyphicon-menu-up'></span></a>
</div>

<div class='jumbotron col-md-12 heliList' id='5'>
    <h2>Function Pointers</h2>
    <ul>
        <li><p><span class='glyphicon-remove'></span>
            &bull; In C++, it's possible to take the address of a function and assign it to a pointer. (Function Pointer)
            <br>Let's start with an example:
            <pre>
            <span class='glyphicon-remove'></span>void func(){
                printf("Func");
            }

            int main() {
                void (*fp)() = func; //Function pointer -> func() method
                //void (*fp)() = &amp;func; //Same as above
                fp();
                //(*fp)(); //Same as above, prefered for explicitness
                return 0;
            }
            </pre>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Example - Jump</h3>
            <pre>
            <span class='glyphicon-remove'></span>#include &lt;cstdio&gt;
            using namespace std;

            const char * prompt();
            int jump( const char * );

            void fa() { puts("this is fa()"); }
            void fb() { puts("this is fb()"); }
            void fc() { puts("this is fc()"); }
            void fd() { puts("this is fd()"); }
            void fe() { puts("this is fe()"); }

            void (*funcs[])() = { fa, fb, fc, fd, fe, nullptr };

            int main(int argc, char ** argv) {
                while(jump(prompt()));
                puts("\nDone.");
                return 0;
            }

            const char * prompt() {
                puts("Choose an options:");
                puts("1. Function fa()");
                puts("2. Function fb()");
                puts("3. Function fc()");
                puts("4. Function fd()");
                puts("5. Function fe()");
                puts("Q. Quit.");
                printf(">> ");

                fflush(stdout);                 // flush after prompt
                const int buffsz = 16;          // constant for buffer size
                static char response[buffsz];   // static storage for the response buffer
                fgets(response, buffsz, stdin); // get response from console

                return response
            }

            int jump( const char * rs) {
                char code = rs[0];
                if(code == 'q' || code == 'Q') return 0;

                // count the length of the funcs array
                int func_length = 0;
                while( funcs[func_length] != NULL) func_length++;

                int i = (int) code - '0'; // convert ASCII numeral to int
                i--;      // list is zero-based
                if( i < 0 || i >= func_length) {
                    puts("invalid choice");
                    return 1;
                } else {
                    funcs[i]();
                    return 1;
                }
            }
            </pre>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            &bull; This is a very simple implementation of a really useful technique called a jump table or a jump array.
            <br>&bull; We can use this technique often in console programs that have a little text menu or something.
            <br>&bull; Or we could use it in CGI or web services where, because the web is stateless, when somebody puts in a response from a webpage, then that response, based on whatever that response is, we might need to call a different function.
        </p></li>
    </ul>
    <a href='#title'><span class='glyphicon-menu-up'></span></a>
</div>

<div class='jumbotron col-md-12 heliList' id='6'>
    <h2>Overloading Functions</h2>
    <ul>
        <li><p><span class='glyphicon-remove'></span>
            &bull; In C++ it's possible to have different functions with the same name.
            <br>&bull; The compiler selects which function to call based on the entire function signature, not just the function name.
            <br>&bull; A function will only call the function where the function signature matches, which allows for many functions of the same name with all different signatures.
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            &bull; The return type of a function cannot be its only distinguishing factor. The const-ness of the return type can be though and often is.
            <br>&bull; There are specific rules about how types are promoted to distinguish parameters, so make sure to test overloaded functions.
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            &bull; Overloaded function is a significant area where C++ differs from C. They do not compile in C.
            <br>&bull; In C++, functions are distinguished by their entire signature.
            <br>&bull; So it's possible to have multiple functions with the same name that operate with different parameters, and with different return types.
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
        <pre>
        <span class='glyphicon-remove'></span>// volume of a cube
        double volume(double a) {
            printf("cube of %.31f\n", a);
            return a * a * a;
        }

        // volume of a cylinder
        double volume(double r, double h) {
            const static double _pi = 3.141592653589793;
            printf("cylinder of %.31f x %.31f\n", r, h);
            return _pi * r * r * h;
        }

        // volume of a cuboid
        double volume(double a, double b, double c) {
            printf("cuboid of %.31f x %.31f x %.31f\n", a, b, c);
            return a * b * c;
        }

        int main() {
            printf("Volume of a 2x2x2 cube: %.31f\n", volume(2.0));
            printf("Volume of a cylinder, radius 2, height 2: %.31f\n", volume(2.0, 2.0));
            printf("Volume of a 2x3x4 cuboid: %.31f\n", volume(2.0, 3.0, 4.0));
            return 0;
        }
        </pre>
        </p></li>
    </ul>
    <a href='#title'><span class='glyphicon-menu-up'></span></a>
</div>

<div class='jumbotron col-md-12 heliList' id='7'>
    <h2>Operator Overloading</h2>
    <ul>
        <li><p><span class='glyphicon-remove'></span>
            When you're dealing with simple built-in scaler values, it's usually pretty obvious what most operators will do. Two plus two will generally get you four. But when you're dealing with classes in C++, it's not obvious at all, in fact, <i>C++ operators do no work with class types unless you create specific functions for those operators.</i> These functions are called operator overloads or operator functions. There's basically two ways of overloading operators. On is with class methods and the other is with functions.
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            This section will be covering <b>overloading operators with functions.</b> Let's see the code:
            <pre>
            <span class='glyphicon-remove'></span>class A {
                int a;
            public:
                A (const in &amp;a) : a(a) {}
                const int &amp; value() const { return a; }
            };

            int operator + (const A &amp; lhs, const A &amp; rhs) {
                puts("operator + for class A");
                return lhs.value() + rhs.value();
            }

            int main() {
                A a(7);
                A b(42);
                printf("add them up. %d\n", a + b);
                return 0;
            }
            </pre>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            So we have a simple class that overloads an integer and it provides one method for returning a value. Down in main, we declare two variables of type A, and A is our class. One of them has a value of seven, and other has a value of 42. Then we add them up using the + operator  in the printf call. This is our <b>operator overload function.</b> The function signature, you'll notice, returns an integer and then the name of it is operator and a symbol.
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            The <i>operator</i> is a keyword that says that this is an operator overload function. Then the symbol is the operator that's going to be overloaded. There are rules for which operators can be overloaded in what way and how many parameters they have. So we see with the + operator, it takes two parameters; one is the left-hand side and one is the right-hand side. They are name lhs and rhs which is a very standard way to name them. They're of type A with constant and reference because you really want to use references for classes to pass into functions.
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            You'll <i>generally always</i> want to use constant references because they ttend to be rather large and you don't want to pass the entire class on the stack and create problems of stack overflow. This operator + function calls puts, so that we know when it's being called. <i>Don't do this in practice.</i>
            <br>The we return the value of the left-hand side plus the value of the right-hand side as integer. 
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            It's important to note that this is not completely adding any functionality that's not otherwise available. It's always possible to just have an Add method in your class and get the same result. This just allows you to use a normal looking expression in your source code.
            <br>It is a powerful tool and like any powerful tool it can be abused and you should use operator overloading with a lot of caution.
        </p></li>
    </ul>
    <a href='#title'><span class='glyphicon-menu-up'></span></a>
</div>

<div class='jumbotron col-md-12 heliList' id='8'>
    <h2>Defining a Variable Number of Arguments</h2>
    <ul>
        <li><p><span class='glyphicon-remove'></span>
            &bull; For times when a function needs to take a varying number of arguments, C++ provides <b>variadic functions.</b>
            <br>&bull; Let's look at the code:
            <pre>
            <span class='glyphicon-remove'></span>#include cstdio, cstdarg

            // first argument is int count of remaining args
            // ... remaining args are doubles for average
            double average(const int count, ...) {
                va_list ap;
                int i;
                double total = 0.0;

                va _start(ap, count);
                for(i = 0; i < count; ++i) {
                    total += va_arg(ap, double);
                }
                va_end(ap);
                return total / count;
            }

            // works like printf, format plus args
            int message(const char * fmt, ...) {
                va_list ap;
                va_start(ap, fmt);
                int rc = vfprintf(stdout, fmt, ap);
                puts("");
                va_end(ap);
                return rc;
            }

            int main() {
                message("This is a message");
                message("Average: %1f", average(5, 25.0, 35.7, 50.1, 127.6, 75.0));
                return 0;
            }
            </pre>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            The first variadic function we have is <i>average</i> which returns a double. It takes an integer which is the count of the number of values that are being averaged, and then it takes a variable number of arguments. Those arguments are double which will be averaged. We also have a macro called <i>va_list</i> which declares the list of arguments that appear after the first argument, and then there's a va_start macro which points at the va-list variable and the count variable.
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            So our count variable declares where the start of the variable argument list begins. So whatever you put here is the last argument that's not one of the variable list. Then the last one is explicitly declared, in this case it's the count one, which also happens to be the first one, and that's what you put there with va_start. Then in the loop, we have the va_arg macro which grabs the next variable from the list, and it also declared its type there. The va_end needs to be called at the end or it could cause issues.
        </p></li>
    </ul>
    <a href='#title'><span class='glyphicon-menu-up'></span></a>
</div>

<div class='jumbotron col-md-12 heliList' id='9'>
    <h2>Recursion</h2>
    <ul>
        <li><p><span class='glyphicon-remove'></span>
            &bull; A <b>recursive</b> function is a function that calls itself. 
            <br>&bull; Let's see some code:
            <pre>
            <span class='glyphicon-remove'></span>unsigned long int factorial(unsigned long int n) {
                if(n < 2) return 1;
                return factorial(n - 1) * n;
            }

            int main() {
                unsigned long int n = 7;
                printf("Factorial of %ld is %ld\n", n, factorial(n));
            }
            </pre>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            &bull; Because a recursive function calls itself, it can use a lot of resources.
            <br>&bull; For every recursive function call, memory is allocated for the parameters, for any local variables, for the return value, and for other overhead that you might have in your function. 
            <br>&bull; All of this is allocated on the stack which means that it's very possible to overrun your stack and create a security vulnerability.
            <br>&bull; In fact, a looping version of the factorial problem is more efficient than the recursive version.
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            &bull; So C++ supports recursive functions, but be careful, for problems that may require a lot of iterations.
            <br>&bull; Recursion can quickly use up a lot of resources which can easily create buffer overflow related security vulnerabilities. 
        </p></li>
    </ul>
    <a href='#title'><span class='glyphicon-menu-up'></span></a>
</div>

                    <!-------------------------------------->
                </div>
            </div>
    </main>

    <!-------------------------------------------------------------------------->

    <!-- FOOTER -->
    <footer class="navbar navbar-inverse navbar-fixed-bottom">
        <nav>
            <div class="container">
                <div class="row">
                    <div class="col-md-6 col-sm-6 col-xs-12">
                        <ul>
                            <li>&copy; 2017 <a href="http://www.gabedeyo.com">Gabe Deyo</a></li>
                            <li>|</li>
                            <li><a href="mailto:gabedeyo@gmail.com?subject=Notes">gabedeyo@gmail.com</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>
    </footer>

    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
    <script src="../../../js/selection.js" charset="utf-8"></script>
</body>

</html>
