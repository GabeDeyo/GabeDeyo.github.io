<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Vue.js - Components</title>

    <meta name="viewport" content="width=device-width,initial-scale=1.0, shrink-to-fit=no" />

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="../../../css/page.css">
</head>

<body>

    <!-- Top Navigation -->
    <header id="header">
        <nav class="navbar navbar-inverse">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapsemenu" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a href="../../../index.html" class="navbar-brand">Personal Notes</a>
                </div>

                <div class="collapse navbar-collapse" id="collapsemenu">
                    <ul class="nav navbar-nav">

                        <!-- GAME DEVELOMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Game Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- CONCEPTS -->
                                <li><a href="../../../game/Categories/concepts.html">Concepts <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ENGINE -->
                                <li><a href="../../../game/Categories/engine.html">Engine <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- IMPLEMENTATIONS -->
                                <li><a href="../../../game/Categories/implementations.html">Implementations <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        
                        <!-- PROGRAMMING -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Programming <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- LANGUAGES -->
                                <li><a href="../../Categories/languages.html">Languages <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- ALGORITHMS -->
                                <li><a href="../../Categories/algorithms.html">Algorithms <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PROBLEMS -->
                                <li><a href="../../Categories/problems.html">Problems <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- RANDOM -->
                                <li><a href="../../Categories/random.html">Random <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                        <!-- GABE DEVELOPMENT -->
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Gabe Development <span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <!-- FITNESS PAGE -->
                                <li><a href="../../../gabe/Categories/fitness.html">Fitness <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- STYLE & GROOMING PAGE -->
                                <li><a href="../../../gabe/Categories/style.html">Style <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- FINANCE PAGE -->
                                <li><a href="../../../gabe/Categories/finance.html">Finance <span class="glyphicon-chevron-right"></span></a></li>

                                <!-- PHILOSOPHY PAGE -->
                                <li><a href="../../../gabe/Categories/philosophy.html">Philosophy <span class="glyphicon-chevron-right"></span></a></li>
                            </ul>
                        </li>

                    </ul>
                </div>

            </div>
        </nav>
    </header>

    <!-------------------------------------------------------------------------->

    <!-- Side Navigation -->
    <aside id="side-nav">
        <ul>
          <li><a href="#header">Top</a></li>
          <li class="separator"></li>
          <li><a href="#0">What are Components?</a></li>
          <li><a href='#1'>Using Components</a></li>
          <li><a href='#2'>Props</a></li>
          <li><a href='#3'>Non-Prop Attributes</a></li>
          <li><a href='#4'>Custom Events</a></li>
          <li><a href='#5'>Content Distribution with Slots</a></li>
          <li><a href='#6'>Dynamic Components</a></li>
          <li><a href='#7'>Misc</a></li>
        </ul>
    </aside>

    <!-- MAIN -->
    <main>
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h1 id="title">Vue.js - Components</h1>

                    <div class="jumbotron heliList">
                        <h2>Index</h2>
                        <ul>
                            <li><p><span class="glyphicon-remove"></span>
                                <a href="#0">What are Components?</a>
                                </p>
                            </li>
                            <li><p><span class='glyphicon-remove'></span>
                                <a href='#1'>Using Components</a>
                                </p>
                            </li>
                            <li><p><span class='glyphicon-remove'></span>
                                <a href='#2'>Props</a>
                                </p>
                            </li>
                            <li><p><span class='glyphicon-remove'></span>
                                <a href='#3'>Non-Prop Attributes</a>
                                </p>
                            </li>
                            <li><p><span class='glyphicon-remove'></span>
                                <a href='#4'>Custom Events</a>
                                </p>
                            </li>
                            <li><p><span class='glyphicon-remove'></span>
                                <a href='#5'>Content Distribution with Slots</a>
                                </p>
                            </li>
                            <li><p><span class='glyphicon-remove'></span>
                                <a href='#6'>Dynamic Components</a>
                                </p>
                            </li>
                            <li><p><span class='glyphicon-remove'></span>
                                <a href='#7'>Misc</a>
                                </p>
                            </li>
                        </ul>
                    </div>

<div class="jumbotron col-md-12 heliList" id="0">
    <h2>What are Components?</h2>
    <ul>
        <li><p><span class="glyphicon-remove"></span>
            Components are one of the most powerful features of Vue.
            <p><span class='glyphicon-remove'></span>They help you extend basic HTML elements to encapsulate reusable code.</p>
            <p><span class='glyphicon-remove'></span>At a high level, components are custom elements that Vue's compiler attaches behavior to.</p>
            <p><span class='glyphicon-remove'></span>In some cases, they may also appear as a native HTML element extended with the special <code>is</code> attribute.</p>
        </p></li>
    </ul>
    <a href="#title"><span class="glyphicon-menu-up"></span></a>
</div>

<div class='jumbotron col-md-12 heliList' id='1'>
    <h2>Using Components</h2>
    <ul>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Registration</h3>
            <p><span class='glyphicon-remove'></span>We've learned in previous sections that we can create a new Vue instance with:</p>
            <pre>
            <span class='glyphicon-remove'></span>new Vue({
                el: '#some-element',
                //options
            })
            </pre>
            <p><span class='glyphicon-remove'></span>To register a global component, you can use <code>Vue.component(tagName, options)</code>. For example:</p>
            <pre>
            <span class='glyphicon-remove'></span>Vue.component('my-component', {
                //options
            })
            </pre>
            <p><span class='glyphicon-remove'></span><b>Warning</b> - Note that Vue does not enforce the W3C rules for custom tag names (all-lowercase, must contain a hyphen) though following this convention is considered good practice.</p>
            <p><span class='glyphicon-remove'></span>Once registered, a component can be used in an instances' template as a custom element, <code>&lt;my-component>&lt;/my-component></code>.</p>
            <p><span class='glyphicon-remove'></span>Make sure the component is registered <b>before</b> you instantiate the root Vue instance. Like so:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;div id="example">
                &lt;my-component>&lt;/my-component>
            &lt;/div>
            </pre>
            <pre>
            <span class='glyphicon-remove'></span>// register
            Vue.component('my-component', {
                template: '&lt;div>Acustom component!&lt;/div>'
            })

            // create a root instance
            new Vue({
                el: '#example'
            })
            </pre>
            <p><span class='glyphicon-remove'></span>Which will render:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;div id="example">
                &lt;div>A custom component!&lt;/div>
            &lt;/div>
            </pre>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Local Registration</h3>
            <p><span class='glyphicon-remove'></span>You don't have to register every component globally.</p>
            <p><span class='glyphicon-remove'></span>You can make a component available only in the scope of another instance/component by registering it with the <code>components</code> instance option:</p>
            <pre>
            <span class='glyphicon-remove'></span>var Child = {
                tempalte: '&lt;div>A custom component!&lt;/div>'
            }

            new Vue({
                //...
                components: {
                    // &lt;my-component> will only be available in parent's tempalte
                    'my-component': Child
                }
            })
            </pre>
            <p><span class='glyphicon-remove'></span>The same encapsulation applies for other registerable Vue features, such as directives.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>DOM Template Parsing Caveats</h3>
            <p><span class='glyphicon-remove'></span>When using the DOM as your tempalte (e.g. using the <code>el</code> option to mount an element with existing content), you will be subject to some restrictions that are inherent to how HTML works, because Vue can only retrieve the template content <b>after</b> the browser has parsed and normalized it.</p>
            <p><span class='glyphicon-remove'></span>Most notably, some lements such as <code>&lt;ul></code>, <code>&lt;ol></code>, <code>&lt;table></code> and <code>&lt;select></code> have restrictions on what elements can appear inside them, and some elements such as <code>&lt;option></code> can only appear inside certain other elements.</p>
            <p><span class='glyphicon-remove'></span>This will lead to issues when using custom components with elements that have such restrictions, for example:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;table>
                &lt;my-row>...&lt;/my-row>
            &lt;/table>
            </pre>
            <p><span class='glyphicon-remove'></span>A custom component <code>&lt;my-row></code> will be hoisted out as invalid content, thus causing errors in the eventual rendered output. A workaround is to use the <code>is</code> special attribute:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;table>
                &lt;tr id="my-row>&lt;/tr>
            &lt;/table>
            </pre>
            <p><span class='glyphicon-remove'></span>It should be <b>noted</b> that these limitations do not apply if you are using string templates from one of the following sources:
                <br> &nbsp; &bull; <code>&lt;script type="text/x-template"></code>
                <br> &nbsp; &bull; JavaScript inline template strings
                <br> &nbsp; &bull; <code>.vue</code> components</p>
            <p><span class='glyphicon-remove'></span>Therefore, prefer using string templates whenever possible.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3><code>data</code> Must be a Function</h3>
            <p><span class='glyphicon-remove'></span>Most of the options that can be passed into the Vue constructor can be used in a component, with one special case: <code>data</code> must be a function.</p>
            <p><span class='glyphicon-remove'></span>In fact, if you try like this:</p>
            <pre>
            <span class='glyphicon-remove'></span>Vue.component('my-component', {
                template: '&lt;span>{{ message }}&lt;/span>',
                data: {
                    message: 'hello'
                }
            })
            </pre>
            <p><span class='glyphicon-remove'></span>Then Vue will halt and emit warnings in the console, telling you that <code>data</code> must be a function for component instances.</p>
            <p><span class='glyphicon-remove'></span>It's good to understand why the rules exist though, so let's cheat.</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;div id="example-2">
                &lt;simple-counter>&lt;/simplecounter>
                &lt;simple-counter>&lt;/simplecounter>
                &lt;simple-counter>&lt;/simplecounter>
            &lt;/div>
            </pre>
            <pre>
            <span class='glyphicon-remove'></span>var data = { counter: 0 }

            Vue.component('simple-counter', {
                template: '&lt;button v-on:click="counter += 1">{{ counter }}&lt;/button>',
                // data is technically a function, so Vue won't complain,
                // but we return the same object reference for each component instance.
                data: function() {
                    return data
                }
            })

            new Vue({
                el: '#example-2'
            })
            </pre>
            <p><span class='glyphicon-remove'></span>Since all three component instances share the same <code>data</code> object, incrementing one counter increments them all!</p>
            <p><span class='glyphicon-remove'></span>Let's fix this by instead returning a fresh data object:</p>
            <pre>
            <span class='glyphicon-remove'></span>data: function() {
                return {
                    counter: 0
                }
            }
            </pre>
            <p><span class='glyphicon-remove'></span>Now all our counters each have their own internal state:</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Composing Components</h3>
            <p><span class='glyphicon-remove'></span>Components are meant to be used together, most commonly in parent-child relationships: 
                <br> &nbsp; component A may use component B in its own template.</p>
            <p><span class='glyphicon-remove'></span>They inevitably need to communicate to one another:
                <br> &nbsp; the parent may need to pass data down to the child, and the child may need to inform the parent of something that happened in the child.</p>
            <p><span class='glyphicon-remove'></span>However, it is also very important to keep the parent and the child as decoupled as possible via a clearly-defined interface.</p>
            <p><span class='glyphicon-remove'></span>This ensures each component's code can be written and reasoned about in relative isolation, thus making them more maintainable and potentially easier to reuse.</p>
            <p><span class='glyphicon-remove'></span>In Vue, the parent-child component relationship can be summarized as <b>props down</b>, <b>events up</b>.</p>
            <p><span class='glyphicon-remove'></span>The parent passes data down to the child via <b>props</b>, and the child sends messages to the parent via <b>events</b>.</p>
        </p></li>
    </ul>
    <a href='#title'><span class='glyphicon-menu-up'></span></a>
</div>

<div class='jumbotron col-md-12 heliList' id='2'>
    <h2>Props</h2>
    <ul>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Passing Data with Props</h3>
            <p><span class='glyphicon-remove'></span>Every component instance has its own <b>isolated scope</b>.</p>
            <p><span class='glyphicon-remove'></span>This means you cannot (and should not) directly reference parent data in a child component's template.</p>
            <p><span class='glyphicon-remove'></span>Data can be passed down to a child component using <b>props</b>.</p>
            <p><span class='glyphicon-remove'></span>A <b>prop</b> is a custom attribute for passing information from parent components.</p>
            <p><span class='glyphicon-remove'></span>A child component needs to explicitly declare the props it expects to receive using the <code>props</code> option:</p>
            <pre>
            <span class='glyphicon-remove'></span>Vue.component('child', {
                // declare the props
                props: ['message'],
                // just like data, the prop can be used inside templates
                // and is also made available in the vm as this.message
                template: '&lt;span>{{ message }}&lt;/span>'
            })
            </pre>
            <p><span class='glyphicon-remove'></span>Then we can pass a plain string to it like so:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;child message="hello!">&lt;/child>
            </pre>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>camelCase vs. kebab-case</h3>
            <p><span class='glyphicon-remove'></span>HTML attributes are case-insensitive, so when using non-string templates, camelCased prop names need to use their kebab-case equivalents:</p>
            <pre>
            <span class='glyphicon-remove'></span>Vue.component('child', {
                //camelCase in JavaScript
                props: ['myMessage'],
                template: '&lt;span>{{ myMessage }}&lt;/span>'
            })
            </pre>
            <pre>
            <span class='glyphicon-remove'></span>&lt;!-- kebab-case in HTML -->
            &lt;child my-message="hello">&lt;/child>
            </pre>
            <p><span class='glyphicon-remove'></span>Again, if you're using string templates, then this limitation does not apply.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Dynamic Props</h3>
            <p><span class='glyphicon-remove'></span>Similar to binding a normal attribute to an expression, we can also use <code>v-bind</code> for dynamically binding props to data on the parent.</p>
            <p><span class='glyphicon-remove'></span>Whenever the data is updated in the parent, it will also flow down to the child:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;div>
                &lt;input v-model="parentMsg">
                &lt;br>
                &lt;child v-bind:my-message="parentMsg">&lt;/child>
            &lt;/div>
            </pre>
            <p><span class='glyphicon-remove'></span>It's often simpler to use the shorthand syntax for <code>v-bind</code>:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;child :my-message="parentMsg">&lt;/child>
            </pre>
            <p><span class='glyphicon-remove'></span>If you want to pass all the properties in an object as props, you can use <code>v-bind</code> without an argument (<code>v-bind</code> instead of <code>v-bind:prop-name</code>). For example, given a <code>todo</code> object:</p>
            <pre>
            <span class='glyphicon-remove'></span>todo: {
                text: 'Learn Vue', 
                isComplete: false
            }
            </pre>
            <pre>
            <span class='glyphicon-remove'></span>&lt;todo-item v-bind="todo">&lt;/todo-item>
            </pre>
            <p><span class='glyphicon-remove'></span>Will be equivalent to:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;todo-item 
                v-bind:text="todo.text"
                v-bind:is-complete="todo.isComplete"
            >&lt;/todo-item>
            </pre>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Literal vs. Dynamic</h3>
            <p><span class='glyphicon-remove'></span>A common mistake beginners tend to make is attempting to pass down a number using the literal syntax:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;!-- this passes down a plain string "1" -->
            &lt;comp some-prop="1">&lt;/comp>
            </pre>
            <p><span class='glyphicon-remove'></span>However, since this is a literal prop, its value is passed down as a plain string <code>"1"</code> instead of an actual number.</p>
            <p><span class='glyphicon-remove'></span>If we want to pass down an actual JavaScript number, we need to use <code>v-bind</code> so that its value is evaluated as a JavaScript expression:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;!-- this passes down an actual number -->
            &lt;comp v-bind:some-prop="1">&lt;/comp>
            </pre>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>One-Way Data Flow</h3>
            <p><span class='glyphicon-remove'></span>All props form a <b>one-way-down</b> binding between the child property and the parent one:
                <br> &nbsp; &bull; when the parent property updates, it will flow down to the child, but not the other way around.</p>
            <p><span class='glyphicon-remove'></span>This prevents child components from accidentally mutating the parent's state, which can make your app's data flow harder to reason about.</p>
            <p><span class='glyphicon-remove'></span>In addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value.</p>
            <p><span class='glyphicon-remove'></span>This means you should <b>not</b> attempt to mutate a prop inside a child component. 
                <br> &nbsp; &bull; If you do, Vue will warn you in the console.</p>
            <p><span class='glyphicon-remove'></span>There are usually two cases wher it's tempting to mutate a prop:
                <br> &nbsp; 1. The prop is used to only pass in an initial value, the child component simply wants to use it as a local data property afterwards;
                <br> &nbsp; 2. The prop is passed in as a raw value that needs to be transformed.</p>
            <p><span class='glyphicon-remove'></span>The proper answer to these cases are:</p>
            <p><span class='glyphicon-remove'></span>1. Define a local data property that uses the prop's initial value as its initial value:</p>
            <pre>
            <span class='glyphicon-remove'></span>props: ['initialCounter'],
            data: function() {
                return { counter: this.initialCounter }
            }
            </pre>
            <p><span class='glyphicon-remove'></span>2. Define a computed property that is computed from the prop's value:</p>
            <pre>
            <span class='glyphicon-remove'></span>props: ['size'],
            computed: {
                normalizedSize: function() {
                    return this.size.trim().toLowerCase()
                }
            }
            </pre>
            <p><span class='glyphicon-remove'></span><b>Warning</b> - Note that objects and arrays in JavaScript are passed by reference, so if the prop is an array or object, mutating the object or array itself inside the child <b>will</b> affect parent state.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Prop Validation</h3>
            <p><span class='glyphicon-remove'></span>It is possible for a component to specify requirements for the props it is receiving.</p>
            <p><span class='glyphicon-remove'></span>If a requirement is not met, Vue will emit warnings. This is especially useful when you are authoring a component that is intended to be used by others.</p>
            <p><span class='glyphicon-remove'></span>Instead of defining the props as an array of string, you can use an object with validation requirements:</p>
            <pre>
            <span class='glyphicon-remove'></span>Vue.component('example', {
                props: {
                    // basic type check ('null' means accept any type)
                    propA: Number,
                    // multiple possible types
                    propB: [String, Number],
                    // a required string
                    propC: {
                        type: String
                        required: true
                    },
                    // a number with a default value
                    propD: {
                        type: Number,
                        default: 180
                    },
                    // object/array defaults should be returned from a 
                    // factory function
                    propE: {
                        type: Object,
                        default: function() {
                            return { message: 'hello' }
                        }
                    },
                    // custom validator function
                    propF: {
                        validator: function(value) {
                            return value > 10
                        }
                    }
                }
            })
            </pre>
            <p><span class='glyphicon-remove'></span>The <code>type</code> can be one of the following native constructors:
                <br> &nbsp; &bull; String
                <br> &nbsp; &bull; Number
                <br> &nbsp; &bull; Boolean
                <br> &nbsp; &bull; Function
                <br> &nbsp; &bull; Object
                <br> &nbsp; &bull; Array
                <br> &nbsp; &bull; Symbol</p>
            <p><span class='glyphicon-remove'></span>In addition, <code>type</code> can also be a custom constructor function and the assertion will be made with an <code>instanceof</code> check.</p>
            <p><span class='glyphicon-remove'></span>When prop validation fails, Vue will produce a console warning (if using the development build).</p>
            <p><span class='glyphicon-remove'></span>Note that props are validated <b>before</b> a component instance is created, so within <code>default</code> or <code>validator</code> functions, instance properties such as from <code>data</code>, <code>computed</code>, or <code>methods</code> will not be available.</p>
        </p></li>
    </ul>
    <a href='#title'><span class='glyphicon-menu-up'></span></a>
</div>

<div class='jumbotron col-md-12 heliList' id='3'>
    <h2>Non-Prop Attributes</h2>
    <ul>
        <li><p><span class='glyphicon-remove'></span>
            A non-prop attribute is an attribute that is passed to a component, but does not have a corresponding prop defined.
            <p><span class='glyphicon-remove'></span>While explicitly defined props are preferred for passing information to a child component, authors of component libraries can't always foresee the contexts in which their components might be used. 
                <br> &nbsp; &bull; That's why components can accept arbitrary attributes, which are added to the component's root element.</p>
            <p><span class='glyphicon-remove'></span>For example, imagine we're using a 3rd-party <code>bs-date-input</code> component with a Bootstrap plugin that requires a <code>data-3d-date-picker</code> attribute on the <code>input</code>.
                <br> &nbsp; &bull; We can add this attribute to our component instance:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;bs-date-input data-3d-date-picker="true">&lt;/bs-date-input>
            </pre>
            <p><span class='glyphicon-remove'></span>And the <code>data-3d-date-picker="true"</code> attribute will automatically be added to the root element of <code>bs-date-input</code>.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Replacing/Merging with Existing Attributes</h3>
            <p><span class='glyphicon-remove'></span>Imagine this is the template for <code>bs-date-input</code>:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;input type="date" class="form-control">
            </pre>
            <p><span class='glyphicon-remove'></span>To specify a theme for our date picker plugin, we might need to add a specific class, like this:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;bs-date-input 
                data-3d-date-picker="true"
                class="date-picker-theme-dark"
            >&lt;/bs-date-input>
            </pre>
            <p><span class='glyphicon-remove'></span>In this case, two different values for <code>class</code> defined:
                <br> &nbsp; &bull; <code>form-control</code>, which is set by the component in its template
                <br> &nbsp; &bull; <code>date-picker-theme-dark</code>, which is passed to the component by its parent</p>
            <p><span class='glyphicon-remove'></span>For most attributes, the value provided to the component will replace the value set by the component.</p>
            <p><span class='glyphicon-remove'></span>So for example, passing <code>type="large"</code> will replace <code>type="date"</code> and probably break it!</p>
            <p><span class='glyphicon-remove'></span>Fortunately, the <code>class</code> and <code>style</code> attributes are a little smarter, so both values are marged, making the final value: <code>form-control date-picker-theme-dark</code>.</p>
        </p></li>
    </ul>
    <a href='#title'><span class='glyphicon-menu-up'></span></a>
</div>

<div class='jumbotron col-md-12 heliList' id='4'>
    <h2>Custom Events</h2>
    <ul>
        <li><p><span class='glyphicon-remove'></span>
            We have learned that the parent can pass data down to the child using props, but how do we communicate back to the parent when something happens?
            <p><span class='glyphicon-remove'></span>This is where Vue's custom event system comes in.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Using <code>v-on</code> with Custom Events</h3>
            <p><span class='glyphicon-remove'></span>Every Vue instance implements an <b>event interface</b>, which means it can:
                <br> &nbsp; &bull; Listen to an event using <code>$on(eventName)</code>
                <br> &nbsp; &bull; Trigger an event using <code>$emit(eventName)</code></p>
            <p><span class='glyphicon-remove'></span><b>Warning</b> - Note that Vue's event system is different from the browser's <b>EventTarget API</b>. Though they work similarly, <code>$on</code> and <code>$emit</code> are <b>not</b> aliases for <code>addEventListener</code> and <code>dispatchEvent</code>.</p>
            <p><span class='glyphicon-remove'></span>In addition, a parent component can listen to the events emitted from a child component using <code>v-on</code> directly in the template where the child component is used.</p>
            <p><span class='glyphicon-remove'></span><b>Warning</b> - You cannot use <code>$on</code> to listen to events emitted by children. You must use <code>v-on</code> directly in the template, as in the example below.</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;div id="counter-event-example">
                &lt;p>{{ total }}&lt;/p>
                &lt;button-counter v-on:increment="incrementTotal">&lt;/button-counter>
                &lt;button-counter v-on:increment="incrementTotal">&lt;/button-counter>
            &lt;/div>
            </pre>
            <pre>
            <span class='glyphicon-remove'></span>Vue.component('button-counter', {
                template: '&lt;button v-on:click="incrementCounter">{{ counter }}&lt;/button>',
                data: function() {
                    return {
                        counter: 0
                    }
                },
                methods: {
                    incrementCounter: function() {
                        this.counter += 1
                        this.$emit('increment')
                    }
                }
            })

            new Vue({
                el: '#counter-event-example',
                data: {
                    total: 0
                },
                methods: {
                    incrementTotal: function() {
                        this.total += 1
                    }
                }
            })
            </pre>
            <p><span class='glyphicon-remove'></span>In this example, it's important to note that the child component is still completely decoupled from what happens outside of it.</p>
            <p><span class='glyphicon-remove'></span>All it does is report information about its own activity, just in case a parent component might care.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Binding Native Events to Components</h3>
            <p><span class='glyphicon-remove'></span>There may be times when you want to listen for a native event on the root element of a component.</p>
            <p><span class='glyphicon-remove'></span>In these cases, you can use the <code>.native</code> modifier for <code>v-on</code>. For example:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;my-component v-on:click.native="doTheThing">&lt;/my-component>
            </pre>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>.sync Modifier</h3>
            <p><span class='glyphicon-remove'></span>In some cases we may need "two-way binding" for a prop - in fact, in Vue 1.x this is exactly what the <code>.sync</code> modifier provided.</p>
            <p><span class='glyphicon-remove'></span>When a child component mutates a prop that has <code>.sync</code>, the value change will be reflected in the parent.</p>
            <p><span class='glyphicon-remove'></span>This is conventient, however it leads to maintenance issues in the long run because it breaks the one-way data flow assumption:
                <br> &nbsp; &bull; the code that mutates child props are implicitly affecting parent state.</p>
            <p><span class='glyphicon-remove'></span>This is why the <code>.sync</code> modifier was removed in the 2.0 release.</p>
            <p><span class='glyphicon-remove'></span>However, it's been found that there are indeed cases where it can be useful, especially when shipping reusable components.</p>
            <p><span class='glyphicon-remove'></span>What we need to change is <b>making the code in the child that affects parent state more consistent and explicit.</b></p>
            <p><span class='glyphicon-remove'></span>In Vue 2.3.0+ the <code>.sync</code> modifier is re-introduced for props, but this time, it is just syntax sugar that automatically exapnds into an additional <code>v-on</code> listener:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;comp :foo.sync="bar">&lt;/comp>
            </pre>
            <p><span class='glyphicon-remove'></span>This is expanded into:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;comp :foo="bar" @update:foo="val => bar = val">&lt;/comp>
            </pre>
            <p><span class='glyphicon-remove'></span>For the child component to update <code>foo</code>'s value, it needs to explicitly emit an event instead of mutating the prop:</p>
            <pre>
            <span class='glyphicon-remove'></span>this.$emit('update:foo', newValue)
            </pre>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Form Input Components using Custom Events</h3>
            <p><span class='glyphicon-remove'></span>Custom events can also be used to create custom inputs that work with <code>v-model</code>. Remember:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;input v-model="something">
            </pre>
            <p><span class='glyphicon-remove'></span>is just syntactic sugar for:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;input
                v-bind:value="something"
                v-on:input="something = $event.target.value">
            </pre>
            <p><span class='glyphicon-remove'></span>When used with a component, it instead simplifies to:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;custom-input 
                :value="something"
                @input="value => { something = value }"    
            >&lt;/custom-input>
            </pre>
            <p><span class='glyphicon-remove'></span>So for a component to work with <code>v-model</code>, it should:
                <br> &nbsp; &bull; accept a <code>value</code> prop
                <br> &nbsp; &bull; emit an <code>input</code> event with the new value</p>
            <p><span class='glyphicon-remove'></span>Let's see it in action with a very simple currency input:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;currency-input v-model="price">&lt;/currency-input>
            </pre>
            <pre>
            <span class='glyphicon-remove'></span>Vue.component('currency-input', {
                tempalte: '\
                    &lt;span>\
                        $\
                        &lt;input\
                            ref="input"\
                            v-bind:value="value"\
                            v-on:input="updateValue($event.target.value)">\
                    &lt;/span>\
                ',
                props: ['value'],
                methods: {
                    // Instead of updating the value directly, this
                    // method is used to format and place constraints
                    // on the input's value
                    updateValue: function (value) {
                        var formattedValue = value
                            //Remove whitespace on either side
                            .trim()
                        //Shorten to 2 decimal places
                            .slice(
                                0,
                                value.indexOf('.') === -1
                                    ? value.length
                                    : value.indexOf('.') + 3
                            )
                        // If the value was not already normalized,
                        // manually override it to conform
                        if(formattedValue !== value) {
                            this.$refs.input.value = formattedValue
                        }
                        //Emit the number value through the input event
                        this.$emit('input', Number(formattedValue))
                    }
                }
            })
            </pre>
            <p><span class='glyphicon-remove'></span>The implementation above is pretty naive though.</p>
            <p><span class='glyphicon-remove'></span>For example, users are allowed to enter multiple periods and even letter sometimes.
                <br> &nbsp; &bull; So for an extended and robust currency filter, here it is:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;div id="app">
            &lt;currency-input 
                label="Price" 
                v-model="price"
            >&lt;/currency-input>
            &lt;currency-input 
                label="Shipping" 
                v-model="shipping"
            >&lt;/currency-input>
            &lt;currency-input 
                label="Handling" 
                v-model="handling"
            >&lt;/currency-input>
            &lt;currency-input 
                label="Discount" 
                v-model="discount"
            >&lt;/currency-input>
            
            &lt;p>Total: ${{ total }}&lt;/p>
            &lt;/div>
            </pre>
            <pre>
            <span class='glyphicon-remove'></span>Vue.component('currency-input', {
                template: '\
                    &lt;div>\
                    &lt;label v-if="label">{{ label }}&lt;/label>\
                    $\
                    &lt;input\
                        ref="input"\
                        v-bind:value="value"\
                        v-on:input="updateValue($event.target.value)"\
                        v-on:focus="selectAll"\
                        v-on:blur="formatValue"\
                    >\
                    &lt;/div>\
                ',
                props: {
                    value: {
                        type: Number,
                        default: 0
                    },
                    label: {
                        type: String,
                        default: ''
                    }
                },
                mounted: function () {
                    this.formatValue()
                },
                methods: {
                    updateValue: function (value) {
                        var result = currencyValidator.parse(value, this.value)
                        if (result.warning) {
                            this.$refs.input.value = result.value
                        }
                        this.$emit('input', result.value)
                    },
                    formatValue: function () {
                        this.$refs.input.value = currencyValidator.format(this.value)
                    },
                    selectAll: function (event) {
                        // Workaround for Safari bug
                        // http://stackoverflow.com/questions/1269722/selecting-text-on-focus-using-jquery-not-working-in-safari-and-chrome
                        setTimeout(function () {
                            event.target.select()
                        }, 0)
                    }
                }
            })
            
            new Vue({
                el: '#app',
                data: {
                    price: 0,
                    shipping: 0,
                    handling: 0,
                    discount: 0
                },
                computed: {
                    total: function () {
                        return ((
                            this.price * 100 + 
                            this.shipping * 100 + 
                            this.handling * 100 - 
                            this.discount * 100
                        ) / 100).toFixed(2)
                    }
                }
            })
            </pre>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Customizing Component <code>v-model</code></h3>
            <p><span class='glyphicon-remove'></span>By default, <code>v-model</code> on a component uses <code>value</code> as the prop and <code>input</code> as the event, but some input types such as checkboxes and radio buttons may want to use the <code>value</code> prop for a different purpose.</p>
            <p><span class='glyphicon-remove'></span>Using the <code>modle</code> option can avoid the conflict in such cases:</p>
            <pre>
            <span class='glyphicon-remove'></span>Vue.component('my-checkbox', {
                model: {
                    prop: 'checked',
                    event: 'change'
                },
                props: {
                    checked: Boolean,
                    // this allows using the 'value' prop for a different purpose
                    value: String
                },
                // ...
            })
            </pre>
            <p><span class='glyphicon-remove'></span>The above will be equivalent to:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;my-checkbox 
                :checked="foo"
                @change="val => { foo = val }"
                value="some value"
            >&lt;/my-checkbox>
            </pre>
            <p><span class='glyphicon-remove'></span>Note that you still have to declare the <code>checked</code> prop explicitly.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Non Parent-Child Communication</h3>
            <p><span class='glyphicon-remove'></span>Sometimes two components may need to communicate with one-another but they are not parent/child to each other.</p>
            <p><span class='glyphicon-remove'></span>In simple scenarios, you can use an empty Vue instance as a central event bus:</p>
            <pre>
            <span class='glyphicon-remove'></span>var bus = new Vue()
            </pre>
            <pre>
            <span class='glyphicon-remove'></span>// in component A's method
            bus.$emit('id-selected', 1)
            </pre>
            <pre>
            <span class='glyphicon-remove'></span>// in component B's created hook
            bus.$on('id-selected', function(id) {
                //
            })
            </pre>
            <p><span class='glyphicon-remove'></span>In more complex cases, you should consider employing a dedicated <b>state-management pattern</b>.</p>
        </p></li>
    </ul>
    <a href='#title'><span class='glyphicon-menu-up'></span></a>
</div>

<div class='jumbotron col-md-12 heliList' id='5'>
    <h2>Content Distribution with Slots</h2>
    <ul>
        <li><p><span class='glyphicon-remove'></span>
            When using components, it is often desired to compose them like this:
            <pre>
            <span class='glyphicon-remove'></span>&lt;app>
                &lt;app-header>&lt;/app-header>
                &lt;app-footer>&lt;/app-footer>
            &lt;/app>
            </pre>
            <p><span class='glyphicon-remove'></span>There are two things to note here:
                <br> &nbsp; 1. The <code>&lt;app></code> component does not know what content it will receive. It is decided by the component using <code>&lt;app></code>.
                <br> &nbsp; 2. The <code>&lt;app></code> component very likely has its own tempalte.</p>
            <p><span class='glyphicon-remove'></span>To make the composition work, we need a way to interweave the parent "content" and the component's own template. This is a process called <b>content distribution</b> (or "transclusion" if you're familiar with Angular).</p>
            <p><span class='glyphicon-remove'></span>Vue.js implements a content distribution API that is modeled after the current <b>Web Components</b> spec draft, using the special  <code>&lt;slot></code> element to serve as distribution outlets for the original content.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Compilation Scope</h3>
            <p><span class='glyphicon-remove'></span>Before we dig into the API, let's first clarify which scope the contents are compiled in. Imagine a template like this:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;child-component>
                {{ message }}
            &lt;/child-component>
            </pre>
            <p><span class='glyphicon-remove'></span>Consider if the <code>message</code> should be bound to the parent's data or the child data?</p>
            <p><span class='glyphicon-remove'></span>A simple rule of thumb for component scope is:
                <br>&bull; <b>Everything in the parent template is compiled in parent scope; everything in the child template is compiled in child scope.</b></p>
            <p><span class='glyphicon-remove'></span>A common mistake is trying to bind a directive to a child property/method in the parent template:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;!-- does NOT work -->
            &lt;child-component v-show="someChildProperty">&lt;/child-component>
            </pre>
            <p><span class='glyphicon-remove'></span>Assuming <code>someChildProperty</code> is a property on the child component, the example above would not work.
                <br> &nbsp; &bull; The parent's template is not aware of the state of a child component.</p>
            <p><span class='glyphicon-remove'></span>If you need to bind child-scope directives on a component root node, you should do so in the child component's own template:</p>
            <pre>
            <span class='glyphicon-remove'></span>Vue.component('child-component', {
                // this does work, because we are in the right scope
                tempalte: '&lt;div v-show="someChildProperty">Child&lt;/div>',
                data: function() {
                    return {
                        someChildProperty: true
                    }
                }
            })
            </pre>
            <p><span class='glyphicon-remove'></span>Similarly, distributed content will be compiled in the parent scope.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Single Slot</h3>
            <p><span class='glyphicon-remove'></span>Parent content will be <b>discarded</b> unless the child component template contains at least one <code>&lt;slot></code> outlet.
                <br> &nbsp; &bull; When there is only one slot with no attributes, the entire content fragment will be inserted at its position in the DOM, replacing the slot itself.</p>
            <p><span class='glyphicon-remove'></span>Anything originally inside the <code>&lt;slot></code> tags is considered <b>fallback content</b>.
                <br> &nbsp; &bull; Fallback content is compiled in the child scope and will only be displayed if the hoisting element is empty and has no content to be inserted.</p>
            <p><span class='glyphicon-remove'></span>Suppose we have a component called <code>my-component</code> with the following template:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;div>
                &lt;h2>I'm the child title&lt;/h2>
                &lt;slot>
                    This will only be displayed if there is no content to be distributed.
                &lt;/slot>
            &lt;/div>
            </pre>
            <p><span class='glyphicon-remove'></span>And a parent that uses the component:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;div>
                &lt;h1>I'm the parent title&lt;/h1>
                &lt;my-component>
                    &lt;p>This is some original content&lt;/p>
                    &lt;p>This is some original content&lt;/p>
                &lt;/my-component>
            &lt;/div>
            </pre>
            <p><span class='glyphicon-remove'></span>The rendered result will be:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;div>
                &lt;h1>I'm the parent title&lt;/h1>
                &lt;div>
                    &lt;h2>I'm the child title&lt;/h2>
                    &lt;p>This is some original content&lt;/p>
                    &lt;p>This is some original content&lt;/p>
                &lt;/div>
            &lt;/div>
            </pre>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Named Slots</h3>
            <p><span class='glyphicon-remove'></span><code>&lt;slot></code> elements have a special attribute, <code>name</code>, which can be used to further customize how content should be distributed.
                <br> &nbsp; &bull; You can have multiple slots with different names.
                <br> &nbsp; &bull; A named slot will match any element that has a corresponsing <code>slot</code> attribute in the content fragment.</p>
            <p><span class='glyphicon-remove'></span>There can still be one unnamed slot, which is the <b>default slot</b> that serves as a catch-all outlet for any unmatched content.
                <br> &nbsp; &bull; If there no default slot, unmatched content will be discarded.</p>
            <p><span class='glyphicon-remove'></span>For example, suppose we have an <code>app-layout</code> component with the following template:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;div class="container">
                &lt;header>
                    &lt;slot name="header">&lt;/slot>
                &lt;/header>
                &lt;main>
                    &lt;slot>&lt;/slot>
                &lt;/main>
                &lt;footer>
                    &lt;slot name="footer">&lt;/slot>
                &lt;/footer>
            &lt;/div>
            </pre>
            <p><span class='glyphicon-remove'></span>Parent markup:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;app-layout>
                &lt;h1 slot="header">Here might be a page title&lt;/h1>

                &lt;p>A paragraph for the main contnet.&lt;/p>
                &lt;p>And another one.&lt;/p>

                &lt;p slot="footer">Here's some contact info&lt;/p>
            &lt;/app-layout>
            </pre>
            <p><span class='glyphicon-remove'></span>The rendered result will be:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;div class="container>
                &lt;header>
                    &lt;h1>Here might be a page title&lt;/h1>
                &lt;/header>
                &lt;main>
                    &lt;p>A paragraph for the main contnet.&lt;/p>
                    &lt;p>And another one.&lt;/p>
                &lt;/main>
                &lt;footer>
                    &lt;p>Here's some contact info&lt;/p>
                &lt;/footer>
            &lt;/div>
            </pre>
            <p><span class='glyphicon-remove'></span>The content distribution API is a very useful mechanism when desigining component that are meant to be composed together.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Scoped Slots</h3>
            <p><span class='glyphicon-remove'></span>A scoped slot is a special type of slot that functions as a reusable template (that can be passed data to) instead of already-rendered-elements.</p>
            <p><span class='glyphicon-remove'></span>In a child component, simply pass data into a slot as if you are passing props to a component:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;div class="child">
                &lt;slot text="hello from child">&lt;/slot>
            &lt;/div>
            </pre>
            <p><span class='glyphicon-remove'></span>In the parent, a <code>&lt;template></code> element with a special attribute <code>scope</code> must exist, indicating that is a template for a scoped slot.
                <br> &nbsp; &bull; The value of <code>scope</code> is the name of a temporary variable that holds the props object passed from the child:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;div class="parent">
                &lt;child>
                    &lt;template scope="props">
                        &lt;span>hello from parent&lt;/span>
                        &lt;span>{{ props.text }}&lt;/span>
                    &lt;/template>
                &lt;/child>
            &lt;/div>
            </pre>
            <p><span class='glyphicon-remove'></span>If we render the above, the output will be:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;div class="parent">
                &lt;div class="child">
                    &lt;span>hello from parent&lt;/span>
                    &lt;span>hello from child&lt;/span>
                &lt;/div>
            &lt;/div>
            </pre>
            <p><span class='glyphicon-remove'></span>A more typical use case for scoped slots would be a list component that allows the component consumer to customize how each item in the list should be rendered:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;my-awesome-list :items="items">
                &lt;!-- scoped slot can be named too -->
                &lt;template slot="item" scope="props">
                    &lt;li class="my-fancy-item">{{ props.text }}&lt;/li>
                &lt;/template>
            &lt;/my-awesome-list>
            </pre>
            <p><span class='glyphicon-remove'></span>And the tempalte for the list component:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;ul>
                &lt;slot name="item"
                    v-for="item in items"
                    :text="item.text">
                    &lt;!-- fallback content here -->
                &lt;/slot>
            &lt;/ul>
            </pre>
        </p></li>
    </ul>
    <a href='#title'><span class='glyphicon-menu-up'></span></a>
</div>

<div class='jumbotron col-md-12 heliList' id='6'>
    <h2>Dynamic Components</h2>
    <ul>
        <li><p><span class='glyphicon-remove'></span>
            You can use the same mount point and dynamically switch between multiple components using the reserved <code>&lt;component></code> element and dyncamically bind to its <code>is</code> attribute:
            <pre>
            <span class='glyphicon-remove'></span>var vm = new Vue({
                el: '#example',
                data: {
                    currentView: 'home'
                },
                components: {
                    home: {/* ... */},
                    posts: {/* ... */},
                    archive: {/* ... */}
                }
            })
            </pre>
            <pre>
            <span class='glyphicon-remove'></span>&lt;component v-bind:is="currentView">
                &lt;!-- component changes when vm.currentView changes! -->
            &lt;/component>
            </pre>
            <p><span class='glyphicon-remove'></span>If you prefer, you can also bind directly to component objects:</p>
            <pre>
            <span class='glyphicon-remove'></span>var Home = {
                template: '&lt;p>Welcome home!&lt;/p>'
            }

            var vm = new Vue({
                el: '#example',
                data: {
                    currentView: Home
                }
            })
            </pre>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3><code>keep-alive</code></h3>
            <p><span class='glyphicon-remove'></span>If you want to keep the switched-out components in memory so that you can preserve their state or avoid re-rendering, you can wrap a dynamic component in a <code>&lt;keep-alive></code> element:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;keep-alive>
                &lt;component :is="currentView">
                    &lt;!-- inactive components will be cached! -->
                &lt;/component>
            &lt;/keep-alive>
            </pre>
        </p></li>
    </ul>
    <a href='#title'><span class='glyphicon-menu-up'></span></a>
</div>

<div class='jumbotron col-md-12 heliList' id='7'>
    <h2>Misc</h2>
    <ul>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Authoring Reusable Components</h3>
            <p><span class='glyphicon-remove'></span>When authoring components, it's good to keep in mind whether you intend to reuse it somewhere else later.
                <br> &nbsp; &bull; It's OK for one-off components to be tightly-coupled, but reusable components should define a clean public interface and make no assumptions about the context it's used in.</p>
            <p><span class='glyphicon-remove'></span>The API for a Vue component comes in three parts - props, events, and slots:
                <br> &nbsp; &bull; <b>Props</b> allow the external environment to pass data into the component
                <br> &nbsp; &bull; <b>Events</b> allow the component to trigger side effects in the external environment
                <br> &nbsp; &bull; <b>Slots</b> allow the external environment to compose the component with extra content.</p>
            <p><span class='glyphicon-remove'></span>With the dedicated shorthand syntaxes for <code>v-bind</code> and <code>v-on</code>, the intents can be clearly and succinctly conveyed in the template:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;my-component 
                :foo="baz"
                :bar="qux"
                @event-a="doThis"
                @event-b="doThat">
                    &lt;img slot="icon" src="...">
                    &lt;p slot="main-text">Hello!&lt;/p>
            &lt;/my-component>
            </pre>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Child Component Refs</h3>
            <p><span class='glyphicon-remove'></span>Despite the existence of props and events, sometimes you might still need to directly access a child component in JavaScript.
                <br> &nbsp; &bull; To achieve this you have to assign a reference ID to the child component using <code>ref</code>. For example:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;div id="parent">
                &lt;user-profile ref="profile">&lt;/user-profile>
            &lt;/div>
            </pre>
            <pre>
            <span class='glyphicon-remove'></span>var parent = new Vue({ el: '#parent' })
            // access child component instance
            var child = parent.$refs.profile
            </pre>
            <p><span class='glyphicon-remove'></span>When <code>ref</code> is used together with <code>v-for</code>, the ref you get will be an array containing the child components mirroring the data source.</p>
            <p><span class='glyphicon-remove'></span><b>Warning</b> - <code>$refs</code> are only populated after the component has been rendered, and it is not reactive. It is only meant as an escape hatch for direct child manipulation - you should avoid using <code>$refs</code> in templates or computed properties.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Async Components</h3>
            <p><span class='glyphicon-remove'></span>In large applications, we may need to divide the app into smaller chunks and only load a component from the server when it's actually needed.
                <br> &nbsp; &bull; To make that easier, Vue allows you to define your component as a factory function that asynchronously resolves your component definition.
                <br> &nbsp; &bull; Vue will only trigger the factory function when the component actually needs to be rendered and will cache the result for future re-renders. For example:</p>
            <pre>
            <span class='glyphicon-remove'></span>Vue.component('async-example', function(resolve, reject) {
                setTimeout(function() {
                    //Pass the component definition to the resolve callback
                    resolve({
                        template: '&lt;div>I am async!&lt;/div>'
                    })
                }, 1000)
            })
            </pre>
            <p><span class='glyphicon-remove'></span>The factory function receives a <code>resolve</code> callback, which should be called when you have retrieved your component definition from the server.
                <br> &nbsp; &bull; You can also call <code>reject(reason)</code> to indicate the load has failed.
                <br> &nbsp; &bull; The <code>setTimeout</code> here is simply for demonstration; How to retrieve the component is entirely up to you.
                <br> &nbsp; &bull; One recommended approach is to use async components together with <b>Webpack's code-splitting feature</b>:</p>
            <pre>
            <span class='glyphicon-remove'></span>Vue.component('async-webpack-example', function(resolve) {
                // This special require syntax will instruct Webpack to
                // automatically split your built code into bundles which
                // are loaded over Ajax requests.
                require(['./my-async-component'], resolve)
            })
            </pre>
            <p><span class='glyphicon-remove'></span>You can also return a <code>Promise</code> in the factory function, so with Webpack 2 + ES2015 syntax you can do:</p>
            <pre>
            <span class='glyphicon-remove'></span>Vue.component(
                'async-webpack-example',
                () => import('./my-async-component')
            )
            </pre>
            <p><span class='glyphicon-remove'></span>When using <b>local registration</b>, you can also directly provide a function that returns a <code>Promise</code>:</p>
            <pre>
            <span class='glyphicon-remove'></span>new Vue({
                // ...
                components: {
                    'my-component': () => import('./my-async-component')
                }
            })
            </pre>
            <p><span class='glyphicon-remove'></span><b>Warning</b> - If you're a <b>Browserify</b> user that would like to use async components, its creator has unfortunately made it clear that async loading "is not something that Browserify will ever support." Officially, at least. The Browserify community has found some workarounds, which may be helpful for existing and complex application. For all other scenarios, it is recommended simply using Webpack for built-in, first-class async support.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Advanced Async Components</h3>
            <p><span class='glyphicon-remove'></span>Starting in 2.3.0+ the async component factory can also return an object of the following format:</p>
            <pre>
            <span class='glyphicon-remove'></span>const AsyncComp = () => ({
                // The component to laod. Should be a Promise
                component: import('./MyComp.vue'),
                // A component to use while the async component is laoding
                loading: LoadingComp,
                // A component to use if the load fails
                error: ErrorComp,
                // Delay before showing the loading component. Default 200ms;
                delay: 200,
                // The error component will be displayed if a timeout is
                // provided and exceeded. Default: Infinity
                timeout: 3000
            })
            </pre>
            <p><span class='glyphicon-remove'></span>Note that when used as a route component in <code>vue-router</code>, these properties will be ignored because async components are resolved upfront before the route navigation happens.
                <br> &nbsp; &bull; You also need to use <code>vue-router</code> 2.4.0+ if you wish to use the above syntax for route components.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Component Naming Conventions</h3>
            <p><span class='glyphicon-remove'></span>When registering components (or props), you can use kebab-case, camelCase, or PascalCase.</p>
            <pre>
            <span class='glyphicon-remove'></span>// in a component definition
            components: {
                // register using kebab-case
                'kebab-cased-component': {/*...*/},
                // register using camelCase
                'camelCasedComponent': {/*...*/},
                // register using PascalCase
                'PascalCasedComponent': {/*...*/}
            }
            </pre>
            <p><span class='glyphicon-remove'></span>Within HTML templates though, you have to use the kebab-case equivalents:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;!-- always use kebab-case in HTML tempaltes -->
            &lt;kebab-cased-component>&lt;/kebab-cased-component>
            &lt;camel-cased-component>&lt;/camel-cased-component>
            &lt;pascal-cased-component>&lt;/pascal-cased-component>
            </pre>
            <p><span class='glyphicon-remove'></span>When using <i>string</i> templates however, we're not bound by HTML's case-insensitive restrictions.</p>
            <p><span class='glyphicon-remove'></span>That means even in the template, you can reference your components using:
                <br> &nbsp; &bull; kebab-case
                <br> &nbsp; &bull; camelCase or kebab-case if the component has been defined using camelCase
                <br> &nbsp; &bull; kebab-case, cameCase or PascaleCase if the component has been defined using PascalCase</p>
            <pre>
            <span class='glyphicon-remove'></span>components: {
                'kebab-cased-component': {/*...*/},
                camelCasedComponent: {/*...*/},
                PascalCasedComponent: {/*...*/}
            }
            </pre>
            <pre>
            <span class='glyphicon-remove'></span>&lt;kebab-cased-component>&lt;/kebab-cased-component>

            &lt;camel-cased-component>&lt;/camel-cased-component>
            &lt;camelCasedComponent>&lt;/camelCasedComponent>

            &lt;pascal-cased-component>&lt;/pascal-cased-component>
            &lt;pascalCasedComponent>&lt;/pascalCasedComponent>
            &lt;PascalCasedComponent>&lt;/PascalCasedCompoent>
            </pre>
            <p><span class='glyphicon-remove'></span>This means that the PascalCase is the most universal <i>declaration convention</i> and kebab-case is the most universal <i>usafe convention</i>.</p>
            <p><span class='glyphicon-remove'></span>If your component isn't passed content via <code>slot</code> elements, you can even make it self-closing with a <code>/</code> after the name:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;my-component/>
            </pre>
            <p><span class='glyphicon-remove'></span>Again, this <i>only</i> works within string templates, as self-closing custom elements are not valid HTML and your browser's native parser will not understand them.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Recursive Components</h3>
            <p><span class='glyphicon-remove'></span>Components can recursively invoke themselves in their own template.
                <br> &nbsp; &bull; However, they can only do so with the <code>name</code> option:</p>
            <pre>
            <span class='glyphicon-remove'></span>name: 'unique-name-of-my-component'
            </pre>
            <p><span class='glyphicon-remove'></span>When you register a component globally using <code>Vue.component</code>, the global ID is automatically set as the component's <code>name</code> option.</p>
            <pre>
            <span class='glyphicon-remove'></span>Vue.component('unique-name-of-my-component', {
                // ...
            })
            </pre>
            <p><span class='glyphicon-remove'></span>If you're not careful, recursive components can also lead to infinite loops:</p>
            <pre>
            <span class='glyphicon-remove'></span>name: 'stack-overflow',
            tempalte: '&lt;div>&lt;stack-overflow>&lt;/stack-overflow>&lt;/div>'
            </pre>
            <p><span class='glyphicon-remove'></span>A component like the above will result in a "max stack size exceeded" error, so make sure recursive invocation is conditional (i.e. uses a <code>v-if</code> that will eventually be <code>false</code>).</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Circular References Between Components</h3>
            <p><span class='glyphicon-remove'></span>Let's say you're building a file directory tree, like in Finder or File Explorer. You might have a <code>tree-folder</code> component with this tempalte:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;p>
                &lt;span>{{ folder.name }}&lt;/span>
                &lt;tree-folder-contents :children="folder.children"/>
            &lt;/p>
            </pre>
            <p><span class='glyphicon-remove'></span>Then a <code>tree-folder-contents</code> component with this template:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;ul>
                &lt;li v-for="child in children">
                    &lt;tree-folder v-if="child.children" :folder="child"/>
                    &lt;span v-else>{{ child.name }}&lt;/span>
                &lt;/li>
            &lt;/ul>
            </pre>
            <p><span class='glyphicon-remove'></span>When you look closely, you'll see that these components will actually be each other's descendent <i>and</i> ancestor in the render tree - a paradox!</p>
            <p><span class='glyphicon-remove'></span>When registering components globally with <code>Vue.component</code>, this paradox is resolved for you automatically.</p>
            <p><span class='glyphicon-remove'></span>If you're requiring/importing components using a <b>modular system</b>, e.g. via Webpack or Browserify, you'll get an error:</p>
            <pre>
            <span class='glyphicon-remove'></span>Failed to mount component: tempalte or render function not defined.
            </pre>
            <p><span class='glyphicon-remove'></span>To examplain what's happening, let's call our components A and B. 
                <br> &nbsp; &bull; The module system sees that it needs A, but first A needs B, but B needs A, but A needs B, etc., etc.
                <br> &nbsp; &bull; It's stuck in a loop, not knowing how to fully resolve either component without first resolving the other.</p>
            <p><span class='glyphicon-remove'></span>To fix this, we need to give the module system a point at which it can say, "A needs B <i>eventually</i>, but there's no need to resolve B first."</p>
            <p><span class='glyphicon-remove'></span>In our case, let's make the point the <code>tree-folder</code> component.
                <br> &nbsp; &bull; We know the child that creates the paradox is the <code>tree-folder-contents</code> component, so we'll wait until the <code>beforeCreate</code> lifecycle hook to register it:</p>
            <pre>
            <span class='glyphicon-remove'></span>beforeCreate: function() {
                this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue').default
            }
            </pre>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Inline Templates</h3>
            <p><span class='glyphicon-remove'></span>When the <code>inline-template</code> special attribute is present on a child component, the component will use its inner context as its template, rather than treating it as distributed content. This allows more flexible template-authoring.</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;my-component inline-tempalte>
                 &lt;div>
                    &lt;p>These are compiled as the component's own template.&lt;/p>
                    &lt;p>Not parent's transclusion content.&lt;/p>
                 &lt;/div>
            &lt;/my-component>
            </pre>
            <p><span class='glyphicon-remove'></span>However, <code>inline-template</code> makes the scope of your templates harder to reason about.
                <br> &nbsp; &bull; As a best practice, prefer defining tempaltes inside the component using the <code>template</code> option for in a <code>template</code> element in a <code>.vue</code> file.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>X-Templates</h3>
            <p><span class='glyphicon-remove'></span>Another way to define templates is inside of a script element with the type <code>text/x-template</code>, then referencing the template by an id. For example:</p>
            <pre>
            <span class='glyphicon-remove'></span>&lt;script type="text/x-template" id="hello-world-template">
                &lt;p>Hello hello hello&lt;/p>
            &lt;/script>
            </pre>
            <pre>
            <span class='glyphicon-remove'></span>Vue.component('hello-world', {
                tempalte: '#hello-world-template'
            })
            </pre>
            <p><span class='glyphicon-remove'></span>These can be useful for demos with large tempaltes or in extremely small applications, but should otherwise be avoided, because they separate templates from the rest of the component definition.</p>
        </p></li>
        <li><p><span class='glyphicon-remove'></span>
            <h3>Cheap Static Components with <code>v-once</code></h3>
            <p><span class='glyphicon-remove'></span>Rendering plain HTML elements is very fast in Vue, but sometimes you might have a component that contains <b>a lot</b> of static content.</p>
            <p><span class='glyphicon-remove'></span>In these cases, you can ensure the it's only evaluated once and then cached by adding the <code>v-once</code> directive to the root element, like so:</p>
            <pre>
            <span class='glyphicon-remove'></span>Vue.component('terms-of-service', {
                template: '\
                    &lt;div v-once>\
                        &lt;h1>Terms of Service&lt;/h1>\
                        ... a lot of static content ...\
                    &lt;/div>\
                '
            })
            </pre>
        </p></li>
    </ul>
    <a href='#title'><span class='glyphicon-menu-up'></span></a>
</div>

                    <!-------------------------------------->
                </div>
            </div>
    </main>

    <!-------------------------------------------------------------------------->

    <!-- FOOTER -->
    <footer class="navbar navbar-inverse navbar-fixed-bottom">
        <nav>
            <div class="container">
                <div class="row">
                    <div class="col-md-6 col-sm-6 col-xs-12">
                        <ul>
                            <li>&copy; 2017 <a href="http://www.gabedeyo.com">Gabe Deyo</a></li>
                            <li>|</li>
                            <li><a href="mailto:gabedeyo@gmail.com?subject=Notes">gabedeyo@gmail.com</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>
    </footer>

    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
    <script src="../../../js/selection.js" charset="utf-8"></script>
</body>

</html>
